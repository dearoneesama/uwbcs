<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Table of contents</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>

</style>
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body class="vscode-light">
        <h1 id="table-of-contents">Table of contents</h1>
<ul>
<li><a href="#lec-1-95">lec 1. 9.5</a></li>
<li><a href="#lec2-910">lec 2. 9.10</a></li>
<li><a href="#tut-1-911">tut 1. 9.11</a></li>
<li><a href="#lec-3-912">lec 3. 9.12</a></li>
<li><a href="#lec-4-917">lec 4. 9.17</a></li>
<li><a href="#tut-2-918">tut 2. 9.18</a></li>
<li><a href="#lec-5-919">lec 5. 9.19</a></li>
<li><a href="#lec-6-924">lec 6. 9.24</a></li>
<li><a href="#tut-3-925">tut 3. 9.25</a></li>
<li><a href="#lec-7-926">lec 7. 9.26</a></li>
<li><a href="#lec-8-101">lec 8. 10.1</a></li>
<li><a href="#tut-4-102">tut 4. 10.2</a></li>
<li><a href="#lec-9-103">lec 9. 10.3</a></li>
<li><a href="#lec-10-108">lec 10. 10.8</a></li>
<li><a href="#tut-5-109">tut 5. 10.9</a></li>
<li><a href="#lec-11-1010">lec 11. 10.10</a></li>
<li><a href="#lec-12-1022">lec 12. 10.22</a></li>
<li><a href="#tut-6-1023">tut 6. 10.23</a></li>
<li><a href="#lec-13-1024">lec 13. 10.24</a></li>
<li><a href="#lec-14-1029">lec 14. 10.29</a></li>
<li><a href="#lec-15-1031">lec 15. 10.31</a></li>
<li><a href="#lec-16-115">lec 16. 11.5</a></li>
<li><a href="#tut-7-1106">tut 7. 11.06</a></li>
<li><a href="#lec-17-117">lec 17. 11.7</a></li>
<li><a href="#lec-18-1112">lec 18. 11.12</a></li>
<li><a href="#tut-8-1113">tut 8. 11.13</a></li>
<li><a href="#lec-19-1114">lec 19. 11.14</a></li>
<li><a href="#lec-20-1119">lec 20. 11.19</a></li>
<li><a href="#lut-9-1120">lut 9. 11.20</a></li>
<li><a href="#lec-21-1121">lec 21. 11.21</a></li>
</ul>
<h1 id="lec-1-95">lec 1. 9.5</h1>
<ul>
<li>
<p><code>cat /path/file</code></p>
<ul>
<li>displays the content of file</li>
<li>the first slash means starting from the root directory. root is the top of  file hierarchy.</li>
<li>directories are files that store files.</li>
<li>in linux, every text file must end with a newline character <em>including the last line</em>.
<ul>
<li>when making a file, make it in linux.</li>
<li>when printing output, make sure it ends with a newline.</li>
<li><code>cat</code> prints user's input to current output stream</li>
<li><code>-n</code> adds line number in front of input and prints output</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>^C (control+C)</code></p>
<ul>
<li>to force stop a program</li>
</ul>
</li>
<li>
<p><code>ls</code></p>
<ul>
<li>lists the non-hidden files in the current directory</li>
<li><code>ls -a</code> including hidden ones</li>
</ul>
</li>
<li>
<p><code>pwd</code></p>
<ul>
<li>prints the current location of the file hierarchy</li>
</ul>
</li>
<li>
<p><code>cat &gt; file</code></p>
<ul>
<li>writes output to file</li>
<li><code>^D</code> at the beginning of the line stops providing texts (sends <code>EOF</code>).</li>
</ul>
</li>
<li>
<p><code>command &gt; file</code></p>
<ul>
<li>executes the command and store the output to file</li>
</ul>
</li>
<li>
<p><code>cat &lt; file</code></p>
<ul>
<li>feeds input from file to <code>cat</code></li>
</ul>
</li>
</ul>
<pre><code class="language-bash"><div>&gt; cat &gt; a.txt
&gt; hello
&gt; henlo
&gt;^D
&gt; cat a.txt   <span class="hljs-comment"># cat receives a.txt as input and open it, prints contents</span>
hello
henlo
&gt; cat &lt; a.txt <span class="hljs-comment"># opens the file and sends contents to cat via input</span>
hello
henlo
&gt;
</div></code></pre>
<ul>
<li>
<p><code>*.txt</code></p>
<ul>
<li>wildcard that matches any <code>.txt</code></li>
</ul>
</li>
<li>
<p><code>cat &lt; a.txt &gt; b.txt</code></p>
<ul>
<li>copies <code>a.txt</code> to <code>b.txt</code></li>
</ul>
</li>
</ul>
<h1 id="lec-2-910">lec 2. 9.10</h1>
<ul>
<li><code>cat &gt; file 2&gt; errfile.txt</code>
<ul>
<li>redirects stderr to file</li>
<li>stderr is not buffered, stdout is</li>
</ul>
</li>
</ul>
<p><strong>term.</strong> pipes <code>|</code> allow us to take output from one program and redirect it as input to another program.</p>
<p><strong>eg.</strong> how many words are there in the first 20 lines of <code>file.txt</code>?</p>
<pre><code class="language-bash"><div>head -20 file.txt | wc -w <span class="hljs-comment"># wc: word count</span>
</div></code></pre>
<ul>
<li><code>head</code> gives first 10 lines; <code>head -n num</code> gives first num lines.</li>
</ul>
<p><strong>eg.</strong> have <code>words.txt</code> and <code>words2.txt</code>, each contains a list of words separated by lines. print the words without duplicate.</p>
<pre><code class="language-bash"><div>cat words*.txt | sort | uniq
<span class="hljs-comment"># sort: sorts lines</span>
<span class="hljs-comment"># uniq: removes adjacent duplicate items</span>
</div></code></pre>
<p><strong>eg.</strong> how to pass result of command as arguments to another command?
<code>files.txt</code> contains a list of file names</p>
<pre><code class="language-bash"><div>wc -w $(cat files.txt)
<span class="hljs-comment"># same as</span>
wc -w hhh.txt ggg.txt
</div></code></pre>
<p>double suppress matching patterns, single quote supress everything
<strong>eg.</strong></p>
<pre><code class="language-bash"><div>&gt; <span class="hljs-built_in">echo</span> <span class="hljs-string">"hello, the date is <span class="hljs-variable">$(date)</span> and you are <span class="hljs-variable">$(whoami)</span> file*.txt"</span>
<span class="hljs-comment"># hello, the date is Tue Sep 10 14:56:18 EDT 2019 and you are xxxyyy file*.txt</span>

&gt; <span class="hljs-built_in">echo</span> <span class="hljs-string">'hello, the date is $(date) and you are $(whoami) file*.txt'</span>
<span class="hljs-comment"># hello, the date is $(date) and you are $(whoami) file*.txt</span>
</div></code></pre>
<h4 id="extended-global-regular-expression-print">extended global regular expression print</h4>
<ul>
<li>
<p><code>egrep pattern file(s)</code></p>
<ul>
<li>prints each line that matches pattern</li>
<li><strong>eg.</strong> <code>egrep &quot;(cs246|CS246)&quot; file.txt</code></li>
</ul>
</li>
<li>
<p><code>pat1|pat2|pat3</code></p>
</li>
<li>
<p><code>(pattern)</code></p>
</li>
<li>
<p><code>[a-Z]</code> <code>[a-z]</code> <code>[A-z]</code> <code>[A-Za-z]</code></p>
</li>
<li>
<p><code>[^...]</code></p>
</li>
<li>
<p><code>?</code></p>
<ul>
<li><strong>eg.</strong> <code>&quot;cs(-|_| )?246&quot;</code></li>
</ul>
</li>
<li>
<p><code>*</code></p>
</li>
<li>
<p><code>+</code></p>
</li>
<li>
<p><code>.</code></p>
</li>
<li>
<p><code>^...$</code></p>
</li>
</ul>
<p><strong>eg.</strong> matches lines of even length.</p>
<pre><code class="language-bash"><div><span class="hljs-string">"^(..)*$"</span>
</div></code></pre>
<p><strong>eg.</strong> lists files in the current directory that contain exactly one a in their names.</p>
<pre><code class="language-bash"><div>ls | egrep <span class="hljs-string">"^[^a]*a[^a]*$"</span>
</div></code></pre>
<ul>
<li><code>ls -l</code>
<ul>
<li>prints file names in their long forms</li>
<li><code>type permission owner group size time name</code></li>
<li>files can have multiple owners but only one group</li>
<li>
<pre><code class="language-bash"><div>d rwx rwx rwx
<span class="hljs-comment"># type user group else</span>
<span class="hljs-comment">#         d          |        f</span>
<span class="hljs-comment"># r-bit: read        | see the files (ls)</span>
<span class="hljs-comment"># w-bit: write       | can add and remove files</span>
<span class="hljs-comment"># x-bit: runnable    | can navigate (cd)</span>
</div></code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="tut-1-911">tut 1. 9.11</h1>
<p><strong>eg.</strong></p>
<pre><code class="language-bash"><div>wc test.c                         <span class="hljs-comment"># has filename</span>
<span class="hljs-comment"># 18 13 90 testssss.txt</span>
wc &lt; test.c                       <span class="hljs-comment"># no filename</span>
<span class="hljs-comment"># 18 13 90</span>
</div></code></pre>
<p><strong>eg.</strong> prints the word count through echo</p>
<pre><code class="language-bash"><div><span class="hljs-built_in">echo</span> <span class="hljs-string">"dassfsafa"</span> | wc
</div></code></pre>
<p><strong>eg.</strong> gets holidays for south korea in next 30 days</p>
<pre><code class="language-bash"><div>calendar -A 30 | grep <span class="hljs-string">"South Korea"</span>
</div></code></pre>
<p><strong>eg.</strong> input lines, sort lines, dedup and add prefix with duplicate counts, sort numerically, prints last 2 lines.</p>
<pre><code class="language-bash"><div>sort | uniq -c | sort -n | tail -2
</div></code></pre>
<p><code>(tail compose sort compose uniq compose sort)(text)</code></p>
<pre><code class="language-c"><div>A  -&gt;   A   -&gt;  <span class="hljs-number">3</span> A  -&gt; <span class="hljs-number">1</span> C  -&gt; <span class="hljs-number">2</span> B
A       A       <span class="hljs-number">2</span> B     <span class="hljs-number">2</span> B     <span class="hljs-number">3</span> A
B       A       <span class="hljs-number">1</span> C     <span class="hljs-number">3</span> A
C       B
A       B
B       C
</div></code></pre>
<h1 id="lec-3-912">lec 3. 9.12</h1>
<ul>
<li><code>chmod</code>
<ul>
<li>user type:
<ul>
<li><code>u</code> user</li>
<li><code>g</code> group</li>
<li><code>o</code> other roles</li>
<li><code>a</code> all</li>
</ul>
</li>
<li>operator:
<ul>
<li><code>+</code> add permission</li>
<li><code>-</code> subtract permission</li>
<li><code>=</code> set permission exactly</li>
</ul>
</li>
<li>permissions:
<ul>
<li><code>r</code>, <code>w</code>, <code>x</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>eg.</strong> gives other read permissions: <code>chmod o+r file</code>
<strong>eg.</strong> gives exactly rx permissions to all: <code>chmod a=rx file</code>
<strong>eg.</strong> gives writable to group and user: <code>chmod gu+w file</code></p>
<p><strong>term.</strong> shell scripts are files containing sequence of shell commands, executed as a program.</p>
<p><strong>eg.</strong> a shell script <code>sc.sh</code></p>
<pre><code class="language-bash"><div><span class="hljs-meta">#!/bin/bash</span>
date
whoami
<span class="hljs-built_in">pwd</span>
</div></code></pre>
<p><strong>syntax.</strong> variables</p>
<ul>
<li><code>name=content</code> (no spaces)</li>
<li><strong>eg.</strong> <code>x=1</code></li>
<li>use <code>$</code> to fetch contents eg. <code>$x</code></li>
<li>do not use <code>$</code> when assigning</li>
<li>can use <code>${x}</code> eg. <code>echo ${x}yz -&gt; 1yz</code></li>
<li>vars contain strings</li>
<li>special vars: <code>$1</code>, <code>$2</code>, ... are command args</li>
</ul>
<p><strong>eg.</strong> check if a word occurs in the dictionary</p>
<pre><code class="language-bash"><div><span class="hljs-meta">#!/bin/bash</span>
egrep <span class="hljs-string">"^<span class="hljs-variable">$1</span>$"</span> file
</div></code></pre>
<p><strong>syntax.</strong> conditional</p>
<pre><code class="language-bash"><div><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> = <span class="hljs-string">"hello"</span>]; <span class="hljs-keyword">then</span>
    ...
<span class="hljs-keyword">elif</span> [ <span class="hljs-variable">$1</span> = <span class="hljs-string">"world"</span> ]; <span class="hljs-keyword">then</span>
    ...
<span class="hljs-keyword">else</span>
    ...
<span class="hljs-keyword">fi</span>
</div></code></pre>
<p><strong>eg.</strong> checks if a word does not occur in the dictionary</p>
<pre><code class="language-bash"><div>egrep <span class="hljs-string">"^<span class="hljs-variable">${1}</span>$"</span> file &gt; /dev/null
<span class="hljs-comment"># egrep exits with 0 if found, 1 if not found</span>
<span class="hljs-comment"># $? stores status of most recently run program</span>
<span class="hljs-keyword">if</span> [ $? -eq 0 ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"bad password!"</span>
<span class="hljs-keyword">else</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"good password!"</span>
<span class="hljs-keyword">fi</span>
</div></code></pre>
<p><strong>syntax.</strong> function
<strong>eg.</strong> checks if a word does not occur in the dictionary</p>
<pre><code class="language-bash"><div><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">usage</span></span>() {
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"Usage: <span class="hljs-variable">$0</span> password"</span>
    <span class="hljs-built_in">exit</span> 1
}

<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -ne 1 ]; <span class="hljs-keyword">then</span>
    <span class="hljs-comment"># $# is arg count</span>
    <span class="hljs-comment"># -eq -ne</span>
    <span class="hljs-comment"># -lt -le</span>
    <span class="hljs-comment"># -gt -ge</span>
    usage
<span class="hljs-keyword">fi</span>
</div></code></pre>
<p><strong>syntax.</strong> while
<strong>eg.</strong> print numbers from 1 to $1</p>
<pre><code class="language-bash"><div>x=1
<span class="hljs-keyword">while</span> [ <span class="hljs-variable">$x</span> -le <span class="hljs-variable">$1</span> ]; <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span>
    x=$((x+1))
    <span class="hljs-comment"># arithmetic operation format (spaces don't matter)</span>
    <span class="hljs-comment"># eg. $((5+4))</span>
<span class="hljs-keyword">done</span>
</div></code></pre>
<p><strong>syntax.</strong> for
<strong>eg.</strong> loop over a list</p>
<pre><code class="language-bash"><div><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> 1 2 3 4 5; <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span>
<span class="hljs-keyword">done</span>
</div></code></pre>
<p><strong>eg.</strong> rename all <code>.cpp</code> files to <code>.cc</code></p>
<pre><code class="language-bash"><div><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> *.cpp; <span class="hljs-keyword">do</span>
    mv <span class="hljs-variable">$file</span> <span class="hljs-variable">${file%cpp}</span>cc
                <span class="hljs-comment">#  %: removes cpp from end of var content if it exists, else no change</span>
<span class="hljs-keyword">done</span>
</div></code></pre>
<p><strong>eg.</strong> how many times does $1 occur in file $2</p>
<pre><code class="language-bash"><div><span class="hljs-meta">#!/bin/bash</span>
x=0
<span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> $(cat <span class="hljs-variable">$2</span>); <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$word</span> -eq <span class="hljs-variable">$1</span> ]; <span class="hljs-keyword">then</span>
        x=$((x+1))
    <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">echo</span> <span class="hljs-variable">$x</span>
</div></code></pre>
<h1 id="lec-4-917">lec 4. 9.17</h1>
<ul>
<li><code>awk</code>
<ul>
<li><code>awk '{print}' file</code> prints the file line by line like <code>cat</code></li>
<li><code>awk '{print $1,$4}' file</code> splits the file lines, prints 1st and 4th columns, <code>$0</code> is the whole line, <code>$NF</code> is last column</li>
<li><code>awk '{print NR, $0}' file</code> prints lines with line numbers</li>
</ul>
</li>
</ul>
<p><strong>eg.</strong> find the last friday of this month.</p>
<pre><code class="language-bash"><div><span class="hljs-function"><span class="hljs-title">report</span></span>() {
    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$1</span> -eq 31 ]; <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"payday is the 31st"</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">echo</span> <span class="hljs-string">"payday is the <span class="hljs-variable">${1}</span>th"</span>
}

report $(cal | awk <span class="hljs-string">'{print $6}'</span> | egrep <span class="hljs-string">"[0-9]"</span> | tail -1)
                        <span class="hljs-comment"># $6 means the 6-th col</span>
</div></code></pre>
<h3 id="testing">testing</h3>
<ul>
<li>essential part of program development</li>
<li>begins before you program</li>
<li>test suites -&gt; expect behaviors</li>
<li>continue while you are programming</li>
<li>debugging occurs when tests are failing</li>
<li>can't prove program is correct; can prove it is wrong</li>
<li>no general formula</li>
<li>psychological barrier -&gt; don't want to find out you are wrong</li>
<li>generally, developers and tests are different people</li>
</ul>
<h4 id="human-testing">human testing</h4>
<ul>
<li>human look over code to find errors</li>
<li>code inspection walk through</li>
<li>explaining code aloud</li>
</ul>
<h4 id="machine-testing">machine testing</h4>
<ul>
<li>runs program on selected input</li>
<li>can't check anything</li>
<li>black/grey/white box</li>
<li>short &amp; black box testing
<ul>
<li>various classes of inputs</li>
<li>boundaries of valid ranges (edge cases)</li>
<li>multiple boundaries simultaneously (corner cases)</li>
<li>intuition/experience (guess common errors)</li>
<li>extreme cases (within reason)</li>
</ul>
</li>
<li>white box testing
<ul>
<li>execute all logical paths</li>
<li>make sure all functions run</li>
<li>not test
<ul>
<li>invalid input unless a behavior is specified</li>
</ul>
</li>
</ul>
</li>
<li>performance testing</li>
<li>regression testing
<ul>
<li>checking if program changes</li>
</ul>
</li>
</ul>
<h2 id="c">C++</h2>
<p><strong>eg.</strong> hello world</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Hello world!"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// implicitly returns 0</span>
}
</div></code></pre>
<ul>
<li><code>std::cout</code> prints string literals/variables/int/bools/...</li>
<li><code>std::endl</code> end-of-line character and flushes output buffer</li>
<li><code>using namespace std</code> can omit <code>std::</code></li>
</ul>
<h3 id="compiling-c-program">compiling C++ program</h3>
<pre><code class="language-bash"><div>g++ -std=c++14 program.cc -o program
<span class="hljs-comment"># g++14 program.cc -o program</span>
</div></code></pre>
<p><strong>remark.</strong> most C programs work in C++.</p>
<h4 id="io-inputoutput">io input/output</h4>
<ul>
<li><code>std::cin</code></li>
<li><code>std::cout</code></li>
<li><code>std::cerr</code></li>
</ul>
<h4 id="io-operations">io operations</h4>
<ul>
<li><code>&lt;&lt;</code> &quot;put to&quot;</li>
<li><code>&gt;&gt;</code> &quot;get from&quot;</li>
<li>the operators &quot;points&quot; in the direction of information flow</li>
</ul>
<p><strong>eg.</strong> add two numbers</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> x, y;
    <span class="hljs-built_in">cin</span> &gt;&gt; x &gt;&gt; y; <span class="hljs-comment">//ignores whitespace / delimited by whitespace</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; x + y &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<h1 id="tut-2-918">tut 2. 9.18</h1>
<p><strong>eg.</strong> moral: when expanding variables, use quotes</p>
<pre><code class="language-bash"><div>foo=<span class="hljs-string">"bar baz"</span>
egrep <span class="hljs-variable">$foo</span> file   <span class="hljs-comment"># searches "bar" in files baz and file</span>
egrep <span class="hljs-string">"<span class="hljs-variable">$foo</span>"</span> file <span class="hljs-comment"># right</span>
</div></code></pre>
<p><strong>eg.</strong> get new extension names for files</p>
<pre><code class="language-bash"><div><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-function"><span class="hljs-title">rename</span></span> () {
    <span class="hljs-comment"># $1: original name</span>
    <span class="hljs-comment"># $2: old ext</span>
    <span class="hljs-comment"># $3: new ext</span>
    mv <span class="hljs-string">"<span class="hljs-variable">$1</span>"</span> <span class="hljs-string">"<span class="hljs-variable">${1%$2}</span>%3"</span>
}
<span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> *.<span class="hljs-variable">$1</span>; <span class="hljs-keyword">do</span>
    <span class="hljs-comment"># $1: old ext</span>
    <span class="hljs-comment"># $2: new ext</span>
    rename <span class="hljs-string">"<span class="hljs-variable">$file</span>"</span> <span class="hljs-variable">$1</span> <span class="hljs-variable">$2</span>
<span class="hljs-keyword">done</span>
</div></code></pre>
<p><strong>eg.</strong> calculates the mean of numbers in file, throws error upon invalid param</p>
<pre><code class="language-bash"><div><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-keyword">if</span> [ <span class="hljs-variable">$#</span> -ne 1 ]; <span class="hljs-keyword">then</span>
    <span class="hljs-built_in">echo</span> <span class="hljs-string">"<span class="hljs-variable">$0</span> takes exactly one arg."</span>
    <span class="hljs-built_in">exit</span> 1
<span class="hljs-keyword">fi</span>
A=<span class="hljs-string">"0"</span>
B=<span class="hljs-string">"0"</span>
<span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> $(cat <span class="hljs-variable">$1</span>); <span class="hljs-keyword">do</span>
    A=$(( <span class="hljs-variable">$A</span>+<span class="hljs-variable">$n</span> ))
    B=$(( <span class="hljs-variable">$B</span>+1 ))
<span class="hljs-keyword">done</span>
<span class="hljs-built_in">echo</span> <span class="hljs-string">"The sum is <span class="hljs-variable">$(( $A/$B )</span>)."</span>
</div></code></pre>
<p><strong>eg.</strong> a small program that checks whether param is present</p>
<pre><code class="language-bash"><div><span class="hljs-meta">#!/bin/bash</span>
<span class="hljs-built_in">printf</span> <span class="hljs-string">"<span class="hljs-variable">${0}</span>:\n"</span>
<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> 1 2 3; <span class="hljs-keyword">do</span>
    <span class="hljs-keyword">if</span> [ -z <span class="hljs-string">"<span class="hljs-variable">${!i+unset}</span>"</span> ]; <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">printf</span> <span class="hljs-string">"\t<span class="hljs-variable">${i}</span>th param unset\n"</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">printf</span> <span class="hljs-string">"\t<span class="hljs-variable">${i}</span>th param is: <span class="hljs-variable">${!i}</span>\n"</span>
    <span class="hljs-keyword">fi</span>
<span class="hljs-keyword">done</span>
</div></code></pre>
<h1 id="lec-5-919">lec 5. 9.19</h1>
<p><strong>eg.</strong> from last lec.</p>
<pre><code class="language-cpp"><div><span class="hljs-built_in">cin</span> &lt;&lt; x &lt;&lt; y;
</div></code></pre>
<p>q: what if input is not int? what if input too big/small or is char? what if there is no more input?<br>
a: statement fails; the var is set to <code>0</code>, <code>INT_MIN</code> or <code>INT_MAX</code>.</p>
<ul>
<li>if read fails, <code>std::cin.fail()</code> returns true.</li>
<li>if EOF, <code>std::cin.eof()</code> and <code>std::cin.fail()</code> return true.</li>
</ul>
<p><strong>eg.</strong> reads inputs until a bad input/EOF</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">cin</span> &gt;&gt; i;
        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cin</span>.fail()) <span class="hljs-keyword">break</span>;
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}
</div></code></pre>
<p><strong>syntax.</strong> bitwise right shift <code>&gt;&gt;</code></p>
<pre><code class="language-c"><div><span class="hljs-number">21</span>      -&gt;   <span class="hljs-number">0b010101</span>
<span class="hljs-number">21</span> &gt;&gt; <span class="hljs-number">3</span> -&gt;   <span class="hljs-number">0b010</span>
</div></code></pre>
<p>when the left side arg is <code>std::cin</code> it is the input operator called</p>
<pre><code class="language-cpp"><div>    <span class="hljs-built_in">cin</span>   &gt;&gt;  x   &gt;&gt; y
<span class="hljs-comment">//istream    int    int</span>
<span class="hljs-comment">// the expression cin &gt;&gt; x returns cin</span>
<span class="hljs-comment">// hence next setp is</span>
<span class="hljs-comment">//  cin &gt;&gt; y</span>
</div></code></pre>
<p>there is an implicit conversion from <code>istream</code> to <code>bool</code>s. this conversion is the result of looking at <code>cin</code>'s fail bit negated.</p>
<p><strong>eg.</strong> reads inputs until a bad input/EOF</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; i) <span class="hljs-comment">// is implicitly converted to bool</span>
        <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<p><strong>eg.</strong> reads inputs until EOF, skip non-int.</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> i;
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
    {
        <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">cin</span> &gt;&gt; i))  <span class="hljs-comment">// if read fails</span>
        {
            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cin</span>.eof()) <span class="hljs-keyword">break</span>;
            <span class="hljs-built_in">cin</span>.clear();  <span class="hljs-comment">// clear fail bit</span>
                          <span class="hljs-comment">//    inf loop if don't clear</span>
            <span class="hljs-built_in">cin</span>.ignore(); <span class="hljs-comment">// ignore the current input char</span>
                          <span class="hljs-comment">//    inf loop if .ignore() not present</span>
        }
        <span class="hljs-keyword">else</span>
        {
            <span class="hljs-built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="hljs-built_in">endl</span>;
        }
    }
}
</div></code></pre>
<h3 id="io-manipulator-iomanip">io manipulator <code>&lt;iomanip&gt;</code></h3>
<p><strong>eg.</strong> <code>std::hex</code> affects any following ints that will be converted to hex</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iomanip&gt;</span></span>
...
    <span class="hljs-built_in">cout</span> &lt;&lt; hex &lt;&lt; x; <span class="hljs-comment">// converts x to hex for output</span>
    <span class="hljs-built_in">cin</span> &gt;&gt; hex &gt;&gt; y;  <span class="hljs-comment">// reads x and store its hex </span>

    <span class="hljs-built_in">cout</span> &lt;&lt; hex &lt;&lt; x &lt;&lt; dec &lt;&lt; x &lt;&lt; oct &lt;&lt; x &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-comment">// prints hex followed by dex followed by oct</span>

    <span class="hljs-built_in">cin</span> &lt;&lt; hex; <span class="hljs-comment">// this line affects all future inputs </span>
... 
</div></code></pre>
<h3 id="stdstring-in-string"><code>std::string</code> in <code>&lt;string&gt;</code></h3>
<ul>
<li>manages own memory; grows automatically</li>
<li>safe; don't have to worry about <code>'\0'</code></li>
</ul>
<p><strong>eg.</strong> string literal</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
...
    <span class="hljs-built_in">string</span> h = <span class="hljs-string">"hello"</span>; <span class="hljs-comment">// still a c-style string</span>
    <span class="hljs-built_in">string</span> w = <span class="hljs-string">"world"</span>; <span class="hljs-comment">// ...</span>

    <span class="hljs-comment">// equality compare</span>
    h == w;
    <span class="hljs-comment">// lexicographical compare</span>
    h &lt;= w;
    <span class="hljs-comment">// fetch length in O(1)</span>
    h.length();
    <span class="hljs-comment">// fetch individual chars</span>
    h[<span class="hljs-number">0</span>], h[<span class="hljs-number">1</span>], ...;
    <span class="hljs-comment">// concatenation</span>
    hw = h + w;
    hw += h;
        <span class="hljs-comment">// helloworldhello</span>
...
</div></code></pre>
<h4 id="stdstringsubstr"><code>std::string.substr</code></h4>
<pre><code class="language-cpp"><div>h.substr(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// "el"</span>
<span class="hljs-comment">// start from 1st index, wants 2 chars</span>
</div></code></pre>
<h4 id="stdgetlinestdcin-mystr"><code>std::getline(std::cin, my_str)</code></h4>
<p>reads a string <code>my_str</code> including whitespace from <code>std::cin</code>.</p>
<h1 id="lec-6-924">lec 6. 9.24</h1>
<h3 id="fstream"><code>&lt;fstream&gt;</code></h3>
<p><strong>eg.</strong> reads a file and prints it</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    ifstream file{<span class="hljs-string">"file.txt"</span>}; <span class="hljs-comment">// initializing an ifstream; opens file</span>
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span> (file &gt;&gt; s)
        <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<p>anything I can do with <code>std::cin</code>/<code>std::cout</code> I can do with <code>std::ifstream</code>/<code>std::ofstream</code>.</p>
<h3 id="sstream"><code>&lt;sstream&gt;</code></h3>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">string</span>
<span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">istringstream</span>; <span class="hljs-comment">// read from a string</span>
<span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">ostringstream</span>; <span class="hljs-comment">// write to string</span>

<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">intToString</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span>
</span>{
    <span class="hljs-built_in">ostringstream</span> oss;
    oss &lt;&lt; n;
    <span class="hljs-keyword">return</span> oss.str(); <span class="hljs-comment">// returns the string stored in the stringstream</span>
}
</div></code></pre>
<p><strong>eg.</strong> convert a string to int (catch failures)</p>
<pre><code class="language-cpp"><div>...
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"enter a number"</span> &lt;&lt; <span class="hljs-built_in">endl</span>;
        <span class="hljs-built_in">string</span> s;
        <span class="hljs-built_in">cin</span> &gt;&gt; s;
        <span class="hljs-built_in">istringstream</span> iss{s};
        <span class="hljs-keyword">if</span> (iss &gt;&gt; n) <span class="hljs-keyword">break</span>;
    }
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"you entered "</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>;
...
</div></code></pre>
<p><strong>eg.</strong> reading ints from stdin, prints all ints, ignoring non-ints</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; s)
    {
        <span class="hljs-built_in">istringstream</span> iss{s};
        <span class="hljs-keyword">int</span> n;
        <span class="hljs-keyword">if</span> (iss &gt;&gt; n)
            <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
}
</div></code></pre>
<h3 id="default-function-parameter">default function parameter</h3>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printSuiteFile</span><span class="hljs-params">(<span class="hljs-built_in">string</span> name=<span class="hljs-string">"suite.txt"</span>)</span>
                             <span class="hljs-comment">// default param (must be on the right)</span>
</span>{
    ifstream file{name};
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span> (file &gt;&gt; s)
        <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    printSuiteFile();
    printSuiteFile(<span class="hljs-string">"suite2.txt"</span>);
}
</div></code></pre>
<h3 id="function-overloading">function overloading</h3>
<p><strong>eg.</strong> two versions of <code>neg</code> function</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">neg</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{ <span class="hljs-keyword">return</span> -n; }
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">neg</span><span class="hljs-params">(<span class="hljs-keyword">bool</span> b)</span> </span>{ <span class="hljs-keyword">return</span> !b; }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    neg(<span class="hljs-number">3</span>); neg(<span class="hljs-literal">false</span>);
}
</div></code></pre>
<ul>
<li>compilers use the number and types of args to decide which function to call</li>
<li><code>int neg(int n, bool b=1);</code> is not a valid overload for <code>int neg(int n);</code></li>
<li>overload must be unambiguous. must have different arg count or types of args</li>
<li>cannot overload return type</li>
</ul>
<h3 id="struct"><code>struct</code></h3>
<p><strong>eg.</strong> defining a struct</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
    <span class="hljs-keyword">int</span> n;
    Node *next; <span class="hljs-comment">// correct</span>
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
    <span class="hljs-keyword">int</span> n;
    Node next; <span class="hljs-comment">// incorrect</span>
               <span class="hljs-comment">// size cannot be determined</span>
};
</div></code></pre>
<h3 id="const"><code>const</code></h3>
<pre><code class="language-cpp"><div><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> max = <span class="hljs-number">100</span>;
</div></code></pre>
<ul>
<li>can't change value of variable</li>
<li>consts must be initialized with a value</li>
<li>declare as many as possible -- help compiler catch error</li>
</ul>
<pre><code class="language-cpp"><div>Node n1 {<span class="hljs-number">5</span>, <span class="hljs-literal">nullptr</span>}; <span class="hljs-comment">// nullptr </span>
<span class="hljs-keyword">const</span> Node n2 = n1;   <span class="hljs-comment">// immutable copy of n1</span>
</div></code></pre>
<h3 id="reference">reference</h3>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> y = <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> &amp;z = y; <span class="hljs-comment">// reference</span>
z; <span class="hljs-comment">// 10, not *z</span>
</div></code></pre>
<ul>
<li>references are like a const pointer we don't have to dereference.</li>
<li>in all instances <code>z</code> behaves exactly like <code>y</code> (an alias)</li>
</ul>
<p><strong>eg.</strong> increments <code>c</code> by one</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;c)</span> </span>{ ++c; }
</div></code></pre>
<p><strong>remark.</strong> things I cannot do with reference</p>
<ul>
<li>cannot leave uninitialized <strong>eg.</strong> <code>int &amp;z;//wrong</code>
<ul>
<li>must be initialized with data with an address <strong>eg.</strong> <code>int &amp;3; int &amp;x=y+z;//wrong</code>
<ul>
<li>this is a left value reference (that can be on the left on assignments)</li>
</ul>
</li>
<li>can't create pointer to reference <strong>eg.</strong> <code>int &amp;*x; //wrong</code></li>
<li>can't create reference to reference <strong>eg.</strong> <code>int &amp;&amp;z; //wrong</code></li>
<li>can't create array of references <strong>eg.</strong> <code>int &amp;r[3]={y,y,y}; //wrong</code></li>
</ul>
</li>
</ul>
<h1 id="tut-3-925">tut 3. 9.25</h1>
<h2 id="review-on-io-streams">review on i/o streams</h2>
<h3 id="standard-streams-iostream">standard streams <code>&lt;iostream&gt;</code></h3>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>std::cin</code></td>
<td style="text-align:center">is</td>
<td style="text-align:center">read from stdin</td>
</tr>
<tr>
<td style="text-align:center"><code>std::cout</code></td>
<td style="text-align:center">os</td>
<td style="text-align:center">print to stdout</td>
</tr>
<tr>
<td style="text-align:center"><code>std::cerr</code></td>
<td style="text-align:center">os</td>
<td style="text-align:center">print to stderr</td>
</tr>
</tbody>
</table>
<h3 id="file-streams-fstream">file streams <code>&lt;fstream&gt;</code></h3>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>std::ifstream</code></td>
<td style="text-align:center">is</td>
<td style="text-align:center">read from file</td>
</tr>
<tr>
<td style="text-align:center"><code>std::ofstream</code></td>
<td style="text-align:center">os</td>
<td style="text-align:center">write to file</td>
</tr>
</tbody>
</table>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div>ifstream ifs{<span class="hljs-string">"read.txt"</span>};
ofstream ofs{<span class="hljs-string">"write.txt"</span>, ofstream::out | ofstream::app};
                                          <span class="hljs-comment">// append mode</span>
<span class="hljs-built_in">string</span> s;
ifs &gt;&gt; s; <span class="hljs-comment">// read</span>
ofs &lt;&lt; s; <span class="hljs-comment">// write</span>
</div></code></pre>
<h3 id="string-streams-sstream">string streams <code>&lt;sstream&gt;</code></h3>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>std::istringstream</code></td>
<td style="text-align:center">is</td>
<td style="text-align:center">read from string</td>
</tr>
<tr>
<td style="text-align:center"><code>std::ostringstream</code></td>
<td style="text-align:center">os</td>
<td style="text-align:center">write to string</td>
</tr>
</tbody>
</table>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-built_in">string</span> s = <span class="hljs-string">"123"</span>;
<span class="hljs-built_in">istringstream</span> iss{s};
<span class="hljs-keyword">int</span> n;
iss &gt;&gt; n; <span class="hljs-comment">// writes string to int var</span>

<span class="hljs-built_in">ostringstream</span> oss;
oss &lt;&lt; <span class="hljs-number">123</span>;
<span class="hljs-built_in">string</span> s = oss.str(); <span class="hljs-comment">// writes int to string var</span>
</div></code></pre>
<p><strong>eg.</strong> <code>cat</code></p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cat</span><span class="hljs-params">(<span class="hljs-built_in">string</span> filename)</span>
</span>{
    ifstream ifs{filename};
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span> (getline(ifs, s))
        <span class="hljs-built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="hljs-built_in">endl</span>;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">string</span> s;
    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">cin</span> &gt;&gt; s)
        cat(s);
}
</div></code></pre>
<p><strong>eg.</strong> complex multiplication</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sstream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ComplexNumber</span>
{</span>
    <span class="hljs-keyword">int</span> re;
    <span class="hljs-keyword">int</span> im;
};

<span class="hljs-function">ComplexNumber <span class="hljs-title">readNum</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> re, im;
    <span class="hljs-keyword">char</span> sign, buff;
    <span class="hljs-built_in">string</span> myNumStr;
    <span class="hljs-built_in">cin</span> &gt;&gt; myNumStr;
    <span class="hljs-function"><span class="hljs-built_in">istringstream</span> <span class="hljs-title">iss</span><span class="hljs-params">(myNumStr)</span></span>;
    iss &gt;&gt; re &gt;&gt; sign &gt;&gt; im &gt;&gt; buff;
    <span class="hljs-keyword">if</span> (sign == <span class="hljs-string">'-'</span>) im = -im;
    ComplexNumber res = { re, im };
    <span class="hljs-keyword">return</span> res;
}

<span class="hljs-function">ComplexNumber <span class="hljs-title">mult</span><span class="hljs-params">(ComplexNumber a, ComplexNumber b)</span>
</span>{
    ComplexNumber res = 
    {
        a.re * b.re - a.im * b.im,
        a.re * b.im + a.im * b.re
    };
    <span class="hljs-keyword">return</span> res;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    ComplexNumber a = readNum();
    ComplexNumber b = readNum();
    ComplexNumber res = mult(a, b);
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"ANS: \n\treal: "</span> &lt;&lt; res.re &lt;&lt; <span class="hljs-string">"\n\timag: "</span> &lt;&lt; res.im &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<h3 id="overloading">overloading</h3>
<p><strong>eg.</strong> an error</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">char</span> b, <span class="hljs-keyword">int</span> c=<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// signature (int, char, int)</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">char</span> b)</span></span>; <span class="hljs-comment">// signature (int, char)</span>

<span class="hljs-comment">// at this point program runs.</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    foo(<span class="hljs-number">10</span>, <span class="hljs-string">'a'</span>); <span class="hljs-comment">// error! does not which one to call</span>
}
</div></code></pre>
<p><strong>eg.</strong> an error</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;
<span class="hljs-comment">// wrong! signature does not include return type</span>
</div></code></pre>
<h1 id="lec-7-926">lec 7. 9.26</h1>
<h3 id="reference-cont">reference (cont.)</h3>
<p><strong>remark.</strong> references are good for</p>
<ul>
<li>function params<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">inc</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;n)</span></span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ReallyBig</span>;</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(ReallyBig rb)</span></span>; <span class="hljs-comment">// slow due to copying</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">g</span><span class="hljs-params">(ReallyBig &amp;rb)</span></span>; <span class="hljs-comment">// alias, no copy, fast, allows mutation</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">h</span><span class="hljs-params">(<span class="hljs-keyword">const</span> ReallyBig &amp;rb)</span></span>; <span class="hljs-comment">// alias, no copy, fast, no mutation</span>
</div></code></pre>
</li>
</ul>
<h3 id="dynamic-memory-allocation-new--delete">dynamic memory allocation <code>new</code> / <code>delete</code></h3>
<ul>
<li>type-safe, less error-prone</li>
<li>must explicitly tell program when help allocated memory is deleted (otherwise memory leak)</li>
</ul>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>;</span>
Node *np = <span class="hljs-keyword">new</span> Node; <span class="hljs-comment">// uninitialized</span>
Node *np2 = <span class="hljs-keyword">new</span> Node{ <span class="hljs-number">5</span>, <span class="hljs-literal">nullptr</span> };
<span class="hljs-keyword">delete</span> np, np2;
</div></code></pre>
<h3 id="arrays">arrays</h3>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div>Node * myNodes = <span class="hljs-keyword">new</span> Node[<span class="hljs-number">10</span>];
...
<span class="hljs-keyword">delete</span> [] myNodes; <span class="hljs-comment">// used to delete array whose contents are heap objects</span>
</div></code></pre>
<h3 id="returning-by-valuepointerref">returning by value/pointer/ref</h3>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-comment">// returns a value</span>
<span class="hljs-function">Node <span class="hljs-title">getNode</span><span class="hljs-params">()</span>
</span>{
    Node n;
    <span class="hljs-keyword">return</span> n;
}
<span class="hljs-comment">// returns dangling pointer, wrong</span>
<span class="hljs-function">Node *<span class="hljs-title">getNode</span><span class="hljs-params">()</span>
</span>{
    Node n;
    <span class="hljs-keyword">return</span> &amp;n;
}
<span class="hljs-comment">// returns a pointer</span>
<span class="hljs-function">Node *<span class="hljs-title">getNode</span><span class="hljs-params">()</span>
</span>{
    Node *n = <span class="hljs-keyword">new</span> Node;
    <span class="hljs-keyword">return</span> n;
}
</div></code></pre>
<h3 id="overloading-operator">overloading operator</h3>
<p><strong>eg.</strong> overloads <code>+</code>, <code>*</code></p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vec</span>
{</span>
    <span class="hljs-keyword">int</span> x,y;
};
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2)
{
    Vec v
    {
        v1.x + v2.x, v1.y + v2.y
    }
    <span class="hljs-keyword">return</span> v;
}
<span class="hljs-comment">//              left:int *  right:vec</span>
Vec <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">const</span> Vec &amp;v)
{
    <span class="hljs-keyword">return</span>
    {
        k * v.x, k * v.y;
    }; <span class="hljs-comment">// initializes the instance based on return type</span>
}
<span class="hljs-comment">//              left:vec *  right:int</span>
Vec <span class="hljs-keyword">operator</span>*(<span class="hljs-keyword">const</span> Vec &amp;v, <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> k)
{
    <span class="hljs-keyword">return</span> k * v;
}
...
Vec v{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>}, w{<span class="hljs-number">3</span>,<span class="hljs-number">5</span>};
Vec x = v + w;
</div></code></pre>
<p><strong>eg.</strong> overloads <code>&lt;&lt;</code>, <code>&gt;&gt;</code></p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Grade</span>
{</span>
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> theGrade;
};

ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> Grade &amp;g)
{
    out &lt;&lt; g.theGrade &lt;&lt; <span class="hljs-string">"%"</span>;
    <span class="hljs-keyword">return</span> out; <span class="hljs-comment">// important</span>
}

istream &amp;<span class="hljs-keyword">operator</span>&gt;&gt;(istream &amp;in, Grade &amp;g)
{
    in &gt;&gt; g.theGrade;
    <span class="hljs-keyword">if</span> (g.theGrade &lt; <span class="hljs-number">0</span>) g.theGrade = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (g.theGrade &gt; <span class="hljs-number">100</span>) g.theGrade = <span class="hljs-number">100</span>;
    <span class="hljs-keyword">return</span> in;
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Grade g;
    <span class="hljs-comment">// gets grade</span>
    <span class="hljs-built_in">cin</span> &gt;&gt; g;
    <span class="hljs-comment">// prints grade</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; g &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<h2 id="preprocessor">preprocessor <code>#</code></h2>
<ul>
<li>transforms program before compiler sees it</li>
</ul>
<h3 id="include-file"><code>#include FILE</code></h3>
<p>replaces include with contents of specified file</p>
<h3 id="define-var-value"><code>#define VAR VALUE</code></h3>
<ul>
<li>sets preprocessor variable</li>
<li>replaces any instance of VAR by VALUE</li>
</ul>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 10</span>
<span class="hljs-keyword">int</span> x[MAX];
</div></code></pre>
<p>compiler sees</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> x[<span class="hljs-number">10</span>];
</div></code></pre>
<h3 id="define-var"><code>#define VAR</code></h3>
<p>VAR's value is an empty string</p>
<h3 id="conditional-compilation-if-elif-else-endif">conditional compilation <code>#if #elif #else #endif</code></h3>
<p><strong>eg.</strong> decides which type to use</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SECURITYLEVEL 1</span>
...
<span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> SECURITYLEVEL == 1</span>
<span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">elif</span> SECURITYLEVEL == 2</span>
<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
publicKey;
</div></code></pre>
<p><strong>eg.</strong> comments</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">if</span> 0</span>
...
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// this is effectively a comment</span></span>
</div></code></pre>
<p><strong>eg.</strong> compile with -DX</p>
<pre><code class="language-cpp"><div><span class="hljs-comment">// file.cc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; X &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<pre><code class="language-bash"><div><span class="hljs-comment"># terminal</span>
&gt; g++ file.cc -DX=10
&gt; ./a.out
10
</div></code></pre>
<h3 id="ifdef-ifndef"><code>#ifdef #ifndef</code></h3>
<p><strong>eg.</strong> turning on debugging</p>
<pre><code class="language-cpp"><div><span class="hljs-comment">// file.cc</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG</span>
    ...
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
}
</div></code></pre>
<pre><code class="language-bash"><div><span class="hljs-comment"># terminal</span>
$ g++ file.cc -DDEBUG <span class="hljs-comment"># replaces DEBUG to 1</span>
</div></code></pre>
<h2 id="separate-compilation">separate compilation</h2>
<p>split program into multiple files/modules</p>
<ul>
<li>interface<code>.h</code></li>
<li>implementation<code>.cc</code></li>
</ul>
<h1 id="lec-8-101">lec 8. 10.1</h1>
<p><strong>recall.</strong></p>
<ul>
<li>decleration - asserts exsitence</li>
<li>definition - full details, allocates space</li>
</ul>
<p><strong>eg.</strong> separately written program</p>
<pre><code class="language-cpp"><div><span class="hljs-comment">// vec.h</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vec</span> {</span> <span class="hljs-keyword">int</span> x, y; }
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2);
</div></code></pre>
<pre><code class="language-cpp"><div><span class="hljs-comment">// vec.cc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"vec.h"</span></span>
Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec &amp;v1, <span class="hljs-keyword">const</span> Vec &amp;v2)
{
    <span class="hljs-keyword">return</span> { v1.x + v2.x, v1.y + v2.y };
}
</div></code></pre>
<pre><code class="language-cpp"><div><span class="hljs-comment">// main.cc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"vec.h"</span></span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    Vec { <span class="hljs-number">1</span>,<span class="hljs-number">2</span> };
    v = v + v;
    ...
}
</div></code></pre>
<p><strong>remark.</strong> an entity can be declared many times but defined only once.</p>
<p><strong>eg.</strong> compile above files</p>
<pre><code class="language-sh"><div>&gt; g++ vec.cc
<span class="hljs-comment"># linker error</span>
undefined reference to <span class="hljs-string">'main'</span>
...
&gt; g++ main.cc
<span class="hljs-comment"># still linker error</span>
undefined reference to <span class="hljs-string">'operator+(Vec const&amp;, Vec const&amp;)'</span>
...
...
&gt; g++ -c vec.cc   <span class="hljs-comment"># compiles only, do not link</span>
&gt; g++ -c main.cc 
&gt; ls
main.cc main.o vec.cc vec.h vec.o <span class="hljs-comment"># creates .o object files</span>
&gt; g++ main.o vec.o -o main  <span class="hljs-comment"># creates main executable</span>
                            <span class="hljs-comment"># ./main</span>
</div></code></pre>
<p>if change <code>vec.h</code>, then needs to recompile both <code>vec.cc</code> and <code>main.cc</code>.</p>
<h2 id="make">make</h2>
<p>creates makefile taht says which files depend on which other files.</p>
<p><strong>eg.</strong> makefile for above files</p>
<pre><code class="language-makefile"><div><span class="hljs-comment"># makefile</span>
<span class="hljs-comment"># target: dependencies</span>
<span class="hljs-comment">#   recipe</span>

<span class="hljs-section">main: main.o vec.o</span>
    g++ main.o vec.o -o main
<span class="hljs-comment"># ^ must be tab</span>
<span class="hljs-section">main.o: main.cc vec.h</span>
    g++ -c main.cc

<span class="hljs-section">vec.o: vec.cc vec.h</span>
    g++ -c vec.cc

<span class="hljs-meta"><span class="hljs-meta-keyword">.PHONY</span>: clean     # optional target - remove binaries</span>

<span class="hljs-section">clean:</span>
    rm *.o main
</div></code></pre>
<pre><code class="language-sh"><div><span class="hljs-comment"># compiles files with makefile</span>
&gt; make
<span class="hljs-comment"># who project is built</span>
... <span class="hljs-comment"># changes vec.cc</span>
&gt; make
<span class="hljs-comment"># only vec.cc is rebuilt and relinked project</span>
</div></code></pre>
<ul>
<li>make - builds only main
<ul>
<li>what does main depend on?
<ul>
<li>recursively builds dependencies if neccessary</li>
<li>rebuilds main if neccessary</li>
</ul>
</li>
</ul>
</li>
<li>if a target is older than dependencies (last modified) it is rebuilt</li>
</ul>
<p><strong>eg.</strong> rebuilt everything</p>
<pre><code class="language-bash"><div>&gt; make clean &amp;&amp; make
</div></code></pre>
<p><strong>eg.</strong> makefile containing variable</p>
<pre><code class="language-makefile"><div>CXX = g++ <span class="hljs-comment"># compiler name</span>
CXXFLAGS = -std=c++14 -Wall <span class="hljs-comment"># option - enables all warnings</span>
OBJECTS = main.o vec.o
EXEC = main

<span class="hljs-section">${EXEC}: ${OBJECTS}</span>
    ${CXX} ${CXXFLAGS} ${OBJECTS} -o ${EXEC}

<span class="hljs-section">main.o: main.cc vec.h</span>
<span class="hljs-section">vec.o: vec.cc vec.h</span>
<span class="hljs-comment"># can guess recipe is ${CXX} ${CXXFLAGS} -c ....cc</span>

<span class="hljs-meta"><span class="hljs-meta-keyword">.PHONY</span>: clean</span>

<span class="hljs-section">clean:</span>
    rm ${OBJECTS} ${EXEC}
</div></code></pre>
<h3 id="g--mmd"><code>g++ -MMD</code></h3>
<p>creates file containing dependencies in make's format</p>
<p><strong>eg.</strong></p>
<pre><code class="language-bash"><div>&gt; g++ -MMD -c vec.cc <span class="hljs-comment"># creates both .o and .d</span>
&gt; ls
main.cc vec.cc vec.d vec.h vec.o
&gt; cat vec.d
vec.o: vec.cc vec.h
</div></code></pre>
<p><strong>eg.</strong> makefile with auto-updating dependencies</p>
<pre><code class="language-makefile"><div>CXX = g++
CXXFLAGS = -std=c++14 -Wall -MMD -g <span class="hljs-comment"># -g: debug mode</span>
OBJECTS = main.o vec.o
DEPENDS = ${OBJECTS:.o=.d}
EXEC = main

<span class="hljs-section">${EXEC}: ${OBJECTS}</span>
    ${CXX} ${CXXFLAGS} ${OBJECTS} -o ${EXEC}

<span class="hljs-keyword">-include</span> ${DEPENDS} <span class="hljs-comment"># expands these .d files</span>
</div></code></pre>
<p>as the project grows, only needs to add .o files.</p>
<p><strong>eg.</strong> global variable in .h</p>
<pre><code class="language-cpp"><div><span class="hljs-comment">// abc.h</span>
<span class="hljs-keyword">int</span> globalNum; <span class="hljs-comment">// both declaration &amp; definition</span>
<span class="hljs-comment">// every file containing abc.h defines a separate vars, program won't link</span>
</div></code></pre>
<p>place it in .cc file -- not visible</p>
<p>solution:</p>
<pre><code class="language-cpp"><div><span class="hljs-comment">// abc.h</span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> globalNum;
</div></code></pre>
<h1 id="tut-4-102">tut 4. 10.2</h1>
<h3 id="review-on-references">review on references</h3>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;
<span class="hljs-keyword">int</span> &amp;k = n;
++k;
<span class="hljs-built_in">cout</span> &lt;&lt; n; <span class="hljs-comment">// 6</span>
<span class="hljs-built_in">cout</span> &lt;&lt; k; <span class="hljs-comment">// 6</span>
<span class="hljs-built_in">cout</span> &lt;&lt; &amp;k; <span class="hljs-comment">// address, same as &amp;n</span>

<span class="hljs-keyword">int</span> &amp;k = <span class="hljs-number">2</span>; <span class="hljs-comment">// wrong</span>
<span class="hljs-keyword">int</span> &amp;k = n+n; <span class="hljs-comment">// wrong</span>
</div></code></pre>
<ul>
<li>good for passing parameter to functions -- always pass-by-const-ref on types bigger than int<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">const</span> reallyBig &amp;rb)</span></span>;
</div></code></pre>
</li>
<li>references are not nullable</li>
</ul>
<h3 id="review-on-memory-allocation">review on memory allocation</h3>
<table>
<thead>
<tr>
<th style="text-align:center">C</th>
<th style="text-align:center">C++</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>malloc</code></td>
<td style="text-align:center"><code>new</code> / <code>new[]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>free</code></td>
<td style="text-align:center"><code>delete</code> / <code>delete[]</code></td>
</tr>
<tr>
<td style="text-align:center">do not use</td>
<td style="text-align:center">use</td>
</tr>
</tbody>
</table>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> *n = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>{<span class="hljs-number">5</span>};
<span class="hljs-keyword">delete</span> n;
<span class="hljs-keyword">int</span> *m = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">// can be variable</span>
                      <span class="hljs-comment">// instead int m[var] is error since compiler</span>
                      <span class="hljs-comment">// doesn't know size to allocate on stack</span>
<span class="hljs-keyword">delete</span> [] m;
</div></code></pre>
<h1 id="lec-9-103">lec 9. 10.3</h1>
<h3 id="include-guard">include guard</h3>
<pre><code class="language-cpp"><div><span class="hljs-comment">// file.h</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> FILE_H</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FILE_H</span>
...
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
</div></code></pre>
<p>first time the file is included, symbol <code>FILE_H</code> is not defined so file.h is included. subsequencetly <code>VEC_H</code> is defined so contents of vec.h are supressed.</p>
<ul>
<li>always put include guard in .h files</li>
<li>do not put <code>using</code> in .h files - will be forced on any files including the file.</li>
<li>do not compile .h files</li>
<li>do not include .cc files</li>
</ul>
<h2 id="classes-and-objects">classes and objects</h2>
<p>we can put functions inside structs.<br>
<strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-comment">// student.h</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>
{</span>
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">grade</span><span class="hljs-params">()</span></span>;
};
</div></code></pre>
<pre><code class="language-cpp"><div><span class="hljs-comment">// student.cc</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"student.h"</span></span>
<span class="hljs-keyword">float</span> Student::grade()
<span class="hljs-comment">//           ↑</span>
<span class="hljs-comment">// scope resolution operator</span>
{
    <span class="hljs-keyword">return</span> assns * <span class="hljs-number">0.4f</span> + mt * <span class="hljs-number">0.2f</span> + final * <span class="hljs-number">0.4f</span>;
    <span class="hljs-comment">// assns, mt, final are fields of the current object</span>
}
</div></code></pre>
<pre><code class="language-cpp"><div><span class="hljs-comment">// main.cc</span>
    Student s{ <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span> };
    <span class="hljs-comment">//  ↑         ↑</span>
    <span class="hljs-comment">// class    object</span>
    <span class="hljs-built_in">cout</span> &lt;&lt; s.grade() &lt;&lt; <span class="hljs-built_in">endl</span>;
    <span class="hljs-comment">//         ↑</span>
    <span class="hljs-comment">//       method</span>
</div></code></pre>
<ul>
<li><code>object.field</code></li>
<li><code>Class::field</code></li>
</ul>
<p>methods take a hiddent extra parameter <code>this</code> which is the pointer to the object.</p>
<pre><code class="language-cpp"><div>s.grade(); <span class="hljs-comment">// this == &amp;s</span>
</div></code></pre>
<p><strong>eg.</strong> explictly write <code>this</code></p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>
{</span>
    ...
    <span class="hljs-comment">// method written in class</span>
    <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">grade</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;assns * <span class="hljs-number">0.4f</span> + <span class="hljs-keyword">this</span>-&gt;mt * <span class="hljs-number">0.2f</span> + <span class="hljs-keyword">this</span>-&gt;final * <span class="hljs-number">0.4f</span>;
    }
};
</div></code></pre>
<h2 id="initializing-objects">initializing objects</h2>
<p>C-style field init. ok but limited:</p>
<pre><code class="language-cpp"><div>Student billy{ <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span> };
</div></code></pre>
<h3 id="constructor-method">constructor method</h3>
<p>better - write a method that initializes</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>
{</span>
    <span class="hljs-keyword">int</span> assns, mt, final;
    <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">grade</span><span class="hljs-params">()</span></span>;
    Student(<span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final);
};
Student::Student(<span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final)
{
    <span class="hljs-keyword">this</span>-&gt;assns = assns;
    <span class="hljs-keyword">this</span>-&gt;mt = mt;
    <span class="hljs-keyword">this</span>-&gt;final = final;
}
...
Student billy{ <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span> };
<span class="hljs-comment">// if constructor is defined then these are passed to constructor</span>
<span class="hljs-comment">// else this is C-style struct init</span>
</div></code></pre>
<p><strong>eg.</strong> another init method identical to above</p>
<pre><code class="language-cpp"><div>Student billy = Student{ <span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span> };
</div></code></pre>
<p><strong>eg.</strong> heap allocation</p>
<pre><code class="language-cpp"><div>Student *billy = <span class="hljs-keyword">new</span> Student{ <span class="hljs-number">60</span>, <span class="hljs-number">70</span>, <span class="hljs-number">80</span> };
</div></code></pre>
<p>advantage of constructors: default params, overloading, sanity checks<br>
<strong>eg.</strong> default parameters</p>
<pre><code class="language-cpp"><div>Student::Student(<span class="hljs-keyword">int</span> assns=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> mt=<span class="hljs-number">0</span>, <span class="hljs-keyword">int</span> final=<span class="hljs-number">0</span>);
Student Jane { <span class="hljs-number">70</span>, <span class="hljs-number">80</span> }; <span class="hljs-comment">// 70, 80, 0</span>
Student newKid;          <span class="hljs-comment">// 0, 0, 0</span>
                         <span class="hljs-comment">// calls default contructor</span>
</div></code></pre>
<p>every class comes with a default constructors (which just default-constructs all fields that are objects).<br>
<strong>eg.</strong></p>
<pre><code class="language-cpp"><div>Vec v; <span class="hljs-comment">// default constructor does nothing // junk memory?</span>
</div></code></pre>
<p>the built-in constructor goes away if you write any constructor<br>
<strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vec</span>
{</span>
    <span class="hljs-keyword">int</span> x, y;
    Vec (<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)
    {
        <span class="hljs-keyword">this</span>-&gt;x = x;
        <span class="hljs-keyword">this</span>-&gt;y = y;
    }
};
Vec v; <span class="hljs-comment">// error!</span>
</div></code></pre>
<p>sturct containing constants or refs<br>
<strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">My</span>
{</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> myConst;
    <span class="hljs-keyword">int</span> &amp;myRef;
}; <span class="hljs-comment">// must initialize</span>
</div></code></pre>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> z;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">My</span>
{</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> myConst = <span class="hljs-number">5</span>;
    <span class="hljs-keyword">int</span> &amp;myRef = z;
};
</div></code></pre>
<p><strong>eg.</strong> this is not right</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>
{</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> id; <span class="hljs-comment">// doesn't change, but not the same for all students.</span>
    Student(<span class="hljs-keyword">int</span> id)
    {
        <span class="hljs-keyword">this</span>-&gt;id = id; <span class="hljs-comment">// attempts to alter CONST field after initialization</span>
    }
};
</div></code></pre>
<p>steps when objects are created:</p>
<ol>
<li>space is allocated</li>
<li>fields are constructed in declaration order **</li>
<li>constructor runs</li>
</ol>
<h1 id="lec-10-108">lec 10. 10.8</h1>
<p>to initialize <code>const</code>s, we hijack step 2. by the use of member initialization list (MIL)</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>
{</span>
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">int</span> assns, mt, final;
    Student(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> assns, <span class="hljs-keyword">int</span> mt, <span class="hljs-keyword">int</span> final)
        :id{id} <span class="hljs-comment">// field{param}</span>
        ,assns{assns}
        ,mt{mt}
        ,final{final}
    {} <span class="hljs-comment">// function body</span>
};
</div></code></pre>
<ul>
<li><code>const</code>s must be initialized in MIL, other fields can and should be initiailized in MIL.</li>
<li>fileds are initialized in the order they appear in the struct definition, not in MIL order.</li>
<li>MIL is more efficient than initializing in the constructor body
<ul>
<li>without MIL: construction and assignment</li>
<li>with MIL: construction</li>
</ul>
</li>
</ul>
<p><strong>eg.</strong> overloading</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vec</span>
{</span>
    <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;
    Vec() {}            <span class="hljs-comment">// x=0, y=0</span>
    Vec(<span class="hljs-keyword">int</span> x): x{x} {} <span class="hljs-comment">// x=x, y=0</span>
                        <span class="hljs-comment">// uses MIL instead of default field vals</span>
};
</div></code></pre>
<h3 id="magic-methods">magic methods</h3>
<p>every class comes with the following methods:</p>
<ul>
<li>default constructor <code>Student s;</code></li>
<li>copy constructor <code>Student r = s;</code></li>
<li>copy assignment operator <code>Student t; t = s;</code></li>
<li>destructor <code>delete s;</code></li>
<li>move constructor <code>Student t = f(s);</code></li>
<li>move assignment operator <code>Student t; t = f(s);</code></li>
</ul>
<h4 id="copy-constructor">copy constructor</h4>
<p><strong>eg.</strong> copying</p>
<pre><code class="language-cpp"><div>Student billy{ <span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span> };
Student bobby = billy;  <span class="hljs-comment">// calls a constructor that initializes the same type</span>
</div></code></pre>
<p><strong>eg.</strong> own copy constructor</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>
{</span>
    ...
    Student(<span class="hljs-keyword">const</span> Student &amp;o) <span class="hljs-comment">// exactly same functionality as default copy constructor</span>
    :id{o.id}
    ,assns{o.assns}
    ,mt{o.mt}
    ,final{o.final}
    {}
};
</div></code></pre>
<ul>
<li>note must pass by reference to the copy constructor otherwise infinite recursion (seg fault)</li>
</ul>
<p><strong>eg.</strong> deep copy</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
    <span class="hljs-keyword">int</span> data;
    Node *next;

    Node(<span class="hljs-keyword">int</span> data, Node *next)
        :data{data}
        ,next{next}
    {}

    Node(<span class="hljs-keyword">const</span> Node &amp;o)
        :data{data}
        ,next{
            o.next != <span class="hljs-literal">nullptr</span> ? <span class="hljs-keyword">new</span> Node{*o.next} : <span class="hljs-literal">nullptr</span>
                                <span class="hljs-comment">// pass by another object</span>
        }
    {}
};

Node *n = <span class="hljs-keyword">new</span> Node {<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">3</span>, <span class="hljs-literal">nullptr</span>}}};
Node *m = n;
</div></code></pre>
<p><strong>remark.</strong> copy constructor is called when</p>
<ul>
<li>object initialized by another object</li>
<li>object is passed-by-value</li>
<li>object is returned-by-value</li>
</ul>
<p><strong>eg.</strong> be careful for one-parameter constructors</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
    ...
    Node(<span class="hljs-keyword">int</span> data)
        :data{data}, next{<span class="hljs-literal">nullptr</span>}
    {}
};
Node n{<span class="hljs-number">4</span>}; <span class="hljs-comment">// fine</span>
Node m = <span class="hljs-number">5</span>; <span class="hljs-comment">// also calls constructor - implicit conversion</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(Node n)</span> </span>{ <span class="hljs-keyword">return</span> n.data };
f(<span class="hljs-number">4</span>); <span class="hljs-comment">// also works - implicit coversion</span>
</div></code></pre>
<p><strong>eg.</strong> explicit constructor types</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
    ...
    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> data)</span></span>;
};
<span class="hljs-comment">// now f(4) results in error</span>
</div></code></pre>
<h4 id="destructors">destructors</h4>
<p>when an object destructor is destroyed (stack-allocated objects go out of scope and when heap-allocated objects are <code>delete</code>d), destructor runs.</p>
<ol>
<li>destructor body runs</li>
<li>destructors are invoked for fields, in reverse of declaration order</li>
<li>space is deallocated</li>
</ol>
<p><strong>eg.</strong> default destructor</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
    ...
    ~Node() {}
};
</div></code></pre>
<p><strong>eg.</strong> completely delete nodes</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
{</span>
    ...
    ~Node()
    {
        <span class="hljs-keyword">delete</span> next; <span class="hljs-comment">// nothing happens upon deleting nullptr</span>
    }
};
</div></code></pre>
<h1 id="tut-5-109">tut 5. 10.9</h1>
<p><strong>eg.</strong> use radial form to create complex num</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Complex</span>
{</span>
    <span class="hljs-keyword">int</span> re, im;
    Complex(<span class="hljs-keyword">float</span> r, <span class="hljs-keyword">float</span> theta);
};
<span class="hljs-keyword">explicit</span> Complex::Complex(<span class="hljs-keyword">float</span> r, <span class="hljs-keyword">float</span> theta)
    :re{ <span class="hljs-function">r * <span class="hljs-title">cos</span><span class="hljs-params">(theta)</span> }
    ,im</span>{ <span class="hljs-function">r * <span class="hljs-title">sin</span><span class="hljs-params">(theta)</span> }
</span>{
    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"I'm initialized!\n"</span>;
}
</div></code></pre>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"hi"</span>;
<span class="hljs-comment">// is implicitly converted to</span>
<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-built_in">string</span>{<span class="hljs-string">"hi"</span>};
</div></code></pre>
<h1 id="lec-11-1010">lec 11. 10.10</h1>
<p><strong>eg.</strong> confusion</p>
<pre><code class="language-cpp"><div>Student billy{<span class="hljs-number">60</span>,<span class="hljs-number">70</span>,<span class="hljs-number">80</span>};
Student jane = billy; <span class="hljs-comment">// copy constructor called</span>

Student joey; <span class="hljs-comment">// default constructor</span>
joey = billy; <span class="hljs-comment">// copy assignment constructor called (default ver. is shallow)</span>
</div></code></pre>
<h4 id="assignment-operator">assignment operator</h4>
<p><strong>eg.</strong> linked list assignment constructor</p>
<pre><code class="language-cpp"><div>Node&amp; Node::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;o)
{   
    <span class="hljs-keyword">this</span>-&gt;data = o.data;
    <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>-&gt;next;
    <span class="hljs-keyword">this</span>-&gt;next = o.next ? <span class="hljs-keyword">new</span> Node{*o.next} : <span class="hljs-literal">nullptr</span>;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</div></code></pre>
<p><strong>eg.</strong> better linked list assignment constructor</p>
<ul>
<li>checks self assignment</li>
<li>if <code>new</code> fails, prevent next being deleted and pointing to invalid mem</li>
</ul>
<pre><code class="language-cpp"><div>Node&amp; Node::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;o)
{
    <span class="hljs-comment">// checks assigning self to self &lt;- seg fault</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;o)
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    Node *tmp = <span class="hljs-keyword">this</span>-&gt;next;
    <span class="hljs-keyword">this</span>-&gt;next = o.next ? <span class="hljs-keyword">new</span> Node{*o.next} : <span class="hljs-literal">nullptr</span>;
    <span class="hljs-comment">// if new fails, this-&gt;next unchanged, below is not run</span>
    <span class="hljs-keyword">this</span>-&gt;data = o.data;
    <span class="hljs-keyword">delete</span> tmp;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</div></code></pre>
<p><strong>eg.</strong> copy and swap idiom</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;utility&gt;</span></span>

<span class="hljs-keyword">void</span> Node::swap(Node &amp;o)
{
    <span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::swap;
    swap(<span class="hljs-keyword">this</span>-&gt;data, o.data);
    swap(<span class="hljs-keyword">this</span>-&gt;next, o.next);
}
Node&amp; Node::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Node &amp;o)
{
    Node tmp = o; <span class="hljs-comment">// calls copy constructor in current stack frame</span>
    swap(tmp);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    <span class="hljs-comment">// at this point tmp's destructor runs and tmp.next is deleted</span>
}
</div></code></pre>
<h3 id="rvalue-reference">rvalue reference <code>&amp;&amp;</code></h3>
<h4 id="move-constructor">move constructor</h4>
<p><strong>eg.</strong> consider</p>
<pre><code class="language-cpp"><div><span class="hljs-function">Node <span class="hljs-title">plusOne</span><span class="hljs-params">(Node n)</span> <span class="hljs-comment">// copy</span>
</span>{
    <span class="hljs-keyword">for</span> (Node *p = &amp;n; p; p = p-&gt;next)
        ++p-&gt;data;
    <span class="hljs-keyword">return</span> n;
}

Node n{<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">2</span>, <span class="hljs-literal">nullptr</span>}};
Node n2 = plusOne(n);
</div></code></pre>
<ul>
<li>invokes copy constructor <code>Node(const Node&amp;)</code>
<ul>
<li><code>plusOne(n)</code> is not an lvalue
<ul>
<li>c++ allows this since the parameter is const</li>
</ul>
</li>
</ul>
</li>
<li>what happens to the returned node from <code>plusOne(n)</code>?
<ul>
<li>temporary is returned and deleted when this line is complete</li>
</ul>
</li>
<li>in the copy constructor, a copy of the temprorary object is created</li>
<li>if the object in the scope is about to be deleted, why make a copy?
<ul>
<li>steal that object by rvalue reference</li>
</ul>
</li>
</ul>
<p><strong>eg.</strong> rvalue reference</p>
<pre><code class="language-cpp"><div>Node::Node(Node &amp;&amp;o)
    :data{o.data}
    ,next{o.next}
{
    o.next = <span class="hljs-literal">nullptr</span>;
}
</div></code></pre>
<h4 id="move-assignment-operator">move assignment operator</h4>
<pre><code class="language-cpp"><div>Node&amp; Node::<span class="hljs-keyword">operator</span>=(Node &amp;&amp;o)
{
    <span class="hljs-keyword">this</span>-&gt;swap(o);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>; <span class="hljs-comment">// originally &amp;&amp;o is about to be deleted, swap this with</span>
                  <span class="hljs-comment">// &amp;&amp;o, then this-&gt;next is deleted!</span>
}

Node m;
m = plusOne(m);
</div></code></pre>
<ul>
<li>if move constructor/assignment operator is not defined, then copy versions will be run. (fine but slow)</li>
<li>if defined they replace all copy constructor and copy operator= where the argument is a temporary rvalue</li>
<li><code>return n</code> in <code>plusOne</code> returns using the move constructor</li>
</ul>
<p><strong>eg.</strong> another move assignment operator</p>
<pre><code class="language-cpp"><div>Node &amp;Node::<span class="hljs-keyword">operator</span>=(Node &amp;&amp;o)
{
    <span class="hljs-keyword">delete</span> next;
    data = o.data;
    next = o.next;
    o.next = <span class="hljs-literal">nullptr</span>;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</div></code></pre>
<h1 id="lec-12-1022">lec 12. 10.22</h1>
<h3 id="copymove-elision">copy/move elision</h3>
<pre><code class="language-cpp"><div><span class="hljs-function">Vec <span class="hljs-title">makeVec</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> {<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};}
Vec v = makeVec(); <span class="hljs-comment">// skips two move constructor calls</span>
                   <span class="hljs-comment">// returned value written directly to v's memory</span>
</div></code></pre>
<ul>
<li><code>fno-elide-constructors</code> forces all constructors to run</li>
</ul>
<p>in summary, if any of these is written</p>
<ol>
<li>copy constructor <code>Object::Object(Object&amp;)</code></li>
<li>move constructor <code>Object::Object(Object&amp;&amp;)</code></li>
<li>copy assignment operator <code>Object&amp; Object::operator=(Object&amp;)</code></li>
<li>move assignment operator <code>Object&amp; Object::operator=(Object&amp;&amp;)</code></li>
<li>destructor <code>Object::~Object()</code></li>
</ol>
<p>all five usually have to be written.</p>
<h3 id="member-operators">member operators</h3>
<p>left hand side is <code>this</code></p>
<p><strong>remark.</strong> input/output operator should never be member operators</p>
<pre><code class="language-cpp"><div>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="hljs-keyword">const</span> Vec &amp;v);
</div></code></pre>
<h3 id="arrays-of-objects">arrays of objects</h3>
<p><strong>eg.</strong> error</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vec</span>
{</span>
    <span class="hljs-keyword">int</span> x, y;
    Vec(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y): x{x}, y{y} {}
};
Vec *vp = <span class="hljs-keyword">new</span> Vec[<span class="hljs-number">10</span>]; <span class="hljs-comment">// error</span>
Vec arr[<span class="hljs-number">10</span>];           <span class="hljs-comment">// error as entries have to be initialized, but no </span>
                       <span class="hljs-comment">// parameterless constructor defined</span>

<span class="hljs-comment">// walkaround:</span>
<span class="hljs-comment">// 1. make a default constructor</span>
<span class="hljs-comment">// 2. for stack arrays</span>
    Vec arr2[<span class="hljs-number">3</span>] = {Vec{<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}, Vec{<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}, Vec{<span class="hljs-number">0</span>,<span class="hljs-number">0</span>}};
<span class="hljs-comment">// 3. create array of pointers</span>
    Vec **vp2 = <span class="hljs-keyword">new</span> Vec*[<span class="hljs-number">10</span>];
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; ++i) <span class="hljs-keyword">delete</span> vp2[i];
    <span class="hljs-keyword">delete</span> [] vp2;
</div></code></pre>
<h3 id="const-objects">const objects</h3>
<p>compiler ensures that fields are not modified by this method</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>
{</span>
    ...
    <span class="hljs-keyword">mutable</span> <span class="hljs-keyword">int</span> numMethodCalls = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">grade</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
    </span>{
        <span class="hljs-comment">// if want to change a field inside const it has to be 'mutable'</span>
        ++numMethodCalls;
        <span class="hljs-keyword">return</span> ....;
    }
};
</div></code></pre>
<h3 id="static-members">static members</h3>
<p>associated with the class not a particular instance</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Student</span>
{</span>
    ...
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numInstances; <span class="hljs-comment">// memory should not be in .h file -&gt; multiple definition</span>
    Student(<span class="hljs-keyword">int</span> grade): grade{grade}
    {
        ++numInstances;
    }
    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">howMany</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-built_in">cout</span> &lt;&lt; numInstances &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
};

<span class="hljs-comment">// in an cc file, do</span>
<span class="hljs-keyword">int</span> Student::numInstances = <span class="hljs-number">0</span>; <span class="hljs-comment">// acts like a global var for class</span>
</div></code></pre>
<p>static methods can access static members that do not belong to a specific instance</p>
<h3 id="invariants--encapsulation">invariants &amp; encapsulation</h3>
<p><strong>eg.</strong> consider</p>
<pre><code class="language-cpp"><div>Node n1{<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Node{<span class="hljs-number">2</span>, <span class="hljs-literal">nullptr</span>}};
Node n2{<span class="hljs-number">3</span>, <span class="hljs-literal">nullptr</span>};
Node n3{<span class="hljs-number">4</span>, &amp;n2};
<span class="hljs-comment">// when these three go out of scope</span>
<span class="hljs-comment">// all of n1, n2, n3 deleted</span>
<span class="hljs-comment">// n1: node and list reclaimed</span>
<span class="hljs-comment">// n2: node reclaimed</span>
<span class="hljs-comment">// n3: node reclaimed, next already deleted</span>

<span class="hljs-comment">// try to delete n2 twice</span>
<span class="hljs-comment">// delete stack-allocated memory - undefined behavior</span>
<span class="hljs-comment">// double free error</span>
</div></code></pre>
<p>the node class relies on an assumption that next is nullptr or heap-allocated memory. this is an <em>invariant</em> - a statement that must be true. we can't guarantee this will hold.</p>
<p>to enforce invariant, we use encapsulation. the clients treat the objects as a black box which abstracts away the specifies of the implementation of the class.</p>
<p>we will not allow clients to access fields -&gt; only methods.</p>
<h1 id="tut-6-1023">tut 6. 10.23</h1>
<h4 id="new-in-c11">new in C++11</h4>
<ul>
<li>uniform initialization <code>int n{5};</code></li>
<li>aggregate initialization <code>Foo x = {1,2};</code></li>
</ul>
<p><strong>eg.</strong> when does UI work but <code>=()</code> doesn't?</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> n{<span class="hljs-number">3.5</span>}; <span class="hljs-comment">// does not work, no narrowing conversion</span>
</div></code></pre>
<p><strong>eg.</strong> when does <code>=()</code> work but UI doesn't?</p>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Binary</span>
{</span>
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Binary &amp;o)</span>
    </span>{
        <span class="hljs-built_in">std</span>::swap(cap, o.cap);
        <span class="hljs-built_in">std</span>::swap(sz, o.sz);
        <span class="hljs-built_in">std</span>::swap(arr, o.arr);
    }
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">int</span> sz, cap;
    <span class="hljs-keyword">bool</span> *arr;
    ~Binary() 
    {
        <span class="hljs-keyword">delete</span> [] arr;
    }
    Binary(<span class="hljs-keyword">const</span> Binary &amp;o)
    :sz{o.sz}, cap{o.cap}, arr{<span class="hljs-keyword">new</span> <span class="hljs-keyword">bool</span>[cap]}
    {
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cap; ++i)
            arr[i] = o.arr[i];
    }
    Binary &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Binary &amp;o)
    {
        Binary tmp{o};
        swap(tmp);
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};
</div></code></pre>
<h1 id="lec-13-1024">lec 13. 10.24</h1>
<h3 id="private-public"><code>private</code>, <code>public</code></h3>
<ul>
<li>private members can be accessed in methods</li>
<li>public members can be accessed anywhere</li>
</ul>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vec</span> //<span class="hljs-title">by</span> <span class="hljs-title">default</span> <span class="hljs-title">struct</span> <span class="hljs-title">is</span> <span class="hljs-title">public</span>
{</span>
<span class="hljs-keyword">private</span>: <span class="hljs-comment">// fields after this are not accessible</span>
    <span class="hljs-keyword">int</span> x, y;
<span class="hljs-keyword">public</span>:
    Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-keyword">const</span> Vec &amp;o) <span class="hljs-keyword">const</span>;
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vec2</span> // <span class="hljs-title">by</span> <span class="hljs-title">default</span> <span class="hljs-title">class</span> <span class="hljs-title">is</span> <span class="hljs-title">private</span>
{</span>
    <span class="hljs-keyword">int</span> x, y;
};
</div></code></pre>
<p><strong>eg.</strong> llist</p>
<pre><code class="language-cpp"><div><span class="hljs-comment">// list.h</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>
{</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>;</span> <span class="hljs-comment">// private nested struct</span>
    Node *theList;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addToFront</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ith</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>;
    ~List();
}
</div></code></pre>
<pre><code class="language-cpp"><div><span class="hljs-comment">// list.cc</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">List</span>:</span>:Node
{
    <span class="hljs-keyword">int</span> data;
    Node *next;
    Node(<span class="hljs-keyword">int</span> data, Node *next): data{data}, next{next} {}
    ~Node() {<span class="hljs-keyword">delete</span> next;}
};

List::~List() 
{
    <span class="hljs-keyword">delete</span> theList;
}

<span class="hljs-keyword">void</span> List::AddToFront(<span class="hljs-keyword">int</span> n)
{
    theList = <span class="hljs-keyword">new</span> Node(n, theList);
}

<span class="hljs-keyword">int</span> List::ith(<span class="hljs-keyword">int</span> i)
{
    Node *cur = theList;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; ++j, cur = cur-&gt;next);
    <span class="hljs-keyword">return</span> cur-&gt;data;
}

<span class="hljs-comment">// nodes are hidden, can't traverse to the next</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printAll</span><span class="hljs-params">(List <span class="hljs-built_in">list</span>, <span class="hljs-keyword">int</span> size)</span>
</span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i)
    {
        <span class="hljs-keyword">int</span> elem = <span class="hljs-built_in">list</span>.ith(i);
        <span class="hljs-built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
} <span class="hljs-comment">// O(n^2)</span>
</div></code></pre>
<h3 id="se-design-patterns">SE: design patterns</h3>
<p>certain scenarios occur often. we can keep track of good solutions to reuse and adapt in similar situations</p>
<h4 id="iterator-patterns">iterator patterns</h4>
<p>problem: want to visit data stored in a struct without losing encapsulation<br>
solution: create a class that manages access to nodes. iterator class acts like a pointer.
__eg. llist iterator</p>
<pre><code class="language-cpp"><div><span class="hljs-comment">// list.h</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>
{</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>;</span>
    Node *theList;
<span class="hljs-keyword">public</span>:
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Iterator</span>
    {</span>
        Node *p;
    <span class="hljs-keyword">public</span>:
        <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Iterator</span><span class="hljs-params">(Node *p)</span>: p</span>{p} 
        {}
        <span class="hljs-keyword">int</span> &amp;<span class="hljs-keyword">operator</span>*()
        {
            <span class="hljs-keyword">return</span> p-&gt;data;
        }
        Iterator &amp;<span class="hljs-keyword">operator</span>++()
        {
            p = p-&gt;next;
            <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        }
        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-keyword">const</span> Iterator &amp;o) <span class="hljs-keyword">const</span>
        {
            <span class="hljs-keyword">return</span> p == o.p;
        }
        <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-keyword">const</span> Iterator &amp;o) <span class="hljs-keyword">const</span>
        {
            <span class="hljs-keyword">return</span> !(*<span class="hljs-keyword">this</span> == o);
        }
    };
    <span class="hljs-function">Iterator <span class="hljs-title">begin</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> Iterator{theList};
    }
    <span class="hljs-function">Iterator <span class="hljs-title">end</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">return</span> Iterator{<span class="hljs-literal">nullptr</span>};
    }
    ...
}
</div></code></pre>
<pre><code class="language-cpp"><div><span class="hljs-comment">// main.cc usage</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    List <span class="hljs-built_in">list</span>;
    <span class="hljs-built_in">list</span>.addToFront(<span class="hljs-number">1</span>);
    <span class="hljs-built_in">list</span>.addToFront(<span class="hljs-number">2</span>);
    <span class="hljs-built_in">list</span>.addToFront(<span class="hljs-number">3</span>);
    <span class="hljs-keyword">for</span> (List::Iterator it = <span class="hljs-built_in">list</span>.begin(); it != <span class="hljs-built_in">list</span>.end(); ++it)
    {
        <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;
    } <span class="hljs-comment">// O(n)</span>
}
</div></code></pre>
<p>Iterator constructor has to be public</p>
<ul>
<li>needs to be accessible to List</li>
<li>it's current accessible to everyone</li>
<li>needs to be able to give access to certain class</li>
</ul>
<h4 id="auto"><code>auto</code></h4>
<ul>
<li><code>auto x = y;</code> defines x to have the same type of y.</li>
<li>don't have to write down long type name</li>
<li>don't need to know the exact type name of <code>x</code></li>
</ul>
<h4 id="range-based-for"><code>range-based for</code></h4>
<p>a class has a range-based for loop if it has</p>
<ul>
<li>methods <code>begin</code> and <code>end</code> that return the same type (iterator)</li>
<li>that iterator supports <code>operator++</code>, <code>operator*</code> and <code>operator!=</code></li>
</ul>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n: <span class="hljs-built_in">list</span>)
    <span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">endl</span>;

<span class="hljs-comment">// mutate</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> &amp;n: <span class="hljs-built_in">list</span>)
    ++n;
</div></code></pre>
<ul>
<li>the client can make iterators currently *</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-keyword">auto</span> it = List::Iterator{<span class="hljs-literal">nullptr</span>};
</div></code></pre>
<ul>
<li>the client should only use <code>begin()</code> and <code>end()</code> to make iterator</li>
<li>list must be able to access to iterator constructor
<ul>
<li>if constructor is private, list can't access it</li>
<li>if cnstructor is public, everyone accesses it</li>
</ul>
</li>
</ul>
<h4 id="friend-to-limit-who-can-access-it"><code>friend</code> to limit who can access it</h4>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Iterator</span>
    {</span>
        Node *p;
        <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Iterator</span><span class="hljs-params">(Node *p)</span></span>; <span class="hljs-comment">// is private</span>
    <span class="hljs-keyword">public</span>:
        ...
        <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>;</span> <span class="hljs-comment">// List has access to all private fields</span>
                           <span class="hljs-comment">// * is no longer possible</span>
    };
    ...
};
</div></code></pre>
<p>friends weaken encapsulation - have as less <code>friend</code> as possible.</p>
<h1 id="lec-14-1029">lec 14. 10.29</h1>
<p><strong>eg.</strong> providing private fields with access/mutator methods</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vec</span>
{</span>
    <span class="hljs-keyword">int</span> x, y;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> x; };
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-keyword">int</span> z)</span> </span>{ x = z; };
};
</div></code></pre>
<p>about operator <code>&lt;&lt;</code></p>
<ul>
<li>needs access to class internals for printing</li>
<li>no problem if getters present</li>
<li>don't want to create getter just for this reason</li>
</ul>
<p><strong>eg.</strong> make operator&lt;&lt; a friend function</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vec</span>
{</span>
    ...
    <span class="hljs-keyword">friend</span> ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;o, <span class="hljs-keyword">const</span> Vec &amp;v);
};
ostream &amp;<span class="hljs-keyword">operator</span>&lt;&lt;(ostream &amp;o, <span class="hljs-keyword">const</span> Vec &amp;v)
{
    o &lt;&lt; <span class="hljs-string">"("</span> &lt;&lt; v.x &lt;&lt; <span class="hljs-string">","</span> &lt;&lt; v.y &lt;&lt; <span class="hljs-string">")"</span>;
    <span class="hljs-keyword">return</span> o;
}
</div></code></pre>
<h3 id="system-modelling">system modelling</h3>
<p>visualize the structure of a system to aid in the design and implementation<br>
popular shortcut: uml (unified modelling language)</p>
<p><strong>eg.</strong> modelling a class</p>
<div style="background:darkgreen;width:130px;padding:5px">
<b>Name:</b><br/>
Vec<br/>
<hr style="background:black"/>
<b>Fields:</b><br/>
-x: integer<br/>
-y: integer<br/>
<hr style="background:black"/>
<b>Methods:</b><br/>
+getX(): integer<br/>
+getY(): integer
</div>
+: public, -: private, :type: type
<h4 id="relationship-composition">relationship: composition</h4>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vec</span>
{</span>
    <span class="hljs-keyword">int</span> x, y;
    Vec(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y): x{x}, y{y} {}
};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Basis</span>
{</span>
    Vec v1, v2;
    ...
};
Basis b; <span class="hljs-comment">// error: can't init v1, v2</span>
         <span class="hljs-comment">// default constructor from compiler calls the default constructor of fields - but Vec does not have a default constructor</span>
</div></code></pre>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Basis</span>
{</span>
    Vec v1, v2;
<span class="hljs-keyword">public</span>:
    Basis(): v1{{<span class="hljs-number">1</span>,<span class="hljs-number">0</span>}}, v2{{<span class="hljs-number">0</span>,<span class="hljs-number">1</span>}} {}
    <span class="hljs-comment">// must have MIL</span>
};
</div></code></pre>
<p>embedding an object insider another is called <em>composition</em>.<br>
relationshp: a Basis object owns a Vec object.<br>
if A owns B then typically:</p>
<ul>
<li>B has no identity outside A</li>
<li>if A is destroyed, so is B</li>
<li>if A is copied, so is B (deep copy)</li>
</ul>
<div>
<div style="background:darkgreen;width:130px;padding:5px;float:left">
<b>Name:</b><br/>
Vec<br/>
<hr style="background:black"/>
<b>Fields:</b><br/>
...
<hr style="background:black"/>
<b>Methods:</b><br/>
...
</div>
<div style="width:100px;padding:5px;float:left">
<br/>
◆---> (2) v1, v2
</div>
<div style="background:darkblue;width:130px;padding:5px;float:left">
<b>Name:</b><br/>
Basis<br/>
<hr style="background:white!important"/>
<b>Fields:</b><br/>
...
<hr style="background:white!important"/>
<b>Methods:</b><br/>
...
</div>
<br style="clear:both"/>
</div>
<p>◆ indicates composition (number) instance names</p>
<h4 id="relationship-aggregation">relationship: aggregation</h4>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pond</span>
{</span>
    Goose *occupied[max];
};
</div></code></pre>
<p>the items stored in a house can exist without a house existing</p>
<ul>
<li>items have an existence of their own</li>
<li>if A has B typically:
<ul>
<li>B exists apart from its association with A</li>
<li>if A is destroyed, B lives on</li>
<li>if A is copied, B is not (shallow copy)</li>
</ul>
</li>
</ul>
<div>
<div style="background:#51dbb9;color:black;width:130px;padding:5px;float:left">
<b>Name:</b><br/>
Pond<br/>
<hr style="background:black"/>
<b>Fields:</b><br/>
...
<hr style="background:black"/>
<b>Methods:</b><br/>
...
</div>
<div style="width:100px;padding:5px;float:left">
<br/>
◇---------> o..*
</div>
<div style="background:#c9c736;color:black;width:130px;padding:5px;float:left">
<b>Name:</b><br/>
Goose<br/>
<hr style="background:black"/>
<b>Fields:</b><br/>
...
<hr style="background:black"/>
<b>Methods:</b><br/>
...
</div>
<br style="clear:both"/>
</div>
<p>o..* - any number within the range can be stored <strong>eg.</strong> 1..n<br>
◇ indicates aggregation</p>
<h4 id="relationship-specialization--inheritance">relationship: specialization / inheritance</h4>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>
{</span>
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> pages;
<span class="hljs-keyword">public</span>:
    Book(<span class="hljs-built_in">string</span> title, <span class="hljs-built_in">string</span> author, <span class="hljs-keyword">int</span> pages);
};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comic</span>
{</span>
    ... samething above
};
</div></code></pre>
<p>what if i want to store these books in an array?</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">union</span> BookTypes {
    Book *b, Text *t, Comic *c
};
BookTypes shelf[<span class="hljs-number">20</span>];
<span class="hljs-comment">// or</span>
<span class="hljs-keyword">void</span> *shelf2[<span class="hljs-number">20</span>];
<span class="hljs-comment">// both ignore/subvert the typing system</span>
</div></code></pre>
<h3 id="inheritance">inheritance</h3>
<p>derived class inherit fields and methods from the base class.</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>
{</span>
    ...
};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Text</span>:</span> <span class="hljs-keyword">public</span> Book
{
    <span class="hljs-built_in">string</span> topic; <span class="hljs-comment">// do not repeat field names in subclass</span>
<span class="hljs-keyword">public</span>:
    Text(<span class="hljs-built_in">string</span> title, <span class="hljs-built_in">string</span> author, <span class="hljs-keyword">int</span> pages, <span class="hljs-built_in">string</span> topic)
    :Book{title, author, pages}
    ,topic{topic}
    {}
};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comic</span>:</span> <span class="hljs-keyword">public</span> Book
{
    <span class="hljs-built_in">string</span> hero;
<span class="hljs-keyword">public</span>:
    Comic(...);
};
</div></code></pre>
<p>subclasses cannot see private members.</p>
<p>when an object is constructed:</p>
<ul>
<li>space allocated</li>
<li>superclass part is constructed</li>
<li>fields are constructed</li>
<li>constructor body runs</li>
</ul>
<p><code>Book</code> does not have a default constructor, so it cannot be constructed without calling the constructor in subclass.</p>
<p>if the superclass has no default contructor, the constructor of subclass must use MIL.</p>
<h1 id="lec-15-1031">lec 15. 10.31</h1>
<h4 id="protected"><code>protected</code></h4>
<p>protected members can be seen by children and no one else.</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>
{</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">int</span> pages;
<span class="hljs-keyword">public</span>:
    Book(...)...
};
</div></code></pre>
<p>protected breaks encapssulation</p>
<ul>
<li>prefer provate fields still</li>
<li>use public getter/setters if they exist</li>
<li>if getters/setters are not needed outside of our subclass, use protected methods</li>
</ul>
<p><strong>eg.</strong> uml of inheritance</p>
<div>
<div style="background:darkgreen;width:130px;padding:5px;float:left">
<b>Name:</b><br/>
Book<br/>
<hr style="background:black"/>
<b>Fields:</b><br/>
#title: string<br/>
...
<hr style="background:black"/>
<b>Methods:</b><br/>
...
</div>
<br style="clear:both;"/>
<div>&nbsp;&nbsp;&nbsp;△<br/>&nbsp;&nbsp;&nbsp;&nbsp;|</div>
<div style="background:darkgreen;width:130px;padding:5px;float:left">
<b>Name:</b><br/>
Text<br/>
<hr style="background:black"/>
<b>Fields:</b><br/>
...
<hr style="background:black"/>
<b>Methods:</b><br/>
...
</div>
<br style="clear:both"/>
</div>
<p>△ indicates inheritance<br>
# protected members</p>
<p><strong>eg.</strong> slicing</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>
{</span>
<span class="hljs-keyword">public</span>:
    ...
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isHeavy</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{<span class="hljs-keyword">return</span> pages &gt; <span class="hljs-number">200</span>;}
};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comic</span>:</span> <span class="hljs-keyword">public</span> Book
{
<span class="hljs-keyword">public</span>:
    ...
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isHeavy</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{<span class="hljs-keyword">return</span> pages &gt; <span class="hljs-number">30</span>;}
};
Book b{<span class="hljs-string">"a little book"</span>, <span class="hljs-string">"author"</span>, <span class="hljs-number">50</span>};
Comic c{<span class="hljs-string">"a big comic"</span>, <span class="hljs-string">"author"</span>, <span class="hljs-number">40</span>, <span class="hljs-string">"hero"</span>};
b.isHeavy(); <span class="hljs-comment">// false</span>
c.isHeavy(); <span class="hljs-comment">// true</span>

<span class="hljs-comment">// ...</span>
Book bb = Comic{<span class="hljs-string">"a big comic"</span>, <span class="hljs-string">"author"</span>, <span class="hljs-number">40</span>, <span class="hljs-string">"hero"</span>};
<span class="hljs-comment">// Comic is sliced, hero field is stripped, becomes a Book</span>
bb.isHeavy(); <span class="hljs-comment">// calls Book::isHeavy() false</span>

<span class="hljs-comment">// store a Comic in Book pointer</span>
Comic *cp = &amp;c;
Book *bp = &amp;c;
cp-&gt;isHeavy(); <span class="hljs-comment">// true as usual</span>
bp-&gt;isHeavy(); <span class="hljs-comment">// calls Book::isHeavy() false</span>
</div></code></pre>
<p>right now a <code>Comic</code> is only treated as a <code>Comic</code> if it is being pointed to by a Comic pointer.</p>
<h3 id="virtual"><code>virtual</code></h3>
<p>declaring the method virtual tells C++ to call a method based on the type of the object being pointed, not the type of the pointer</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>
{</span>
<span class="hljs-keyword">public</span>:
    ...
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">isHeavy</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{<span class="hljs-keyword">return</span> pages &gt; <span class="hljs-number">200</span>;}
};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Text</span>:</span> <span class="hljs-keyword">public</span> Book
{
<span class="hljs-keyword">public</span>:
    ...
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isHeavy</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>{<span class="hljs-keyword">return</span> pages &gt; <span class="hljs-number">500</span>;}
};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Comic</span>:</span> <span class="hljs-keyword">public</span> Book
{
<span class="hljs-keyword">public</span>:
    ...
    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isHeavy</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> override </span>{<span class="hljs-keyword">return</span> pages &gt; <span class="hljs-number">30</span>;}
                        <span class="hljs-comment">// redundant. but if it is not an override</span>
                        <span class="hljs-comment">// (no virtual) and we use the override word</span>
                        <span class="hljs-comment">// c++ tells us</span>
};
</div></code></pre>
<p>subclass with method with same signature will have the subclass version. now <code>Book*</code> and <code>Book&amp;</code> referring to a <code>Comic</code> object call the <code>Comic::isHeavy()</code>  method.</p>
<p><strong>eg.</strong> UML for virtual</p>
<div>
<div style="background:darkgreen;width:130px;padding:5px;float:left">
<b>Name:</b><br/>
Book<br/>
<hr style="background:black"/>
<b>Fields:</b><br/>
...
<hr style="background:black"/>
<b>Methods:</b><br/>
<i>isHeavy: bool</i>
</div>
<br style="clear:both"/>
</div>
virtual: italic or cursive
<h1 id="lec-16-115">lec 16. 11.5</h1>
<p>now can have an array of books</p>
<pre><code class="language-cpp"><div>Books *shelf[<span class="hljs-number">20</span>];...
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; ++i)
    <span class="hljs-keyword">if</span> (shelf[i]) <span class="hljs-built_in">cout</span> &lt;&lt; shelf[i]-&gt;isHeavy(); <span class="hljs-comment">// calls isHeavy() based on object</span>
</div></code></pre>
<h3 id="polymorphism">polymorphism</h3>
<p>the code accommodates multiple types under one abstraction</p>
<p>                    <code>istream</code><br>
                         △<br>
                          |<br>
--------------------------------------------<br>
<code>istringstream</code>    <code>iftream</code>    <code>iostream</code></p>
<p>never use arrays of objects polymorphically, use pointers instead</p>
<pre><code class="language-cpp"><div>Text *myText[<span class="hljs-number">10</span>]; <span class="hljs-comment">// good</span>
Text myText2[<span class="hljs-number">10</span>]; <span class="hljs-comment">// bad</span>
</div></code></pre>
<pre><code class="language-cpp"><div>Book *b = <span class="hljs-keyword">new</span> Text{...};d
<span class="hljs-keyword">delete</span> b; <span class="hljs-comment">// which destructor called?</span>
          <span class="hljs-comment">// runs ~Text() then ~Book()</span>
</div></code></pre>
<p>when calling a destructor:</p>
<ol>
<li>destructor body runs</li>
<li>free each field calling their destructors (if neccessary)</li>
<li>superclass destructor runs</li>
<li>deallocates space</li>
</ol>
<p><strong>destructor of a superclass must be virtual.</strong></p>
<p><code>valgrind</code></p>
<pre><code class="language-bash"><div>&gt; g++ main.cc -g
&gt; valgrind --leak-check=full a.out
</div></code></pre>
<h3 id="abstract-class">abstract class</h3>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>
{</span>
<span class="hljs-keyword">protected</span>:
    <span class="hljs-keyword">int</span> numCourses;
<span class="hljs-keyword">public</span>: 
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fees</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// pure virtual</span>
};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Regular</span>:</span> <span class="hljs-keyword">public</span> Student
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fees</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> override</span>;
};
Student *s = <span class="hljs-keyword">new</span> Regular{...}; <span class="hljs-comment">// can have pointer</span>
</div></code></pre>
<p><code>fees()</code> is always the subclass version.</p>
<ul>
<li>a class with pure virtual functions cannot be initiated.</li>
<li>abstract class are intended to organize subclasses</li>
<li>all subclasses will itself be abstract classes unless all pure virtual methods are overrided</li>
<li>non-abstract classes are called <em>concrete classes</em></li>
</ul>
<p><strong>eg.</strong> UML for interface</p>
<div>
<div style="background:darkgreen;width:130px;padding:5px;float:left">
<b>Name:</b><br/>
<i>Student</i><br/>
<hr style="background:black"/>
<b>Fields:</b><br/>
...
<hr style="background:black"/>
<b>Methods:</b><br/>
...
</div>
<br style="clear:both"/>
<div>&nbsp;&nbsp;&nbsp;△<br/>&nbsp;&nbsp;&nbsp;&nbsp;|</div>
<div style="background:darkgreen;width:130px;padding:5px;float:left">
<b>Name:</b><br/>
Regular<br/>
<hr style="background:black"/>
<b>Fields:</b><br/>
...
<hr style="background:black"/>
<b>Methods:</b><br/>
...
</div>
<br style="clear:both"/>
</div>
<p>interface: italic or cursive</p>
<h3 id="templates">templates</h3>
<p><strong>eg.</strong> <code>Stack</code></p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span>
{</span>
    <span class="hljs-keyword">int</span> size, cap;
    T *contents;
<span class="hljs-keyword">public</span>:
    Stack();
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(T t)</span></span>;
    <span class="hljs-function">T <span class="hljs-title">top</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;
};
Stack&lt;<span class="hljs-keyword">int</span>&gt; myInts;
Stack&lt;Book*&gt; myBooks;
</div></code></pre>
<p><strong>eg.</strong> <code>LinkedList</code></p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">template</span> &lt;type T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>
{</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span>
    {</span>
        T data;
        Node *next;
    };
<span class="hljs-keyword">public</span>:
    Node *theList;
    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Iterator</span>
    {</span>
        Node *p;
        <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Iterator</span><span class="hljs-params">(Node *p)</span></span>;
    <span class="hljs-keyword">public</span>:
        T&amp; <span class="hljs-keyword">operator</span>*();
        Iterator &amp;<span class="hljs-keyword">operator</span>++();
        ...
        <span class="hljs-keyword">friend</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">List</span>&lt;T&gt;;</span>
    }
    ...
    <span class="hljs-function">T <span class="hljs-title">th</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">const</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addToFront</span><span class="hljs-params">(<span class="hljs-keyword">const</span> T&amp; t)</span></span>;
};

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(List&lt;T&gt; &amp;lst)</span>
</span>{
    <span class="hljs-keyword">for</span> (List&lt;T&gt;::Iterator it = l1.begin(); it != l1.end(); ++it)
        <span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<h1 id="tut-7-1106">tut 7. 11.06</h1>
<h3 id="class-relationships">class relationships</h3>
<ul>
<li>composition (OWNS-A) <strong>eg.</strong> car owns-an engine<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span>
{</span>
    Engine e;
}; <span class="hljs-comment">// ~Car() deletes e as well</span>
</div></code></pre>
</li>
<li>aggregation (HAS-A) <strong>eg.</strong> wall has-a poster<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wall</span>
{</span>
    Poster &amp;p;
}; <span class="hljs-comment">// ~Wall() does not delete p</span>
</div></code></pre>
</li>
<li>inheritance (IS-A)<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vec2D</span>
{</span>
    <span class="hljs-keyword">int</span> x, y;
    Vec2D(<span class="hljs-keyword">int</span> x_, <span class="hljs-keyword">int</span> y_): x{x_}, y{y_} {}
};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Vec3D</span>:</span> <span class="hljs-keyword">public</span> Vec2D
{
    <span class="hljs-keyword">int</span> z;
    Vec3(<span class="hljs-keyword">int</span> x_, <span class="hljs-keyword">int</span> y_, <span class="hljs-keyword">int</span> z_): Vec2D{x_, y_}, z{z_} {}
};
</div></code></pre>
</li>
</ul>
<p><strong>Liskov substitution principle.</strong> if A is a subclass of B then A should behave like a B in any context.</p>
<p>template is faster than polymorphism (virtuals)</p>
<h1 id="lec-17-117">lec 17. 11.7</h1>
<h2 id="stl">STL</h2>
<p>large collection of useful templates</p>
<h3 id="vector-dynamic-length-array"><code>&lt;vector&gt;</code> dynamic-length array</h3>
<p><strong>eg.</strong> basics</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span>

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec{ <span class="hljs-number">4</span>, <span class="hljs-number">5</span> }; <span class="hljs-comment">// [4, 5]</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; vec2(<span class="hljs-number">4</span>,<span class="hljs-number">5</span>)    <span class="hljs-comment">// [5, 5, 5, 5]</span>

vec.emplace_back(<span class="hljs-number">6</span>); <span class="hljs-comment">// appends ; can be faster</span>
vec.push_back(<span class="hljs-number">6</span>); <span class="hljs-comment">// appends 6</span>

<span class="hljs-comment">// iterating</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">size_t</span> i = <span class="hljs-number">0</span>; i &lt; vec.size(); ++i)
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; vec[i] &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
<span class="hljs-comment">// or</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n: vec)
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
<span class="hljs-comment">// reverse iterating</span>
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;::reverse_iterator it=vec.rbegin(); it != vec.rend(); ++it)
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;

vec.pop_back(); <span class="hljs-comment">// removes last item</span>
</div></code></pre>
<p>vectors are guaranteed to be implement as an array.<br>
use vectors instead of arrays.</p>
<p>after running a method that modifies an iterator, all iterators are invalid.<br>
<strong>eg.</strong> <code>.erase</code></p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">auto</span> it = vec.erase(vec.begin()); <span class="hljs-comment">// erases first element, returns the new iterator to the new first element</span>
     it = vec.erase(vec.begin()+<span class="hljs-number">3</span>); <span class="hljs-comment">// erases 4th element, returns the new iterator to that position</span>
     it = vec.erase(vec.end()<span class="hljs-number">-1</span>); <span class="hljs-comment">// removes the last item, returns .end()</span>

<span class="hljs-comment">// removes all 6 in vec</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = vec.begin(); it != vec.end();)
    <span class="hljs-keyword">if</span> (*it == <span class="hljs-number">6</span>)
        it = it.erase(it);
    <span class="hljs-keyword">else</span>
        ++it;
</div></code></pre>
<p><strong>eg.</strong> check index</p>
<pre><code class="language-cpp"><div>vec[<span class="hljs-number">999</span>]; <span class="hljs-comment">// out of range, undefined behavior</span>
vec.at(<span class="hljs-number">999</span>); <span class="hljs-comment">// exception out_of_range</span>
</div></code></pre>
<h3 id="set"><code>set</code></h3>
<h3 id="map"><code>map</code></h3>
<h3 id="exception">exception</h3>
<p><strong>eg.</strong> handle expection</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdexcept&gt;</span></span>

<span class="hljs-keyword">try</span>
{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; vec.at(<span class="hljs-number">999</span>);
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"......"</span>;
}
<span class="hljs-keyword">catch</span> (<span class="hljs-built_in">std</span>::out_of_range &amp;err)
{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cerr</span> &lt;&lt; <span class="hljs-string">"error: "</span> &lt;&lt; err.what() &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
}
</div></code></pre>
<p>the program resumes after the try-catch block. <code>......</code> is not run if last statement is error<br>
<code>std::exception::what</code> returns a string explaing what happens.</p>
<p>if <code>new</code> fails <code>std::bad_alloc</code> is thrown.</p>
<p>control goes through the call stack, unwinding the stack until a handler is found<br>
<strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">throw</span> out_of_range(<span class="hljs-string">"f"</span>);}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">int</span> arr[<span class="hljs-number">10</span>]; f();}
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">h</span><span class="hljs-params">()</span> </span>{g();}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-function"><span class="hljs-keyword">try</span> <span class="hljs-title">h</span><span class="hljs-params">()</span></span>;
    <span class="hljs-keyword">catch</span> (out_of_range) {...}
}

<span class="hljs-comment">/* call stack
    f:
    g: arr
    h:
    main:
*/</span>
<span class="hljs-comment">/*
    exception at f -&gt; no handler -&gt; travels to g -&gt; no handler -&gt; travels to h (arr deleted) -&gt; no handler -&gt; travels to main -&gt; exception caught
    if main has no handler, program terminates
/*
</span></div></code></pre>
<p><strong>eg.</strong> what if we need to clean the stack but cannot recover from exception</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">try</span> ...
<span class="hljs-keyword">catch</span> (some_error_type err)
{
    ...
    <span class="hljs-keyword">throw</span>; <span class="hljs-comment">// rethrows same exception, not neccessarily err; by value</span>
}
</div></code></pre>
<p>why not <code>throw err</code>?<br>
the exception caught might be a subclass of <code>err</code>, we instead want to throw the actual object being caught.</p>
<p><strong>eg.</strong> catch everything</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">try</span>
{}
<span class="hljs-keyword">catch</span> (...) <span class="hljs-comment">// literally ...; no access to object; but can be thrown</span>
{}
</div></code></pre>
<h1 id="lec-18-1112">lec 18. 11.12</h1>
<ul>
<li>you can throw anything
<ul>
<li>prefer throwing objects</li>
<li>catches only thrown objects with matching type</li>
</ul>
</li>
<li>catch by reference to avoid slicing</li>
<li>do never let a destructor throw
<ul>
<li>by default, if a destructor throws, the program terminates (calls <code>std::terminate</code>)</li>
</ul>
</li>
<li>when an exception is thrown, the stack unwinds
<ul>
<li>stack-based objects have destructors called</li>
<li>if a destructor throws, we have a second thrown exception
<ul>
<li>c++ can only handle throwing one exception at a time - program terminate</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="observer-pattern">observer pattern</h3>
<p>publish-subcribe model</p>
<ul>
<li>one class as publisher/subject - generate data</li>
<li>one or more subscriber/observer class - receive data and react</li>
</ul>
<p><strong>eg.</strong> spredsheets<br>
subject: cells, observers: cells, graphs. updating a cell affects other cells and praphs</p>
<p>there can be many types of classes, and the subject does not need to know info about them - only need to notify</p>
<p><img src="./assets/l18_1.PNG" alt="img"></p>
<p><code>Subject</code> contains code common to all subject. observer acts as an interface for all observers.<br>
sequence of methods:</p>
<ol>
<li>concrete subject has state updated</li>
<li><code>Subject::notifyObservers()</code> calls each observer's <code>notify()</code> method</li>
<li>each notified observer calls <code>ConcreteSubject::getInfo()</code> to query state and act accordingly</li>
</ol>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> ~Observer() {}
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span>
{</span>
    <span class="hljs-built_in">vector</span>&lt;Observer*&gt; observers;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Observer *ob)</span>
    </span>{
        observers.push_back(ob);
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Observer *ob)</span>
    </span>{
        <span class="hljs-comment">// remove in some way</span>
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> o: observers) o-&gt;notify();
    }
    <span class="hljs-keyword">virtual</span> ~Subject() = <span class="hljs-number">0</span>;
};


<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Celeb</span>:</span> <span class="hljs-keyword">public</span> Subject
{
    <span class="hljs-built_in">string</span> name;
    <span class="hljs-built_in">string</span> lastTweet;
    Celeb(<span class="hljs-built_in">string</span> name): name{name} {}
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">tweet</span><span class="hljs-params">(<span class="hljs-built_in">string</span> msg)</span>
    </span>{
        lastTweet = msg;
        <span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">" tweets "</span> &lt;&lt; msg &lt;&lt; <span class="hljs-built_in">endl</span>;
        notifyObservers();
    }
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Heckler</span>:</span> <span class="hljs-keyword">public</span> Observer
{
    <span class="hljs-built_in">string</span> name;
    Celeb *c;
    Heckler(<span class="hljs-built_in">string</span> name, Celeb *c): name{name}, c{c}
    {
        c-&gt;attach(<span class="hljs-keyword">this</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">" replied 'you suck!' to "</span> &lt;&lt; c-&gt;name &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Supporter</span>:</span> <span class="hljs-keyword">public</span> Observer
{
    ...
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-built_in">cout</span> &lt;&lt; name &lt;&lt; <span class="hljs-string">" retweets "</span> &lt;&lt; c-&gt;lastTweet &lt;&lt; <span class="hljs-string">" from "</span> &lt;&lt; c-&gt;name &lt;&lt; <span class="hljs-built_in">endl</span>;
    }
};

Celeb *th{<span class="hljs-string">"Tom"</span>};
Supporter a{<span class="hljs-string">"Albert"</span>, &amp;th};
Heckler b{<span class="hljs-string">"Bob"</span>, &amp;th};
</div></code></pre>
<p>(a class can be abstract by making the destructor pure virtual)</p>
<h3 id="decorator-pattern">decorator pattern</h3>
<p>we have an object that we want to add features to at run time</p>
<p><strong>eg.</strong> video game character<br>
default behavior (can jump); gains ability to break blocks; gains ability to fire balls</p>
<p><img src="./assets/l18_2.PNG" alt="img"></p>
<ul>
<li>component provides an interface: the operation the object provides</li>
<li>concrete component implements the interface for basic functionality</li>
<li>decorator: all other decorators inherit from. used by all decorators. can be written here to reduce repeating code</li>
<li>decorator is-a component and has-a component</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pizza</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-built_in">string</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> ~Pizza() {}
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CrustAndSauce</span>:</span> <span class="hljs-keyword">public</span> Pizza
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-number">5.99</span>;
    }
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
    </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-string">"Pizza"</span>;
    }
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span>:</span> <span class="hljs-keyword">public</span> Pizza
{
<span class="hljs-keyword">protected</span>:
    Pizza *comp;
<span class="hljs-keyword">public</span>:
    Decorator(Pizza *p): comp{p} {}
    <span class="hljs-keyword">virtual</span> ~Decorator()
    {
        <span class="hljs-keyword">delete</span> comp; <span class="hljs-comment">// has-a</span>
    }
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StuffedCrust</span>:</span> <span class="hljs-keyword">public</span> Decorator
{
<span class="hljs-keyword">public</span>:
    StuffedCrust(Pizza *p): Decorator{p} {}
    <span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">prize</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
    </span>{
        <span class="hljs-keyword">return</span> comp-&gt;cost() + <span class="hljs-number">99.99</span>;
    }
    <span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">desc</span><span class="hljs-params">()</span> <span class="hljs-keyword">const</span>
    </span>{
        <span class="hljs-keyword">return</span> comp-&gt;desc() + <span class="hljs-string">" with stuffed crust"</span>;
    }
};


Pizza *p = <span class="hljs-keyword">new</span> CrustAndSauce{};
p = <span class="hljs-keyword">new</span> StuffedCrust{p};
p = <span class="hljs-keyword">new</span> Topping{<span class="hljs-string">"cheese"</span>, p};
p = <span class="hljs-keyword">new</span> Topping{<span class="hljs-string">"mushroom"</span>, p};
...
</div></code></pre>
<h1 id="tut-8-1113">tut 8. 11.13</h1>
<h3 id="review-on-virtual-destructor">review on virtual destructor</h3>
<p>problem:</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span>
{</span>
    ~A() {}
};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">B</span>:</span> <span class="hljs-keyword">public</span> A
{
    ~B() {...}
};
A *a = <span class="hljs-keyword">new</span> B{};
<span class="hljs-keyword">delete</span> a; <span class="hljs-comment">// calls A::~A(), causes memory leak</span>
<span class="hljs-comment">// solution: mark A's destructor virtual</span>
</div></code></pre>
<p>virtual desturctor ==&gt; inheritance<br>
<strong>note.</strong> don't inherit from concrete class<br>
<strong>note.</strong> if need a class to be abstract, mark destructor as pure virtual. have to implement.</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span>
{</span>
    <span class="hljs-keyword">virtual</span> ~A() = <span class="hljs-number">0</span>;
};
A::~A()
{
    <span class="hljs-keyword">delete</span> ...
}
</div></code></pre>
<p><code>A::~A()</code> will be called every time a subclass is destroyed even it is virtual.</p>
<h3 id="review-on-observer-pattern">review on observer pattern`</h3>
<p><img src="./assets/t8_1.PNG" alt="img"></p>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNotify</span><span class="hljs-params">(info i)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> ~Observer() {}
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span>:</span> <span class="hljs-keyword">public</span> Observer
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onNotify</span><span class="hljs-params">(info i)</span>
    </span>{
        <span class="hljs-built_in">cout</span> &lt;&lt; i.course &lt;&lt; i.content;
    }
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lazy</span>:</span> <span class="hljs-keyword">public</span> Observer
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onNotify</span><span class="hljs-params">(info i)</span> </span>{}
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span>
{</span>
    <span class="hljs-built_in">vector</span> &lt;Observer*&gt; observers;
<span class="hljs-keyword">protected</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">(info i)</span>
    </span>{
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ob: observers) ob-&gt;onNotify(i);
    }
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer *ob)</span>
    </span>{
        observers.emplace_back(ob);
    }
    <span class="hljs-keyword">virtual</span> ~Subject() = <span class="hljs-number">0</span>; <span class="hljs-comment">// implement this directly in Subject</span>
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Piazza</span>:</span> <span class="hljs-keyword">public</span> Subject
{
    <span class="hljs-built_in">string</span> course;
<span class="hljs-keyword">public</span>:
    Piazza(<span class="hljs-built_in">string</span> course): course{course} {}
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">makePost</span><span class="hljs-params">(<span class="hljs-built_in">string</span> content)</span>
    </span>{
        notifyObservers(info{course, content});
    }
};
</div></code></pre>
<h3 id="review-on-decorator-pattern">review on decorator pattern</h3>
<p><img src="./assets/t8_2.PNG" alt="img"></p>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Audio</span>
{</span>
    <span class="hljs-keyword">virtual</span> pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; play() = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> ~Audio() {}
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span>:</span> <span class="hljs-keyword">public</span> Audio
{
<span class="hljs-keyword">protected</span>:
    Audio *a;
<span class="hljs-keyword">public</span>:
    Decorator(Audio *a)
        :a{a}
    {
    }
    <span class="hljs-keyword">virtual</span> ~Decorator() 
    {  
        <span class="hljs-keyword">delete</span> a;
    }
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span> <span class="hljs-keyword">public</span> Audio
{
<span class="hljs-keyword">public</span>:
    pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; play()
    {
        <span class="hljs-keyword">return</span> { <span class="hljs-number">440</span>, <span class="hljs-number">1000</span> };
    }
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OctaveUp</span>:</span> <span class="hljs-keyword">public</span> Decorator
{
<span class="hljs-keyword">public</span>:
    OctaveUp(Audio *a)
        :Decorator{a}
    {
    }
    pair&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; play()
    {
        <span class="hljs-keyword">auto</span> p = a-&gt;play();
        <span class="hljs-keyword">return</span> { p.first * <span class="hljs-number">2</span>, p.second };
    }
};
</div></code></pre>
<h1 id="lec-19-1114">lec 19. 11.14</h1>
<h3 id="factory-method-pattern-virtual-constructor-pattern">factory method pattern (virtual constructor pattern)</h3>
<p>decide the type of object being created at runtime</p>
<p><img src="./assets/l19_1.PNG" alt="img"></p>
<p><strong>eg.</strong> video game with two kinds of enemies: turtles and bullets. bullets are moer frequent on some later levels.</p>
<p>we don't know what enemy comes next time -&gt; it is random. -&gt; we don't know which constructor to call. additionally, we don't want to hard code the creation policies. so put a factory method in level</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Level</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> Enemy *<span class="hljs-title">createEnemy</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Field</span>:</span> <span class="hljs-keyword">public</span> Level
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">Enemy *<span class="hljs-title">createEnemy</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-comment">// create mostly turtles</span>
        <span class="hljs-keyword">int</span> n = ... <span class="hljs-comment">// random number</span>
        <span class="hljs-keyword">if</span> (n &lt; m) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Turtle{};
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Bullet{};
    }
};

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    level *l = <span class="hljs-keyword">new</span> Field{};
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)
    {
        Enemy *e = l-&gt;createEnemy();
        ...
        <span class="hljs-keyword">delete</span> e;
    }
    <span class="hljs-keyword">delete</span> l;
}
</div></code></pre>
<h3 id="template-method-pattern">template method pattern</h3>
<p>allow subclasses limited specialization.</p>
<p><strong>eg.</strong> draw turtles. some are red shells, some are green shells</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Turtle</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// Turtle::draw is a template of how to draw a turtle</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-comment">// not virtual</span>
    </span>{
        drawHead();
        drawshell();
        drawfeet();
    }
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawHead</span><span class="hljs-params">()</span> </span>{...}
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawFeet</span><span class="hljs-params">()</span> </span>{...}
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">drawShell</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedTurtle</span>:</span> <span class="hljs-keyword">public</span> Turtle
{
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawShell</span><span class="hljs-params">()</span> override </span>{...}
};


Turtle *t = <span class="hljs-keyword">new</span> RedTurtle{};
t-&gt;draw(); <span class="hljs-comment">// called superclass</span>
</div></code></pre>
<h3 id="extension-non-virtual-interface-nvi-idiom">extension non-virtual interface (NVI) idiom</h3>
<ul>
<li>a public virtual method has two rules
<ul>
<li>interface to client
<ul>
<li>ensures invariant are maintained</li>
<li>indicates provided beahavior</li>
</ul>
</li>
<li>interface to subclass
<ul>
<li>a &quot;hook&quot; to insert specialized behavior</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>contradicting ideas: if a subclass can specialize behavior, we can't enofrce them to maintain invariants.</p>
<ul>
<li>what if specialized behavior is broken into multiple methods</li>
<li>what if i want non-specialized steps in between</li>
</ul>
<p>the NVI says</p>
<ul>
<li>all public methods should be non-virtual</li>
<li>all virtual methods should be private or at least protected</li>
<li>exception: desturctor should be public and virtual</li>
</ul>
<p><strong>eg.</strong> without NVI</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DigitalMedia</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> ~DigitalMedia() {}
};
</div></code></pre>
<p><strong>eg.</strong> with NVI</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DigitalMedia</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span>
    </span>{
        doPlay();
    }
    <span class="hljs-keyword">virtual</span> ~DigitalMedia() {}
<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;
};
</div></code></pre>
<p>we have extra control over play</p>
<ul>
<li>we can later add/remove code that occurs before/after doPlay() which can't be changed eg play ads</li>
<li>add additional &quot;hook&quot; to the subclass by adding virtual methods eg <code>showCoverArt()</code></li>
<li>does not change public interface of our class</li>
</ul>
<h2 id="stl-1">STL</h2>
<h3 id="map-1"><code>&lt;map&gt;</code></h3>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;map&gt;</span></span>

<span class="hljs-built_in">std</span>::<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; m;
m[<span class="hljs-string">'a'</span>] = <span class="hljs-number">1</span>; <span class="hljs-comment">// inserts pair 'a' ↦ 1</span>
m[<span class="hljs-string">'a'</span>]; <span class="hljs-comment">// 1</span>
m.erase(<span class="hljs-string">'a'</span>); <span class="hljs-comment">// removes key 'a'</span>

<span class="hljs-comment">// do not use m[s] to check if s is in the map</span>
m[<span class="hljs-string">'g'</span>]; <span class="hljs-comment">// if key is not found, it is inserted and default constructed, initializes 0</span>
<span class="hljs-comment">// use</span>
<span class="hljs-keyword">if</span> (m.count(<span class="hljs-string">'g'</span>)); <span class="hljs-comment">// 0 if not found, 1 if found</span>


<span class="hljs-comment">// iteratring occurs in sorted key order</span>
<span class="hljs-comment">// std::pair is included in &lt;utility&gt;</span>
<span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; &amp;p: m)
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; p.first &lt;&lt; p.second;
</div></code></pre>
<h2 id="gnu-debugger">GNU debugger</h2>
<p>to use:</p>
<pre><code class="language-bash"><div>&gt; <span class="hljs-comment"># compile with -g</span>
&gt; gdb a.out

<span class="hljs-comment"># commands</span>
(gdb) r ...args <span class="hljs-comment"># run program</span>
(gdb) l <span class="hljs-comment"># displays code around error line</span>
(gdb) bt <span class="hljs-comment"># prints traceback</span>
(gdb) p var <span class="hljs-comment"># prints content of var</span>

(gdb) <span class="hljs-built_in">break</span> linenum <span class="hljs-comment"># set a breakpoint</span>
(gdb) n <span class="hljs-comment"># next breakpoint</span>
(gdb) c <span class="hljs-comment"># continue running</span>
</div></code></pre>
<h1 id="lec-20-1119">lec 20. 11.19</h1>
<p><strong>eg.</strong> what is called here:</p>
<pre><code class="language-cpp"><div>Book *b = <span class="hljs-keyword">new</span> Text{};
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Book *b)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(Text *b)</span></span>;

f(b); <span class="hljs-comment">// Book one is called // only virtual methods choose beased on type</span>
</div></code></pre>
<h3 id="visitor-pattern">visitor pattern</h3>
<p>want to select the methods called based on the type of two objects</p>
<ul>
<li>perhaps <code>void f(Book*, Student*)</code></li>
<li>cannot choose overload based on polymorphic pointers</li>
</ul>
<p><img src="./assets/l20_1.PNG" alt="img"></p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Enemy</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-title">beStruckBy</span><span class="hljs-params">(Weapon &amp;w)</span> </span>= <span class="hljs-number">0</span>;
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Turtle</span>:</span> <span class="hljs-keyword">public</span> Enemy
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-comment">// calls correct weapon type method</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">beStruckBy</span><span class="hljs-params">(Weapon &amp;w)</span> override </span>{ w.strike(*<span class="hljs-keyword">this</span>); }
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bullet</span>:</span> <span class="hljs-keyword">public</span> Enemy
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">beStruckBy</span><span class="hljs-params">(Weapon &amp;w)</span> override </span>{ w.strike(*<span class="hljs-keyword">this</span>); }
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Weapon</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strike</span><span class="hljs-params">(Turtle &amp;e)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">strike</span><span class="hljs-params">(Bullet &amp;e)</span> </span>= <span class="hljs-number">0</span>;
};


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stick</span>:</span> <span class="hljs-keyword">public</span> Weapon
{
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">strike</span><span class="hljs-params">(Turtle &amp;e)</span> override </span>{...}
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">strike</span><span class="hljs-params">(Bullet &amp;e)</span> override </span>{...}
};


Enemy *e = <span class="hljs-keyword">new</span> Bullet{};
Weapon *w = <span class="hljs-keyword">new</span> Stick{};
e-&gt;beStruckBy(*w); <span class="hljs-comment">// calls Bullet::beStruckBy() calls Stick::strike(Bullet&amp;)</span>
</div></code></pre>
<ul>
<li>to add new weapon - write <code>strike</code> methods only</li>
<li>to add new enemy - write <code>beStruckBy</code> for enemy, and write <code>strike</code> for each weapon</li>
</ul>
<p><strong>eg.</strong> adding a visitor to the Book hierachy</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>
{</span>
<span class="hljs-keyword">public</span>:
    ...
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(BookVisitor &amp;v)</span> </span>{ v.visit(*<span class="hljs-keyword">this</span>); }
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Text</span>:</span> <span class="hljs-keyword">public</span> Book
{
    ...
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(BookVisitor &amp;v)</span> override </span>{ v.visit(*<span class="hljs-keyword">this</span>); };
};

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookVisitor</span>
{</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Book &amp;b)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Text &amp;b)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Comic &amp;b)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">virtual</span> ~BookVisitor() = <span class="hljs-keyword">default</span>; <span class="hljs-comment">// uses compiler-generated default</span>
    <span class="hljs-comment">// superclass shall always have a virtual destructor</span>
};

<span class="hljs-comment">// keeps track of books we have in our library based on info specific</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Catalogue</span>:</span> <span class="hljs-keyword">public</span> BookVisitor
{
    <span class="hljs-built_in">map</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-keyword">int</span>&gt; theCatalogue; <span class="hljs-comment">// keeps track of number of visits</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Book &amp;b)</span> override </span>{ ++theCatalogue[b.getAuthor()]; }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Text &amp;b)</span> override </span>{ ++theCatalogue[b.getTopic()]; }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">visit</span><span class="hljs-params">(Comic &amp;b)</span> override </span>{ ++theCatalogue[b.getHero()]; }
};
</div></code></pre>
<p><code>Book</code> needs <code>BookVisitor</code> in its details while <code>BookVisitor</code> needs <code>Book</code>  -&gt; circular dependency.</p>
<h3 id="compilation-dependencies">compilation dependencies</h3>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> {</span>};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>:</span> <span class="hljs-keyword">public</span> A {};           <span class="hljs-comment">// include in header</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span> {</span> A myA; };             <span class="hljs-comment">// include in header</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span> {</span> A *myA; };            <span class="hljs-comment">// declare in header</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span> {</span> <span class="hljs-function">A <span class="hljs-title">foo</span><span class="hljs-params">(A myA)</span></span>; };      <span class="hljs-comment">// declare in header</span>
</div></code></pre>
<p>when do we need to <code>#include</code>?</p>
<ul>
<li>when we need to know the size oo info about its attributes</li>
<li>class B needs to know how big it is -&gt; need to know the size of parents
<ul>
<li>need to know info, need to <code>#include</code></li>
</ul>
</li>
<li>class C needs to know ihe size of A to know the size of C
<ul>
<li>need to <code>#include</code></li>
</ul>
</li>
<li>class D only needs the size of pointer (8)
<ul>
<li>don't include, use forward declaration <code>class A;</code></li>
</ul>
</li>
<li>class E only needs to know class A exists for type checking
<ul>
<li>don't include, use forward declaration <code>class A;</code></li>
</ul>
</li>
</ul>
<h1 id="lut-9-1120">lut 9. 11.20</h1>
<h1 id="lec-21-1121">lec 21. 11.21</h1>
<h3 id="pimpl-idom-pointer-to-implementation">pImpl idom (pointer to implementation)</h3>
<p>if we want to add/remove a private member, all files that include the header file have to be recompiled. we shall hide these details</p>
<pre><code class="language-cpp"><div><span class="hljs-comment">// window.h</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XWindowImpl</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XWindow</span>
{</span>
    XWindowImpl *impl;
<span class="hljs-keyword">public</span>:
    ...
};


<span class="hljs-comment">// windowimpl.h</span>

<span class="hljs-comment">/**@interface*/</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XWindowImpl</span>
{</span>
    ... 
};
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">XWindowImplLinux</span>
{</span>
    Display *d;
    Window *w;
    <span class="hljs-keyword">int</span> s;
    GC gc;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> colours[<span class="hljs-number">10</span>];
};
</div></code></pre>
<h3 id="measures-of-design-quality">measures of design quality</h3>
<p>coupling and cohesion</p>
<p>coupling: how much distinct program modules depend on each other</p>
<ol>
<li>(lowest) modules communicate via function calls and simple params</li>
<li>modules pass struct/arrays back and forth</li>
<li>module affect each other's control flow</li>
<li>modules share global data</li>
<li>(highest) modules have access to each others' implementation (friends)</li>
</ol>
<p>high coupling:</p>
<ol>
<li>changes in one module require greater changes in another</li>
<li>harder to reuse module</li>
</ol>
<p>cohesion: how related components of a program are</p>
<ol>
<li>(lowest) arbitrary grouping of unrelated elements (<code>&lt;utility&gt;</code>)</li>
<li>elements share a common theme, but are otherwise unrelated (<code>&lt;algorithm&gt;</code>)</li>
<li>elements manipulate state over the lifetime of an object <code>(fopen)</code></li>
<li>elements pass data to each other</li>
<li>(highest) elements cooperate to perform one task</li>
</ol>
<p>low cohesion:</p>
<ol>
<li>poorly organized code</li>
<li>hard to maintain/understand</li>
</ol>
<p>Goal: low coupling, high cohension</p>
<h3 id="decoupling">decoupling</h3>
<p>the majority of classes should not print things.</p>
<h3 id="single-responsibility-principle">single responsibility principle</h3>
<p>a class should only have one reason to change.</p>
<ul>
<li>class should have only one goal</li>
<li>methods should try to accomplish one goal</li>
</ul>
<p>Q: should main do all the interactions and method calls? no, main's responsibility is to manage the argv and start the program.</p>
<h3 id="model-view-controller">model-view controller</h3>
<p>seperate program into three views:</p>
<ul>
<li>maintain data for the program (model)
<ul>
<li>can have multiple views</li>
<li>doesn't know details about views</li>
<li>classic observer pattern (Subject[Model] - Observer[View])</li>
</ul>
</li>
<li>presentation of data (view)</li>
<li>manipulate data (controller)
<ul>
<li>communicate with user for input
<ul>
<li>could be part of view (buttons)</li>
</ul>
</li>
<li>encapsulate turn-taking/game rules
<ul>
<li>share with model. constrol modifies input to be useful for model</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="exception-safety">exception safety</h3>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{
    myClass mc;
    myClass *p = <span class="hljs-keyword">new</span> MyClass;
    g();
    <span class="hljs-keyword">delete</span> p;
}
<span class="hljs-comment">// if g() throws, g is not deleted during stack unwinding</span>
</div></code></pre>
<p><strong>eg.</strong> to be exception safe</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{
    myClass mc;
    myClass *p = <span class="hljs-keyword">new</span> MyClass;
    <span class="hljs-keyword">try</span>
    {
        g();
    }
    <span class="hljs-keyword">catch</span>(...)
    {
        <span class="hljs-keyword">delete</span> p;
        <span class="hljs-keyword">throw</span>;
    }
    <span class="hljs-keyword">delete</span> p;
}
</div></code></pre>
<h3 id="resource-acquisition-is-initialization-idom-raii">resource acquisition is initialization idom (RAII)</h3>
<p>all resources should be allocated in a stack-allocated object where destructor will release</p>
<p>destructor deletes unique pointer stored</p>
<pre><code class="language-cpp"><div><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;memory&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
</span>{
    myClass mc;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unique_ptr</span>&lt;MyClass&gt; p = <span class="hljs-built_in">std</span>::make_unique&lt;MyClass&gt;(...args);
    <span class="hljs-comment">// also can use std::unique_ptr&lt;MyClass&gt; = {new MyClass{...}};</span>
    g();
    <span class="hljs-comment">// auto q = p; // fails (copy constructor made uncallable)</span>
}
</div></code></pre>
<h1 id="lec-22-1126">lec 22. 11.26</h1>
<p><strong>eg.</strong> sample implementation</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">unique_ptr</span>
{</span>
    T *ptr;

<span class="hljs-keyword">public</span>:

    <span class="hljs-built_in">unique_ptr</span>(T *p): ptr{p} {}

    ~<span class="hljs-built_in">unique_ptr</span>() {<span class="hljs-keyword">delete</span> ptr;}

    <span class="hljs-built_in">unique_ptr</span>(<span class="hljs-keyword">const</span> <span class="hljs-built_in">unique_ptr</span>&lt;T&gt;&amp;) = <span class="hljs-keyword">delete</span>;

    <span class="hljs-built_in">unique_ptr</span>&lt;T&gt; &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> <span class="hljs-built_in">unique_ptr</span>&lt;T&gt;&amp;) = <span class="hljs-keyword">delete</span>;

    <span class="hljs-built_in">unique_ptr</span>(<span class="hljs-built_in">unique_ptr</span>&lt;T&gt; &amp;&amp;o) {o.ptr = <span class="hljs-literal">nullptr</span>;};

    <span class="hljs-built_in">unique_ptr</span>&lt;T&gt; &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">unique_ptr</span>&lt;T&gt; &amp;&amp;o)
    {
        <span class="hljs-built_in">std</span>::swap(ptr, o.ptr);
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }

    T &amp;<span class="hljs-keyword">operator</span>*() {<span class="hljs-keyword">return</span> *ptr};

    <span class="hljs-function">T *<span class="hljs-title">get</span><span class="hljs-params">()</span> </span>{<span class="hljs-keyword">return</span> ptr;}

};
</div></code></pre>
<p>what if we want multiple pointers to the same object?</p>
<ul>
<li>who will own the resource, who deletes resource</li>
<li>the owner should have a unique_ptr</li>
<li>other pointers to the resource should be raw pointers initialized with get</li>
</ul>
<p>if the resource should be shared, ie should not be owned by a specific object, but should be deleted if all references go out of scope, use shared_ptr</p>
<pre><code class="language-cpp"><div>{
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;MyClass&gt; p = <span class="hljs-built_in">std</span>::make_shared&lt;MyClass&gt;(...args);
    <span class="hljs-keyword">if</span> (...)
    {
        <span class="hljs-keyword">auto</span> q = p;
    } <span class="hljs-comment">// q goes out of scope, data not deleted</span>
} <span class="hljs-comment">// p goes out of scope, data deleted</span>
</div></code></pre>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Data</span>
{</span>
    <span class="hljs-keyword">int</span> data;
    <span class="hljs-built_in">shared_ptr</span>&lt;Node&gt; next;
    <span class="hljs-built_in">shared_ptr</span>&lt;Node&gt; prev;
};

<span class="hljs-built_in">shared_ptr</span>&lt;Node&gt; n = {<span class="hljs-number">2</span>,<span class="hljs-literal">nullptr</span>,<span class="hljs-literal">nullptr</span>};
<span class="hljs-built_in">shared_ptr</span>&lt;Node&gt; m = {<span class="hljs-number">4</span>,n, <span class="hljs-literal">nullptr</span>};
n-&gt;prev = m;
<span class="hljs-comment">// if n goes out of scope</span>
</div></code></pre>
<h3 id="">...</h3>
<p>there are three levels of exception safety for a function <code>f</code></p>
<ol>
<li>basic guarantee: if <code>f</code> throws an exception, the state of the program is valid -&gt; no mem leaked ad all invariants hold</li>
<li>strong guarantee: if <code>f</code> throws (or propagates an exception), it acts like <code>f</code> is never called</li>
<li>no throw guarantee: an exception is never thrown and <code>f</code> accomplishes task</li>
</ol>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> {</span>...};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> {</span>...};
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>
{</span>
    A a;
    B b;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
    </span>{
        a.g(); <span class="hljs-comment">// strong</span>
        b.h(); <span class="hljs-comment">// strong</span>
    }
};
</div></code></pre>
<p>is <code>C</code> exception safe?<br>
<code>a.g</code> if it throws, state not changed. if it doesn't throw, state could change<br>
<code>b.h</code> if it throws, state was changed by <code>a.g()</code><br>
so <code>C:f</code> has the basic guarantee (at best)</p>
<p><strong>eg.</strong> better one</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>
{</span>
    A a;
    B b;
<span class="hljs-keyword">public</span>:
    A tempa = a;
    B tempb = b;
    tempa.g();
    tempb.h();
    a = tempa;
    b = tempb;
}
</div></code></pre>
<p>assign pointers does not throw
<strong>eg.</strong> or</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CImpl</span>
{</span>
    A a;
    B b;
}
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>
{</span>
    <span class="hljs-built_in">unique_ptr</span>&lt;Impl&gt; impl;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">()</span>
    </span>{
        <span class="hljs-keyword">auto</span> temp = make_unique&lt;CImpl&gt;(*Impl); <span class="hljs-comment">// invokes Impl copy constructor</span>
        temp-&gt;a.g();
        temp-&gt;b.h();
        <span class="hljs-built_in">std</span>::swap(impl, temp);
    }
}
</div></code></pre>
<h1 id="tut-10-1127">tut 10. 11.27</h1>
<h4 id="review-on-visitor-pattern">review on visitor pattern</h4>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">TreeNode</span>
{</span>
    C data;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(TreeVistor&lt;C&gt; &amp;v)</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">UnaryTreeNode</span>:</span> <span class="hljs-keyword">public</span> TreeNode&lt;C&gt;
{
    UnaryTreeNode&lt;C&gt; *child;
    <span class="hljs-function">T <span class="hljs-title">accept</span><span class="hljs-params">(TreeVistor&lt;C&gt; &amp;v)</span> </span>{<span class="hljs-keyword">return</span> v.visit(*<span class="hljs-keyword">this</span>);}
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BinaryTreeNode</span>&lt;C&gt;:</span> <span class="hljs-keyword">public</span> TreeNode&lt;C&gt; {...};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">TreeVisitor</span>
{</span>
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">visit</span><span class="hljs-params">(UnaryTreeNode&lt;C&gt; &amp;t)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">int</span> <span class="hljs-title">visit</span><span class="hljs-params">(BinaryTreeNode&lt;C&gt; &amp;t)</span> </span>= <span class="hljs-number">0</span>;
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">TreeLengthCounter</span>&lt;C&gt;:</span> <span class="hljs-keyword">public</span> TreeVisitor&lt;C&gt;
{
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">visit</span><span class="hljs-params">(UnaryTreeNode&lt;C&gt; &amp;t)</span> </span>{...}
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">visit</span><span class="hljs-params">(BinaryTreeNode&lt;C&gt; &amp;t)</span> </span>{...}
};

<span class="hljs-keyword">template</span>&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>&gt;
<span class="hljs-title">struct</span> <span class="hljs-title">TreePrinter</span>&lt;C&gt;:</span> <span class="hljs-keyword">public</span> TreeVisitor&lt;C&gt; {...};

<span class="hljs-keyword">auto</span> t = UnaryTree&lt;<span class="hljs-keyword">int</span>&gt;{};
<span class="hljs-keyword">auto</span> tv = TreeLengthCounter&lt;<span class="hljs-keyword">int</span>&gt;{};
t.accept(tv);
</div></code></pre>
<h1 id="lec-23-1128">lec 23. 11.28</h1>
<h3 id="inheritance-and-copymove">inheritance and copy/move</h3>
<p><strong>eg.</strong> a copy constructor and =</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span>
{</span>
    ...<span class="hljs-comment">// define copy/move constructor and assignment operators</span>
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Text</span>:</span> <span class="hljs-keyword">public</span> Book
{
    <span class="hljs-built_in">string</span> topic;
    <span class="hljs-comment">// no move/copy</span>
};

Text t = {<span class="hljs-string">"Algorithm"</span>, <span class="hljs-string">"CLRS"</span>, <span class="hljs-number">500</span>, <span class="hljs-string">"CS"</span>};
Text t2 = t; <span class="hljs-comment">// this uses compiler default copy constructor</span>
             <span class="hljs-comment">// calls super copy constructor, then copies fields</span>
</div></code></pre>
<p>to implement:</p>
<pre><code class="language-cpp"><div>Text::Text(<span class="hljs-keyword">const</span> Text &amp;o)
    :Book{o}
    ,topic{topic}
{}

Text &amp;Text::<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Text &amp;o)
{
    Book::<span class="hljs-keyword">operator</span>=(o);
    topic = o.topic;
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</div></code></pre>
<p><strong>eg.</strong> about move constructor and =</p>
<pre><code class="language-cpp"><div>Text::Text(Text &amp;&amp;o)
    :Book{<span class="hljs-built_in">std</span>::move(o)} <span class="hljs-comment">// if just pass o, o points to rvalue, but itself is lvalue</span>
                        <span class="hljs-comment">// that will cause copy constructor to run</span>
    ,topic{<span class="hljs-built_in">std</span>::move(topic)}
{}

Text &amp;<span class="hljs-keyword">operator</span>=(Text &amp;&amp;o)
{
    Book::<span class="hljs-keyword">operator</span>=(<span class="hljs-built_in">std</span>::move(o));
    topic = <span class="hljs-built_in">std</span>::move(o);
    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
}
</div></code></pre>
<p><strong>eg.</strong> consider</p>
<pre><code class="language-cpp"><div>Text t1{...}, t2{...};
Book *bp1 = &amp;t1, *bp2 = &amp;t2;
*bp1 = *bp2; <span class="hljs-comment">// book's copy constructor called here -&gt; partial assignment, wrong</span>
</div></code></pre>
<p>solution 1: make them virtual</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span>
{</span>
    <span class="hljs-keyword">virtual</span> Book &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Book&amp;);
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Text</span>:</span> <span class="hljs-keyword">public</span> Book
{                  <span class="hljs-comment">// param same type</span>
    Text &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Book&amp;) override;
};

Text t{...};
Book b{...};
Book *bp = &amp;t;
*bp = b; <span class="hljs-comment">// assigning Text from Book -&gt; bad</span>
Comic c{...};
t = c    <span class="hljs-comment">// assigning Text from Comic -&gt; bad</span>
<span class="hljs-comment">// results in mixed assignment</span>
</div></code></pre>
<p>recommendation: all superclasses should be abstract</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Book</span>
{</span>
    <span class="hljs-built_in">string</span> title, author;
    <span class="hljs-keyword">unsigned</span> pages;
<span class="hljs-keyword">protected</span>:
    _Book &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> _Book&amp;); <span class="hljs-comment">// not callable to clients</span>
<span class="hljs-keyword">public</span>:
    _Book(<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>, <span class="hljs-keyword">unsigned</span>);
    <span class="hljs-keyword">virtual</span> ~_Book() = <span class="hljs-number">0</span>;
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Book</span>:</span> <span class="hljs-keyword">public</span> _Book
{
    Book(<span class="hljs-built_in">string</span> t, <span class="hljs-built_in">string</span> a, <span class="hljs-keyword">unsigned</span> p)
        :_Book{t, a, p}
    {}
    Book &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> Book &amp;o)
    {
        _Book::<span class="hljs-keyword">operator</span>=(o);
        <span class="hljs-comment">// if extra fields, copy</span>
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Text</span>:</span> <span class="hljs-keyword">public</span> _Book {...};

Text t{...}, t2{...};
Book b{...};
Text *tp = &amp;t;
*tp = t2; <span class="hljs-comment">// ok</span>
_Book *ab = &amp;t;
*ab = b; <span class="hljs-comment">// error, cannot access protected operator= =&gt; prevents mixed and partial assignment</span>
</div></code></pre>
<h3 id="c-style-casting">C++ style casting</h3>
<h4 id="staticcast"><code>static_cast</code></h4>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">double</span>)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span>;
<span class="hljs-keyword">double</span> d = <span class="hljs-number">5.0</span>;
f(<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(d)); <span class="hljs-comment">// runs second version</span>
</div></code></pre>
<p><strong>eg.</strong> superclass to subclass pointer</p>
<pre><code class="language-cpp"><div>_Book *b = <span class="hljs-keyword">new</span> Text{...};
Text *t = <span class="hljs-keyword">static_cast</span>&lt;Text*&gt;(b);
<span class="hljs-comment">// we promise the compiler that the pointer is the type we say it is</span>
<span class="hljs-comment">// or undefined behavior</span>
</div></code></pre>
<h4 id="dynamiccast"><code>dynamic_cast</code></h4>
<p>basically a static cast with type checking<br>
we do not know what is stored in the pointer, but if it is the type we want, we will use it</p>
<pre><code class="language-cpp"><div>_Book *b = ...;
<span class="hljs-keyword">static_cast</span>&lt;Text*&gt;(b)-&gt;getTopic(); <span class="hljs-comment">// only safe when b points to a Text</span>
Text *t = <span class="hljs-keyword">dynamic_cast</span>&lt;Text*&gt;(b); <span class="hljs-comment">// if b contains a Text*, that pointer is returned</span>
                                  <span class="hljs-comment">// if that fails, nullptr is returned</span>
</div></code></pre>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-built_in">string</span> <span class="hljs-title">getTopic</span><span class="hljs-params">(_Book *bpr)</span>
</span>{
    Text *t = <span class="hljs-keyword">dynamic_cast</span>&lt;Text*&gt;(b);
    <span class="hljs-keyword">if</span> (t) <span class="hljs-keyword">return</span> t-&gt;getTopic();
    <span class="hljs-keyword">throw</span> runtime_error{<span class="hljs-string">"not a text!"</span>};
}
</div></code></pre>
<p><strong>eg.</strong> can write a better polymrphic assignment operator<br>
make <code>_Book::operator=(const _Book&amp;)</code> virtual</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Book</span>
{</span>
    ...
    <span class="hljs-keyword">virtual</span> _Book &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> _Book&amp;);
};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Text</span>:</span> <span class="hljs-keyword">public</span> _Book
{
    ...
    Text &amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-keyword">const</span> _Book &amp;o) override
    {
        <span class="hljs-keyword">const</span> Text &amp;other = <span class="hljs-keyword">dynamic_cast</span>&lt;Text&amp;&gt;(o);
        <span class="hljs-comment">// if fails, std::bad_cast is thrown</span>
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;other) <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
        _Book::<span class="hljs-keyword">operator</span>=(other);
        topic = other.topic;
        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;
    }
};

Text *t = <span class="hljs-keyword">new</span> Text{...};
_Book *ab = ...;
<span class="hljs-keyword">try</span>
{
    *t = *ab;
}
<span class="hljs-keyword">catch</span> (<span class="hljs-keyword">const</span> <span class="hljs-built_in">std</span>::bad_cast &amp;err)
{
    <span class="hljs-comment">// recover</span>
}
</div></code></pre>
<h1 id="lec-24-123">lec 24. 12.3</h1>
<h4 id="constcast"><code>const_cast</code></h4>
<p>converts between const and non-const -&gt; cast away constness</p>
<pre><code class="language-cpp"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">g</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *p)</span></span>;
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> *p)</span>
</span>{
    g(p); <span class="hljs-comment">// compiler error</span>
    <span class="hljs-comment">// if we know g does not change p, we can do</span>
    g(<span class="hljs-keyword">const_cast</span>&lt;<span class="hljs-keyword">int</span>*&gt;(p));
}
</div></code></pre>
<h4 id="reinterpretcast"><code>reinterpret_cast</code></h4>
<p>cast a type into any other type</p>
<ul>
<li>dangerous</li>
<li>compiler dependent</li>
</ul>
<pre><code class="language-cpp"><div>Student s;
Turtle *t = <span class="hljs-keyword">reinterpret_cast</span>&lt;Turtle*&gt;(&amp;s);
</div></code></pre>
<p><strong>eg.</strong> 2d rray</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">int</span> (*a)[<span class="hljs-number">10</span>] = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">int</span>(*)[<span class="hljs-number">10</span>]&gt; (<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span> [<span class="hljs-number">10</span>*<span class="hljs-number">15</span>]);
<span class="hljs-comment">// access like a[i][j]...</span>
<span class="hljs-keyword">delete</span> [] <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">int</span>*&gt;(a);
</div></code></pre>
<h4 id="about-smart-pointers">about smart pointers</h4>
<pre><code class="language-cpp"><div><span class="hljs-comment">// casting smart pointers</span>
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Student&gt; foo;
<span class="hljs-built_in">std</span>::<span class="hljs-built_in">shared_ptr</span>&lt;Turtle&gt; fee;
foo = <span class="hljs-built_in">std</span>::make_shared&lt;Student&gt;();
fee = <span class="hljs-built_in">std</span>::dynamic_pointer_cast&lt;Turtle&gt;(foo);

<span class="hljs-comment">// std::const_pointer_cast</span>
<span class="hljs-comment">// std::static_pointer_cast</span>
</div></code></pre>
<h2 id="vtable">vtable</h2>

    </body>
    </html>