<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>Foundations of Sequential Programs</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
</style>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
<link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
<style>
    body {
        padding: 0 1px;
    }
    @media only screen and (max-width:800px){
        html {
            padding: 0 16px;
        }
        body {
            margin: 0;
        }
        code {
            font-size: .9rem;
        }
    }
</style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
        
    </head>
    <body class="vscode-light">
        <p>page: <a href="https://www.student.cs.uwaterloo.ca/~cs241/">https://www.student.cs.uwaterloo.ca/~cs241/</a></p>
<p>Instructor: Nomair Naeem, Gregor Richards</p>
<ul>
<li><a href="#week-1-may-11">Week 1. May 11</a></li>
<li><a href="#week-2-may-18">Week 2. May 18</a></li>
<li><a href="#week-3-may-25">Week 3. May 25</a></li>
<li><a href="#week-4-june-1">Week 4. June 1</a></li>
<li><a href="#week-5-june-8">Week 5. June 8</a></li>
<li><a href="#week-6-june-15">Week 6. June 15</a></li>
<li><a href="#week-7-june-23">Week 7. June 23</a></li>
<li><a href="#week-8-june-29">Week 8. June 29</a></li>
<li><a href="#week-9-july-6">Week 9. July 6</a></li>
<li><a href="#week-10-july-13">Week 10. July 13</a></li>
<li><a href="#week-11-july-21">Week 11. July 21</a></li>
<li><a href="#week-12-july-27">Week 12. July 27</a></li>
<li><a href="#week-13-august-3">Week 13. August 3</a></li>
</ul>
<h1 id="week-1-may-11">Week 1. May 11</h1>
<p><strong>defn.</strong> a <em>bit</em> is a binary digit that is 0 or 1.</p>
<p><strong>defn.</strong> a <em>nibble</em> is 4 bits.</p>
<p><strong>defn.</strong> a <em>byte</em> is 8 bits.</p>
<p><strong>defn.</strong> a <em>word</em> is a machine-specific grouping of bytes, it is 4 bytes on 32-bit architectures, 8 bytes on 64-bit architectures.</p>
<p><strong>defn.</strong> the <em>Most Signiﬁcant Bit (MSB)</em> is the left-most bit (highest value/sign bit)</p>
<p><strong>defn.</strong> the <em>Least Signiﬁcant Bit (LSB)</em> is the right-most bit (lowest value)</p>
<h2 id="unsigned-integers">unsigned integers</h2>
<p><strong>eg.</strong> convert from decimal to binary</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0101010</mn><msub><mn>1</mn><mn>2</mn></msub><mo>=</mo><msup><mn>2</mn><mn>6</mn></msup><mo>+</mo><msup><mn>2</mn><mn>4</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><msup><mn>2</mn><mn>0</mn></msup><mo>=</mo><mn>64</mn><mo>+</mo><mn>16</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>1</mn><mo>=</mo><mn>8</mn><msub><mn>5</mn><mn>10</mn></msub></mrow><annotation encoding="application/x-tex">01010101_{2}=2^{6}+2^{4}+2^{2}+2^{0}=64+16+4+1=85_{10}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord">1</span><span class="mord">0</span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mord">6</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79444em;vertical-align:-0.15em;"></span><span class="mord">8</span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p><strong>eg.</strong> convert from binary to decimal<br>
method1: break number to factors that are power of 2, eg 38 = 32 + 4 + 2 =&gt; 2^5 + 2^2 + 2^1 =&gt; 100110</p>
<p>method2: constantly divide number by 2, write all remainders in reverse:</p>
<table>
<thead>
<tr>
<th style="text-align:center">number</th>
<th style="text-align:center">q</th>
<th style="text-align:center">r</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">38</td>
<td style="text-align:center">19</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">19</td>
<td style="text-align:center">9</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<p>after every division, the least significant digit is yielded as remainder</p>
<p>result: 100110</p>
<h2 id="signed-integers">signed integers</h2>
<h3 id="sign-magnitude">sign-magnitude</h3>
<p>use the first bit as sign bit, 0 for positive, 1 for negative.</p>
<ul>
<li>two representations for 0 (00000000 and 10000000), which is awkward</li>
<li>tricky arithmetic</li>
</ul>
<h3 id="twos-complement-8-bit-length">two's complement (8-bit length)</h3>
<ul>
<li>to negate value: flip all bits and add 1, or locate the rightmost 1 bit and flip all bits before it:<br>
<strong>eg.</strong> <code>110110 10  --&gt;  001001 10</code></li>
</ul>
<p><strong>eg.</strong> convert from -38 to two's complement</p>
<pre><code><code><div>-38
--&gt; 38         take abs
--&gt; 00100110   to binary
--&gt; 11011001   flip
--&gt; 11011010   add 1
</div></code></code></pre>
<p>converting 38 to two's complement is the same as unsigned</p>
<p><strong>eg.</strong> convert 0b11011010 to decimal<br>
method1:</p>
<pre><code><code><div>11011010
--&gt; 00100101  flip bits
--&gt; 00100110  add 1
--&gt; 38
--&gt; -38       negative
</div></code></code></pre>
<p>method2: treat it as unsigned and convert to decimal, then subtract 2^8 from it</p>
<pre><code><code><div>11011010
--&gt; 218     to decimal
--&gt; 218-256 since 1st bit is 1, it is negative
--&gt; -38
</div></code></code></pre>
<p><strong>eg.</strong> arithmetic
addition works naturally</p>
<pre><code><code><div>  .... .
  0000 0100 (+4)
+ 1111 1101 (-3)
= 0000 0001 (+1)
</div></code></code></pre>
<pre><code><code><div>  .... .
  1111 1100 (-4)
+ 1111 1101 (-3)
= 1111 1101 (-7)
</div></code></code></pre>
<p>overﬂow occurs when add two numbers of the same sign but get a different sign</p>
<pre><code><code><div>  .... ...
  0111 1111 (+127, CHAR_MAX)
+ 0000 0001 (+1)
= 1000 0000 (-128, CHAR_MIN)  # overflow
</div></code></code></pre>
<p>overflow is not possible if two operands have different signs.</p>
<h2 id="hexadecimal-notation">hexadecimal notation</h2>
<p><strong>defn.</strong> the base-16 representation system is called the <em>hexadecimal system</em>. it consists of the numbers from 0 to 9 and the letters A, B, C, D, E and F (which convert to the numbers from 10 to 15 in decimal notation).</p>
<p><strong>eg.</strong> convert 3914 to hex</p>
<table>
<thead>
<tr>
<th style="text-align:center">number</th>
<th style="text-align:center">q</th>
<th style="text-align:center">r</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">3914</td>
<td style="text-align:center">244</td>
<td style="text-align:center">10</td>
</tr>
<tr>
<td style="text-align:center">244</td>
<td style="text-align:center">15</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">0</td>
<td style="text-align:center">15</td>
</tr>
</tbody>
</table>
<p>write in reverse: 15 4 10 -&gt; result: 0xF4A</p>
<p><strong>eg.</strong> convert 0xF4A to binary
each digit in hex represent a nibble in binary:</p>
<pre><code><code><div>0xF4A
--&gt; 15 4 10
--&gt; 1110 0100 1010
</div></code></code></pre>
<h2 id="ascii-representation">ASCII representation</h2>
<p>...</p>
<h2 id="bitwise-operation">bitwise operation</h2>
<p><strong>eg.</strong></p>
<pre><code><code><div>AND:
  0001 0010 0011 0100 0101 0110 0111 1000
&amp; 1000 0111 0110 0101 0100 0011 0010 0001
= 0000 0010 0010 0100 0100 0010 0010 0000

OR:
  0001 0010 0011 0100 0101 0110 0111 1000
| 1000 0111 0110 0101 0100 0011 0010 0001
= 1001 0111 0111 0101 0101 0111 0111 1001

SHL (x &lt;&lt; n == x * pow(2,n)):
  0001 0010 0011 0100 0101 0110 0111 1000 &lt;&lt; 16
= 0101 0110 0111 1000 0000 0000 0000 0000

SHR (arithmetic):
  0001 0010 0011 0100 0101 0110 0111 1000 &gt;&gt; 16
= 0000 0000 0000 0000 0001 0010 0011 0100
  1101 0010 0011 0100 0101 0110 0111 1000 &gt;&gt; 16
= 1111 1111 1111 1111 1101 0010 0011 0100
</div></code></code></pre>
<h2 id="32-bit-mips">32-bit MIPS</h2>
<pre><code><code><div>+---------------------CPU----------------------+  +----------------+
|------+    +--------+   +-------------------+ |  |      RAM       |
|| hi  |    |general |   |                   | |  |                |
|------+    |purpose |   |                   | |  +-0x00           |
|| lo  |    |register|   |                   | |  +-0x01           |
+------+    +-$0     |   |     ALU           | |  +-0x02           |
|           +-$1     |   |                   | |  |...             |
+------+    |...     |   |                   | |  |                |
|| MAR |    |        |   |                   | |  |                |
|------+    |        |   +-------------------+ |  |                |
|| MDR |    |        |                         |  |                |
+------+    |        |                         |  |                |
|           |        |   +-------------------+ |  |                |
+------+    |        |   |                   | |  |                |
|| PC  |    |        |   |  Control unit     | |  |                |
|------+    |...     |   |                   | |  |                |
|| IR  |    +-$31    |   |                   | |  |                |
|------+    |--------+   +-------------------+ |  |                |
+----------------------------------------------+  +----------------+
</div></code></code></pre>
<ul>
<li>each memory slot is 8 bits. 4 slots make up 1 word</li>
<li>PC stores the address of the next instruction</li>
</ul>
<h3 id="machine-language">machine language</h3>
<p>fetch-execute cycle:</p>
<pre><code><code><div>while true:
    IR = MEM[PC]    # reads the machine instruction that starts at
                    # memory address PC (program counter) and retrieves
                    # it into the IR (instruction register)
    PC += 4
    decode and execute instruction in IR
end
</div></code></code></pre>
<p>there are 32 registers $0, ..., $31. $0 will always hold the value zero, $29 will be used as a frame pointer, $30 as the stack pointer and $31 will store the return address</p>
<h3 id="add-instruction">add instruction</h3>
<p>syntax:</p>
<pre><code><code><div>  assembly                     machine
add $d, $s, $t:   000000 sssss ttttt ddddd 00000 100000
</div></code></code></pre>
<p>performs $d = $s + $t</p>
<p>need 5 bits to represent a register value since there are 32 general purpose registers numbered 0 to 31</p>
<p><strong>eg.</strong> adds values in $5 and $7 and store result in $3</p>
<pre><code><code><div>add $3, $5, $7    000000 00101 00111 00011 00000 100000
                           5     7     3
                         sssss ttttt ddddd

it is 0000 0000 1010 0111 0001 1000 0010 0000, ie 0x00A71820
</div></code></code></pre>
<h3 id="sub-instruction"><code>sub</code> instruction</h3>
<p>syntax:</p>
<pre><code><code><div>sub $d, $s, $t:   00000 sssss ttttt ddddd 00000 100010
</div></code></code></pre>
<p>the values are interpreted as signed integers, to negate a value in <code>$1</code>, do <code>sub $1, $0, $1</code></p>
<h3 id="jr-instruction"><code>jr</code> instruction</h3>
<p>syntax</p>
<pre><code><code><div>jr $s: 000000 sssss 00000 00000 00000 001000
</div></code></code></pre>
<p><code>$s</code> is interpreted as address. this jumps to the instruction at address stored in register <code>$s</code>.</p>
<p>MIPS programs must have an explicit jump to the return address:</p>
<pre><code><code><div>// $31 stores the return address
jr $31:   0000 0011 1110 0000 0000 0000 0000 1000, ie 0x03e00008
</div></code></code></pre>
<h3 id="lis-instruction"><code>lis</code> instruction</h3>
<p>syntax:</p>
<pre><code><code><div>lis $d: 000000 00000 00000 ddddd 00000 010100
</div></code></code></pre>
<p>treats the next instruction (appeared in memory) as data (an immediate), and place its value into <code>$d</code>, then skip to the next next instruction by incrementing PC by 4. (the fetch-exec cycle already increments PC by 4 once)</p>
<p>it does: first $d = MEM[PC] then: PC += 4</p>
<h3 id="word-directive"><code>.word</code> directive</h3>
<p>syntax:</p>
<pre><code><code><div>.word i: iiii iiii iiii iiii iiii iiii iiii iiii
</div></code></code></pre>
<p>put literally the data i into the current address</p>
<p><strong>eg.</strong> program that adds integers 11 and 13 and stores result in $3</p>
<pre><code class="language-asm"><code><div>mem addr  shorthand       hex
0x00      lis $8          0x00004014
0x04      .word 11        0x0000000B
0x08      lis $9          0x00004814
0x0c      .word 13        0x0000000D
0x10      add $3,$8,$9    0x01091820
0x14      jr $31          0x03E00008
</div></code></code></pre>
<h1 id="week-2-may-18">Week 2. May 18</h1>
<p><strong>defn.</strong> <em>assembly language</em> is a textual representation of a machine language</p>
<p><code>lo</code> and <code>hi</code> are not general purpose registers</p>
<h2 id="mult-mulu-div-divu">mult, mulu, div, divu</h2>
<h3 id="mult-s-t"><code>mult $s, $t</code></h3>
<ul>
<li><code>000000 sssss ttttt 00000 00000 011000</code></li>
<li>multiplies values in $s and $t. destination is not specified</li>
<li>result is stored in <code>hi</code> (for most significant word) and <code>lo</code> (for least significant word)</li>
<li>assumes numbers are signed two's complement</li>
<li>for CS241 it is safe to assume result is 32-bit and fits in <code>lo</code></li>
</ul>
<h3 id="multu-s-t"><code>multu $s, $t</code></h3>
<ul>
<li><code>000000 sssss ttttt 00000 00000 011001</code></li>
<li>assumes numbers are unsigned</li>
</ul>
<h3 id="div-s-t"><code>div $s, $t</code></h3>
<ul>
<li><code>000000 sssss ttttt 00000 00000 011010</code></li>
<li>performs signed division and put quotient $s/$t in <code>lo</code> and remainder $s%$t in <code>hi</code></li>
<li>sign of remainder = sign of the divisor in $s</li>
</ul>
<h3 id="divu-s-t"><code>divu $s, $t</code></h3>
<ul>
<li><code>000000 sssss ttttt 00000 00000 011011</code></li>
<li>unsigned version</li>
</ul>
<h2 id="move-from-hi-and-lo">move from hi and lo</h2>
<h3 id="mfhi-d"><code>mfhi $d</code></h3>
<ul>
<li><code>000000 00000 00000 ddddd 00000 010000</code></li>
<li>move from register <code>hi</code> to register <code>$d</code></li>
</ul>
<h3 id="mflo-d"><code>mflo $d</code></h3>
<ul>
<li><code>000000 00000 00000 ddddd 00000 010010</code></li>
<li>move from register <code>lo</code> to register <code>$d</code></li>
</ul>
<h2 id="branch">branch</h2>
<h3 id="beq-s-t-i"><code>beq $s, $t, i</code></h3>
<ul>
<li><code> 000100 sssss ttttt iiii iiii iiii iiii</code></li>
<li>compares values in $s and $t. if equal, then skip instructions, else continue to next</li>
<li>if $i positive, then pc += i*4, skip i instructions</li>
<li>if $i negative, then pc -= (|i|-1)*4, go up |i|-1 instruction</li>
</ul>
<h3 id="bne-s-t-i"><code>bne $s, $t, i</code></h3>
<ul>
<li><code> 000101 sssss ttttt iiii iiii iiii iiii</code></li>
<li>if not equal, skip instructions</li>
</ul>
<p><strong>eg.</strong></p>
<pre><code class="language-asm"><code><div>xxxx
yyyy
beq $0, $0, -2  // will jump to yyyy
beq $0, $0, 1   // will jump to tttt
zzzz
tttt
</div></code></code></pre>
<p><strong>eg.</strong> update $2 to 3 if the signed number in $1 is odd, and to 11 otherwise</p>
<pre><code class="language-asm"><code><div>lis $8
.word 2        // store comparer
lis $9
.word 3        // value if $1 odd
lis $2
.word 11       // value if $1 even
div $1, $8     // $1 / 2
mfhi $3        // extract remainder
beq $3, $0, 1  // remainder is 0, then $2 is already 11, skip 1 line
add $2, $9, $0 // else $2 &lt;- $9
jr $31
</div></code></code></pre>
<h2 id="set-less-than">set less than</h2>
<h3 id="slt-d-s-t"><code>slt $d, $s, $t</code></h3>
<ul>
<li><code> 000000 sssss ttttt ddddd 00000 101010</code></li>
<li>if $s &lt; $t, then $d is set to 1, otherwise $d is 0</li>
</ul>
<h3 id="sltu-d-s-t"><code>sltu $d, $s, $t</code></h3>
<ul>
<li><code> 000000 sssss ttttt ddddd 00000 101011</code></li>
<li>unsigned version</li>
</ul>
<p><strong>eg.</strong> determine the abs value of signed integer in $1 and store at $1</p>
<pre><code class="language-asm"><code><div>slt $1, $0, $2
beq $2, $0, 1   // if not less than 0, return
sub $1, $0, $1  // if less than 0, negate
jr $31
</div></code></code></pre>
<p><strong>eg.</strong> determines the minimum of signed integers in $1, $2, places it in $3</p>
<pre><code class="language-asm"><code><div>slt $4, $1, $2   0x0022202A
beq $0, $4, 2    0x10040002
add $3, $1, $0   0x00201820 // if less than
jr $31           0x03E00008
add $3, $2, $0   0x00401820 // if not less than
jr $31           0x03E00008
</div></code></code></pre>
<p><strong>eg.</strong> compute 13+12+...+1, store result at $3</p>
<pre><code class="language-asm"><code><div>lis $2
.word 13           // i = 13
lis $1
.word -1           // $1 = -1
add $3, $0, $0     // sum = 0

add $3, $3, $2     // sum += 2  // this line
add $2, $2, $1     // i -= 1
bne $2, $0, -3     // i != 0 &amp;&amp; goto ^^

jr $31
</div></code></code></pre>
<h2 id="labels">labels</h2>
<p>when the assembler encounters the deﬁnition of a label it associates the name of the label with the address of the instruction at that point. When the assembler encounters a label being used, the assembler computes the number of instructions to skip.</p>
<p><strong>eg.</strong> compute 20+18+16+...+2 and store result at $3</p>
<pre><code class="language-asm"><code><div>0x00  lis $2
0x04  .word 20
0x08  lis $1
0x0c  .word 2
0x10  add $3, $0, $0
      loop:              // defined, addr is 0x14
0x14  add $3, $3, $2
0x18  sub $2, $2, $1
0x1c  bne $2, $0, loop  // used, computed addr is (0x14 - 0x20)/4 = -3
                        // (note PC is already at next)
0x20  jr $31
</div></code></code></pre>
<h2 id="storeload-word">store/load word</h2>
<h3 id="sw-t-is"><code>sw $t, i($s)</code></h3>
<ul>
<li><code> 101011 sssss ttttt iiii iiii iiii iiii</code></li>
<li>takes 32-bit value currently in $t and stores it at MEM[$s+i]</li>
<li>i is 16-bit two's complement immediate</li>
<li>value in $s is treated as a 32-bit address</li>
<li>MEM[$s+i] stores the most significant byte and MEM[$s+i+3] for least significant byte</li>
</ul>
<h3 id="lw-t-is"><code>lw $t, i($s)</code></h3>
<ul>
<li><code> 100011 sssss ttttt iiii iiii iiii iiii</code></li>
<li>loads a word starting at MEM[$s+i] to $t</li>
<li>mips can only perform operations on register data</li>
</ul>
<p><strong>eg.</strong> $1 contains the address of an array and $2 contains # of elements in this array. place 7 in the last spot of the array</p>
<pre><code><code><div>lis $4
.word $4          // word with
mult $2, $4
mflo $3           // $3 = len * 4
add $3, $3, $1    // addr just past end of array
lis $8
.word 7
sw $8, -4($3)     // len*4-4 is addr of last elem
jr $31
</div></code></code></pre>
<h3 id="io">IO</h3>
<ul>
<li>loading from <code>0xFFFF0004</code> reads <em>one</em> character from stdin and store it as the lease significant byte within the register</li>
<li>storing to <code>0xFFFF000C</code> writes the least significant byte to stdout</li>
</ul>
<p><strong>eg.</strong></p>
<pre><code class="language-asm"><code><div>read:
    lis $1
    .word 0xffff0004
    lw $2, 0($1)      // load one char from stdin into $2
write:
    lis $1
    .word 0xffff000c
    lis $2
    .word 67
    sw $2, 0($1)      // outputs 'C' to stdout
</div></code></code></pre>
<h2 id="procedures">procedures</h2>
<ul>
<li>$30 stores the stack pointer</li>
</ul>
<p>when we call <code>bar</code></p>
<ul>
<li>assume <code>bar</code> uses $5 and $6, it will store the original values of $5 and $6 and update $30 to ensure it reflects the boundary between used and unused memory</li>
<li><code>bar</code> changes $5 and $6 and calls <code>baz</code>. <code>baz</code> uses $6 and $9, so it will store the original values of them and update $30</li>
<li>when <code>baz</code> is done, before returning, it restore the values it overwrote in $6 and $9 and restores $30. when control is back to <code>bar</code>, the register values are the same</li>
<li>when <code>baz</code> is done, it will restore $5 and $6 and update $30</li>
</ul>
<pre><code><code><div>+-----------+0x00               +------------+              +----free----+   curr
|           |                   |            |              +-------------&lt;--+$30
|           |                   |            |              | initial val|
|           |  ^                |    free    |              |  of $9     |
|           |  |                |            |              +------------+
|           |  |                |            |              | initial val|
|           |  |                |            |   curr       |  of $6     |
|           |  |free            +-------------&lt;--+$30       +-------------&lt;--+$30 by bar
|           |  |memory          | initial val|              | initial val|
|           |  |                |  of $6     |              |  of $6     |
|           |  |                +------------+              +------------+
|           |  |                | initial val|              | initial val|
|           |  v                |  of $5     |  initial     |  of $5     |  initial
+-----------+&lt;-++$30            +------------+&lt;--+$30       +------------+&lt;--+$30
   INITIAL                         IN BAR                      IN BAZ
</div></code></code></pre>
<p>stack memory grows from bottom to top</p>
<p>pushing a register value on memory stack</p>
<pre><code><code><div>sw $1, -4($30)     // store value of $1
lis $4
.word 4
sub $30, $30, $4   // update stack pointer
</div></code></code></pre>
<p>popping a value from memory stack into a register</p>
<pre><code><code><div>lis $4
.word 4
add $30, $30, $4   // update stack pointer
lw $1, -4($30)     // load into $1
</div></code></code></pre>
<h3 id="jalr-s"><code>jalr $s</code></h3>
<ul>
<li>jump and link register</li>
<li><code> 000000 sssss 00000 00000 00000 001001</code></li>
<li>stores the current value of PC to $31, then set PC to $s</li>
</ul>
<p><strong>eg.</strong> calling a procedure</p>
<pre><code class="language-sh"><div><span class="hljs-comment"># a procedure</span>
foo:
    ...
    jr <span class="hljs-variable">$31</span>            <span class="hljs-comment"># jump to caller</span>

<span class="hljs-comment"># start of my caller</span>
sw <span class="hljs-variable">$31</span> -4(<span class="hljs-variable">$30</span>)        <span class="hljs-comment"># push $31 to stack</span>
lis <span class="hljs-variable">$31</span>               <span class="hljs-comment"># use $31</span>
.word 4
sub <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$31</span>

lis <span class="hljs-variable">$21</span>
.word foo
jalr <span class="hljs-variable">$21</span>              <span class="hljs-comment"># jump to foo, at this time $31 is next</span>
...                   <span class="hljs-comment"># foo returns to here</span>

lis <span class="hljs-variable">$31</span>               <span class="hljs-comment"># $31 is changed, set it back to 4</span>
.word 4
add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$31</span>
lw <span class="hljs-variable">$31</span>, -4(<span class="hljs-variable">$30</span>)       <span class="hljs-comment"># pop $31</span>

jr <span class="hljs-variable">$31</span>                <span class="hljs-comment"># return to loader</span>
</div></code></pre>
<p><strong>eg.</strong> a procedure computing 13+12+...+1</p>
<pre><code class="language-sh"><div><span class="hljs-comment"># Sum1ToN adds all numbers 1 to N</span>
<span class="hljs-comment"># registers:</span>
<span class="hljs-comment">#   $1 scratch (original value preserved)</span>
<span class="hljs-comment">#   $2 input N (original value preserved)</span>
<span class="hljs-comment">#   $3 output  (overwrites)</span>
Sum1ToN:
    sw <span class="hljs-variable">$1</span>, -4(<span class="hljs-variable">$30</span>)         <span class="hljs-comment"># preserve $1</span>
    sw <span class="hljs-variable">$2</span>, -8(<span class="hljs-variable">$30</span>)         <span class="hljs-comment"># preserve $2</span>
    lis <span class="hljs-variable">$1</span>
    .word 8
    sub <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$1</span>       <span class="hljs-comment"># update stack ptr</span>

    add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$0</span>, <span class="hljs-variable">$0</span>         <span class="hljs-comment"># res = 0</span>
    lis <span class="hljs-variable">$1</span>
    .word -1

    loop:
        add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$3</span>, <span class="hljs-variable">$2</span>     <span class="hljs-comment"># res += curr</span>
        add <span class="hljs-variable">$2</span>, <span class="hljs-variable">$2</span>, <span class="hljs-variable">$1</span>     <span class="hljs-comment"># counter--</span>
        bne <span class="hljs-variable">$2</span>, <span class="hljs-variable">$0</span>, loop

    lis <span class="hljs-variable">$1</span>
    .word 8
    add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$1</span>       <span class="hljs-comment"># update stack ptr</span>
    lw <span class="hljs-variable">$1</span>, -4(<span class="hljs-variable">$30</span>)         <span class="hljs-comment"># restore $1</span>
    lw <span class="hljs-variable">$2</span>, -8(<span class="hljs-variable">$30</span>)         <span class="hljs-comment"># restore $2</span>
    jr <span class="hljs-variable">$31</span>
</div></code></pre>
<p><strong>eg.</strong> get the sum of digits of a positive integer in $1 and store result in $3</p>
<pre><code class="language-sh"><div><span class="hljs-comment"># $1: input N (preserved)</span>
<span class="hljs-comment"># $3: output (overwrites)</span>
<span class="hljs-comment"># variables:</span>
<span class="hljs-comment"># $1: remaining number, $4 temp, $10 holds 10</span>
SumDigits:
    sw <span class="hljs-variable">$1</span>, -4(<span class="hljs-variable">$30</span>)
    sw <span class="hljs-variable">$4</span>, -8(<span class="hljs-variable">$30</span>)
    sw <span class="hljs-variable">$10</span>, -12(<span class="hljs-variable">$30</span>)
    lis <span class="hljs-variable">$4</span>
    .word 12
    sub <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>

    lis <span class="hljs-variable">$10</span>
    .word 10
    add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$0</span>, <span class="hljs-variable">$0</span>       <span class="hljs-comment"># res</span>
    loop:
        div <span class="hljs-variable">$1</span>, <span class="hljs-variable">$10</span>
        mfhi <span class="hljs-variable">$4</span>          <span class="hljs-comment"># remainder</span>
        add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$3</span>, <span class="hljs-variable">$4</span>
        mflo <span class="hljs-variable">$1</span>          <span class="hljs-comment"># quotient</span>
        bne <span class="hljs-variable">$1</span>, <span class="hljs-variable">$0</span>, loop <span class="hljs-comment"># if not 0 divide again</span>

    lis <span class="hljs-variable">$4</span>
    .word 12
    add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>
    lw <span class="hljs-variable">$1</span>, -4(<span class="hljs-variable">$30</span>)
    lw <span class="hljs-variable">$4</span>, -8(<span class="hljs-variable">$30</span>)
    lw <span class="hljs-variable">$10</span>, -12(<span class="hljs-variable">$30</span>)
    jr <span class="hljs-variable">$31</span>
</div></code></pre>
<p><strong>eg.</strong> get the sum of digits in $1 and $2 and store result in $3</p>
<pre><code class="language-sh"><div>SumDigits2:
    <span class="hljs-comment"># we call other procedures, so need to store $31</span>
    sw <span class="hljs-variable">$31</span>, -4(<span class="hljs-variable">$30</span>)
    sw <span class="hljs-variable">$1</span>, -8(<span class="hljs-variable">$30</span>)
    sw <span class="hljs-variable">$2</span>, -12(<span class="hljs-variable">$30</span>)
    sw <span class="hljs-variable">$4</span>, -16(<span class="hljs-variable">$30</span>)
    lis <span class="hljs-variable">$31</span>
    .word 16
    sub <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$31</span>

    lis <span class="hljs-variable">$3</span>                  <span class="hljs-comment"># $1 has first number</span>
    .word SumDigits
    jalr <span class="hljs-variable">$3</span>

    add <span class="hljs-variable">$4</span>, <span class="hljs-variable">$3</span>, <span class="hljs-variable">$0</span>          <span class="hljs-comment"># result in $3, copy it to $4</span>

    add <span class="hljs-variable">$1</span>, <span class="hljs-variable">$2</span>, <span class="hljs-variable">$0</span>          <span class="hljs-comment"># copy number in $2 to $1</span>
    lis <span class="hljs-variable">$3</span>
    .word SumDigits
    jalr <span class="hljs-variable">$3</span>

    add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$4</span>, <span class="hljs-variable">$3</span>          <span class="hljs-comment"># result</span>

    lis <span class="hljs-variable">$31</span>
    .word 16
    add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$31</span>
    lw <span class="hljs-variable">$31</span>, -4(<span class="hljs-variable">$30</span>)
    sw <span class="hljs-variable">$1</span>, -8(<span class="hljs-variable">$30</span>)
    sw <span class="hljs-variable">$2</span>, -12(<span class="hljs-variable">$30</span>)
    sw <span class="hljs-variable">$4</span>, -16(<span class="hljs-variable">$30</span>)
    jr <span class="hljs-variable">$31</span>
</div></code></pre>
<h1 id="week-3-may-25">Week 3. May 25</h1>
<h2 id="mips-assembler">mips assembler</h2>
<pre><code><code><div>            +--------------------------------------------------------------------------------+
            |   +----------------------------------------------+                             |
            |   | +----------+ +-----------+   +-----------+   |     +------------------+    |
            |   | | scanning | |  parsing  |   | sematics  |   |     |                  |    |
mips +--------&gt; | |         +----&gt;        +----&gt; analysis  +-----------&gt;  synthesis     | +-----------&gt; mips machine
assembly    |   | +----------+ +-----------+   +-----------+   |     |                  |    |          language
language    |   |                   analysis                   |     +------------------+    |
            |   +----------------------------------------------+                             |
            |                               mips assembler                                   |
            +--------------------------------------------------------------------------------+

</div></code></code></pre>
<h3 id="analysis">analysis</h3>
<ul>
<li>scan strings into <em>tokens</em></li>
<li>parse the tokens to determine the structure of the program and check syntax</li>
<li>semantics analysis checks uniqueness of labels, validness of variables, etc</li>
</ul>
<h3 id="synthesis">synthesis</h3>
<ul>
<li>once the input program is known to be correct assembly program, the synthesis stage generates the output (machine instructions)</li>
</ul>
<h4 id="process-labels">process labels</h4>
<ul>
<li>pass 1: scan, parse and generate symbol table and detect duplicate symbols</li>
<li>pass 2: semantic analysis and synthesis</li>
</ul>
<pre><code class="language-sh"><div>0x00  main: lis <span class="hljs-variable">$2</span>
0x04        .word beyond         <span class="hljs-comment"># symbol table</span>
0x08        lis <span class="hljs-variable">$1</span>               <span class="hljs-comment"># main   |  0x00</span>
0x0c        .word 2              <span class="hljs-comment"># top    |  0x14</span>
            <span class="hljs-comment"># comment            # begin  |  0x14</span>
0x10        add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$0</span>, <span class="hljs-variable">$0</span>       <span class="hljs-comment"># beyond |  0x24</span>
      top:  begin:
0x14        add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$3</span>, <span class="hljs-variable">$2</span>
0x18        sub <span class="hljs-variable">$2</span>, <span class="hljs-variable">$2</span>, <span class="hljs-variable">$1</span>
0x1c        bne <span class="hljs-variable">$2</span>, <span class="hljs-variable">$0</span>, top    <span class="hljs-comment"># computed: (defn-PC)/4=(0x14-0x20)/4=-3</span>
0x20        jr <span class="hljs-variable">$31</span>
      beyond:
0x24
</div></code></pre>
<h4 id="encode-instruction">encode instruction</h4>
<p><strong>eg.</strong> encode <code>add $3, $2, $4</code></p>
<ul>
<li>this format requires three reg values and a function code</li>
<li>general <code>(s &lt;&lt; 21) | (t &lt;&lt; 16) | (d &lt;&lt; 11) | func</code></li>
</ul>
<pre><code><code><div>add $d, $s, $t:   000000 sssss ttttt ddddd 00000 100000
machine code:
    6bits opcode  5bits $s  5bits $t  5bits $d  5bits pad  6bits func
       000000      00010     00100     00011      00000      100000
                     2         4         3                     32
</div></code></code></pre>
<p>register indices are all positive, we have</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">uint32_t</span> instr = (<span class="hljs-number">0</span> &lt;&lt; <span class="hljs-number">26</span>) | (<span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">21</span>) | (<span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">16</span>) | (<span class="hljs-number">3</span> &lt;&lt; <span class="hljs-number">11</span>) | <span class="hljs-number">32</span>; <span class="hljs-comment">// or +</span>
</div></code></pre>
<p><strong>eg.</strong> encode <code>beq $1, $2, -3</code></p>
<ul>
<li>this format requires two reg values, and one immediate value. the immediate value is interpreted as signed two's complement</li>
<li>general <code>(op &lt;&lt; 26) | (s &lt;&lt; 21) | (t &lt;&lt; 16) | (i &amp; 0xffff)</code></li>
</ul>
<pre><code><code><div>beq $s, $t, i: 000100 sssss ttttt iiiiiiiiiiiiiiii
machine code:
    6bits opcode  5bits $s  5bits $t  16bits offset
       000100      00001     00010    1111111111111101
         8           1         2           -3
</div></code></code></pre>
<p>note -3 is negative and has to be 16bits, we have to trim the extra leftmost 16bits because it is passed as a 32bit int</p>
<pre><code class="language-cpp"><div><span class="hljs-comment">//   1111111111111111 1111111111111101</span>
<span class="hljs-comment">// &amp; 0000000000000000 1111111111111111</span>
<span class="hljs-comment">// = 0000000000000000 1111111111111101</span>
<span class="hljs-keyword">uint32_t</span> instr = (<span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">26</span>) | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">21</span>) | (<span class="hljs-number">2</span> &lt;&lt; <span class="hljs-number">16</span>) | (<span class="hljs-number">-3</span> &amp; <span class="hljs-number">0xffff</span>);

<span class="hljs-comment">// we can write the bytes out (from left to right)</span>
<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> c;
<span class="hljs-built_in">cout</span> &lt;&lt; (c = instr &gt;&gt; <span class="hljs-number">24</span>);
<span class="hljs-built_in">cout</span> &lt;&lt; (c = instr &gt;&gt; <span class="hljs-number">16</span>);
<span class="hljs-built_in">cout</span> &lt;&lt; (c = instr &gt;&gt; <span class="hljs-number">8</span>);
<span class="hljs-built_in">cout</span> &lt;&lt; (c = instr);
</div></code></pre>
<h1 id="week-4-june-1">Week 4. June 1</h1>
<h2 id="formal-languages">formal languages</h2>
<p><strong>defn.</strong> an <em>alphabet</em> is a non-empty finite set of symbols often denoted by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>.</p>
<p><strong>defn.</strong> a <em>word</em> (<em>string</em>) is a finite sequence of symbols chosen from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>. the set of all words over an alphabet <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> is denoted by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\Sigma^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li>the length of a word <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>w</mi><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|w|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord">∣</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span> is the empty word with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>ϵ</mi><mi mathvariant="normal">∣</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">|\epsilon|=0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord mathdefault">ϵ</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mtext> </mtext><mi mathvariant="normal">∀</mi><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\epsilon\in\Sigma^*\,\forall\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">ϵ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord">Σ</span></span></span></span></li>
<li>we assume <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> will never contain <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span></li>
</ul>
<p><strong>defn.</strong> a <em>language</em> is a set of strings.</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mi mathvariant="normal">∅</mi><mtext> or </mtext><mo stretchy="false">{</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L=\varnothing \text{ or } \{\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord amsrm">∅</span><span class="mord text"><span class="mord"> or </span></span><span class="mopen">{</span><span class="mclose">}</span></span></span></span> is the empty language</li>
</ul>
<p><strong>eg.</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><msup><mi>b</mi><mi>n</mi></msup><mi>a</mi><mo>:</mo><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L=\{ab^na:n\in\mathbb{N}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mclose">}</span></span></span></span> is the set of strings over the alphabet <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Sigma=\{a,b\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">}</span></span></span></span> consisting of words like aa, aba, abba, ...</p>
<h3 id="recognition">recognition</h3>
<p><strong>defn.</strong> a recognition algorithm is a decision algorithm that takes the specification of a language and an input word and answers whether the words satisfies the specification</p>
<ul>
<li>from easy to hard</li>
<li>finite</li>
<li>regular</li>
<li>context-free</li>
<li>context-sensitive</li>
<li>recursive/decidable</li>
<li>impossible/undecidable</li>
</ul>
<h2 id="finite-languages">finite languages</h2>
<p><strong>eg.</strong> have language L={ bne, beq, mult, multu }. determine whether word is in L. each character is scanned exactly once without storing previous seen one.</p>
<p><img src="assets/w4_1.PNG" alt="img"></p>
<ul>
<li>transition states based on the character. if there is no transition to next input character, reject the word. if input is exhausted, accept the word.</li>
</ul>
<h2 id="regular-languages">regular languages</h2>
<p><strong>defn.</strong> a language over an alphabet <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> is regular if</p>
<ol>
<li>it is the empty language <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mclose">}</span></span></span></span>, or the language consisting of the empty word, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>ϵ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{\epsilon\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">ϵ</span><span class="mclose">}</span></span></span></span></li>
<li>it is a language of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{a\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mclose">}</span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">a\in\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span></li>
<li>it is a language built using union, concatenation, or Kleene star of two regular languages</li>
</ol>
<p>let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo separator="true">,</mo><msub><mi>L</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>L</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">L,L_1,L_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">L</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> be regular languages, then the following are regular:</p>
<ul>
<li><strong>union</strong>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub><mo>∪</mo><msub><mi>L</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mo>:</mo><mi>x</mi><mo>∈</mo><msub><mi>L</mi><mn>1</mn></msub><mtext> or </mtext><mi>x</mi><mo>∈</mo><msub><mi>L</mi><mn>2</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L_1\cup L_2=\{x:x\in L_1 \text{ or }x\in L_2\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord text"><span class="mord"> or </span></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>
<ul>
<li><strong>eg.</strong> { up, down } ⋃ { hill, load } = { up, down, hill, load }</li>
</ul>
</li>
<li><strong>concatenation</strong>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>L</mi><mn>1</mn></msub><msub><mi>L</mi><mn>2</mn></msub><mo>=</mo><mo stretchy="false">{</mo><mi>x</mi><mi>y</mi><mo>:</mo><mi>x</mi><mo>∈</mo><msub><mi>L</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><msub><mi>L</mi><mn>2</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L_1L_2=\{xy:x\in L_1,y\in L_2\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>
<ul>
<li><strong>eg.</strong> { up, down }{ hill, load } = { uphill, upload, downhill, download }</li>
</ul>
</li>
<li><strong>Kleene star</strong>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mo>∗</mo></msup><mo>=</mo><mo stretchy="false">{</mo><mi>ϵ</mi><mo stretchy="false">}</mo><mo>∪</mo><mo stretchy="false">{</mo><mi>x</mi><mi>y</mi><mo>:</mo><mi>x</mi><mo>∈</mo><msup><mi>L</mi><mo>∗</mo></msup><mo separator="true">,</mo><mi>y</mi><mo>∈</mo><mi>L</mi><mo stretchy="false">}</mo><mo>=</mo><msubsup><mo>⋃</mo><mrow><mi>n</mi><mo>=</mo><mn>0</mn></mrow><mi mathvariant="normal">∞</mi></msubsup><msup><mi>L</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">L^*=\{\epsilon\}\cup\{xy:x\in L^*,y\in L\}=\bigcup_{n=0}^\infty L^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">ϵ</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">x</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8831359999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋃</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">∞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mn>0</mn></msup><mo>=</mo><mo stretchy="false">{</mo><mi>ϵ</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L^0=\{\epsilon\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">ϵ</span><span class="mclose">}</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>L</mi><mi>n</mi></msup><mo>=</mo><mi>L</mi><msup><mi>L</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">L^n=LL^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>
<ul>
<li><strong>eg.</strong> { a, b }* = { ε,a,b,aa,ab,ba,aaa,bb,aba,... }</li>
</ul>
</li>
</ul>
<h3 id="regular-expressions">regular expressions</h3>
<p><strong>eg.</strong> regular expression for language over <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{a,b\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">}</span></span></span></span> where words in the language have an odd number of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>'s is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mo>∗</mo></msup><mi>a</mi><msup><mi>b</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>a</mi><msup><mi>b</mi><mo>∗</mo></msup><mi>a</mi><msup><mi>b</mi><mo>∗</mo></msup><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">b^*ab^*(ab^*ab^*)^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><strong>eg.</strong> for even number of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>'s: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>b</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>a</mi><msup><mi>b</mi><mo>∗</mo></msup><mi>a</mi><msup><mi>b</mi><mo>∗</mo></msup><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">b^*(ab^*ab^*)^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><strong>eg.</strong> a+ is same as aa*</p>
<h1 id="week-5-june-8">Week 5. June 8</h1>
<h2 id="deterministic-finite-automata">deterministic finite automata</h2>
<ul>
<li>one symbol only corresponds to transition to one target state</li>
<li>errors states are implicit: if a state does not define a transition on a symbol, it is error</li>
</ul>
<p><strong>defn.</strong> a <em>DFA</em> is a 5-tuple <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>Q</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>A</mi><mo separator="true">,</mo><mi>δ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Sigma,Q,q_0,A,\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">Σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> is a finite non-empty set (alphabet)</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> is a finite non-empty set of states</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_0\in Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> is a start state</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">A\subseteq Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> is a set of accepting states</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mo stretchy="false">(</mo><mi>Q</mi><mo>×</mo><mi mathvariant="normal">Σ</mi><mo stretchy="false">)</mo><mo>→</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">\delta:(Q\times\Sigma)\rightarrow Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> is the [total] transition function</li>
</ul>
<p><strong>eg.</strong> the DFA for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mi>a</mi><msup><mi>b</mi><mo>∗</mo></msup><mi>a</mi></mrow><annotation encoding="application/x-tex">L=ab^*a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mord mathdefault">a</span></span></span></span> is</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Sigma=\{a,b\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mo stretchy="false">{</mo><mi>S</mi><mn>1</mn><mo separator="true">,</mo><mi>S</mi><mn>2</mn><mo separator="true">,</mo><mi>S</mi><mn>3</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">Q=\{S1,S2,S3\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">3</span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mo>=</mo><mi>S</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">q_0=S1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">{</mo><mi>S</mi><mn>3</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">A=\{S3\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">3</span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false">(</mo><mi>S</mi><mn>1</mn><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>S</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>S</mi><mn>2</mn><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>S</mi><mn>2</mn></msub><mo separator="true">,</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>S</mi><mn>2</mn><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mi>S</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">\delta(S1,a)=S_2,\delta(S2,b)=S_2,\delta(S2,a)=S3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord">3</span></span></span></span>. (note for some combination undefined, they are considered <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mi>R</mi><mi>R</mi></mrow><annotation encoding="application/x-tex">\delta(q,w)=ERR</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span></span></span></span>)</li>
</ul>
<p><img src="assets/w4_2.PNG" alt="img"></p>
<p>(left: shorthand)</p>
<p><strong>eg.</strong> labels in mips consisting of alphanumeric letters:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>z</mi><mo separator="true">,</mo><mi>A</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi>Z</mi><mo separator="true">,</mo><mn>0...9</mn><mo separator="true">,</mo><mo>:</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Sigma=\{a...z,A...Z,0...9,:\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.07153em;">Z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">9</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>q</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>q</mi><mn>2</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">Q=\{q_0,q_1,q_2\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">q_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is start state</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>q</mi><mn>2</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">A=\{q_2\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo stretchy="false">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mtext>letter</mtext><mo stretchy="false">)</mo><mo>=</mo><msub><mi>q</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>δ</mi><mo stretchy="false">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo separator="true">,</mo><mtext>letter or digit</mtext><mo stretchy="false">)</mo><mo>=</mo><msub><mi>q</mi><mn>1</mn></msub><mo separator="true">,</mo><mi>δ</mi><mo stretchy="false">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>:</mo><mo stretchy="false">)</mo><mo>=</mo><msub><mi>q</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">\delta(q_0,\text{letter})=q_1,\delta(q_1,\text{letter or digit})=q_1,\delta(q_1,:)=q_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">letter</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord text"><span class="mord">letter or digit</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. all others lead to error state</li>
</ul>
<p><img src="assets/w4_3.PNG" alt="img"></p>
<h3 id="dfa-recognition-algorithm">DFA recognition algorithm</h3>
<p>extend the definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span> to handle a sequence of transitions based on input string and provide the resulting state after the <em>sequence of characters</em> in the string has been consumed (left fold)</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi>δ</mi><mo>∗</mo></msup><mo>:</mo><mo stretchy="false">(</mo><mi>Q</mi><mo>×</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><mi>Q</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>ϵ</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>↦</mo><mi>q</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>a</mi><mi>w</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>↦</mo><msup><mi>δ</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    \delta^*:(Q\times\Sigma^*)&amp;\rightarrow Q\\
    (q,\epsilon)&amp;\mapsto q\\
    (q,aw)&amp;\mapsto\delta^*(\delta(q,a),w)
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ϵ</span><span class="mclose">)</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">Q</span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>w</mi><mo>∈</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">a\in\Sigma,w\in\Sigma^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">Σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><strong>defn.</strong> a DFA given by <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi><mo>=</mo><mo stretchy="false">(</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>Q</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>A</mi><mo separator="true">,</mo><mi>δ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">M=(\Sigma,Q,q_0,A,\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">Σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span> <em>accepts a string</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> iff <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>δ</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo>∈</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">\delta^*(q_0,w)\in A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>.</p>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div>dfa_recog(w=w[<span class="hljs-number">1</span>]w[<span class="hljs-number">2</span>]...w[n], s=q[<span class="hljs-number">0</span>]):
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n:
        s = delta(s, w[i]) <span class="hljs-keyword">or</span> reject(w) <span class="hljs-comment">/* if s is error */</span>
    <span class="hljs-keyword">if</span> s in A:
        accept(w)
    <span class="hljs-keyword">else</span>:
        reject(w)
</div></code></pre>
<p><strong>defn.</strong> the <em>language of a DFA</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>, is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>w</mi><mo>:</mo><mi>M</mi><mtext> accepts </mtext><mi>w</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(M)=\{w: M\text{ accepts } w\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord text"><span class="mord"> accepts </span></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">}</span></span></span></span>.</p>
<p><strong>theorem.</strong> <em>(Kleene)</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> is regular iff <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K=L(M)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span></span></span></span> for some DFA <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>. ie the regular languages are precisely the languages accepted by DFAs.</p>
<p><strong>eg.</strong> dfa that correctly recognizes $0,$1,...,$31</p>
<p><img src="assets/w4_4.PNG" alt="img"></p>
<h3 id="finite-transducer">finite transducer</h3>
<ul>
<li>for each transition, add an action to perform while taking the transition</li>
</ul>
<p><strong>eg.</strong> convert a string of binary digits to its decimal representation (N)</p>
<p><img src="assets/w4_5.PNG" alt="img"></p>
<p>if input is &quot;1011&quot;, when string is consumed, the number N is the decimal representation 11.</p>
<pre><code class="language-lua"><div><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">convert</span><span class="hljs-params">(s)</span></span>
    <span class="hljs-keyword">local</span> n
    <span class="hljs-keyword">local</span> state1, state2, errorstate = {}, {}, {}
    <span class="hljs-keyword">local</span> state = state1
    <span class="hljs-keyword">local</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">delta</span><span class="hljs-params">(currstate, inputc)</span></span> <span class="hljs-comment">--&gt; state</span>
        <span class="hljs-keyword">if</span> currstate == state1 <span class="hljs-keyword">then</span>
            <span class="hljs-keyword">if</span> inputc == <span class="hljs-string">'0'</span> <span class="hljs-keyword">then</span>
                n = <span class="hljs-number">0</span>
                <span class="hljs-keyword">return</span> state1
            <span class="hljs-keyword">elseif</span> inputc == <span class="hljs-string">'1'</span> <span class="hljs-keyword">then</span>
                n = <span class="hljs-number">1</span>
                <span class="hljs-keyword">return</span> state2
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> errorstate
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">elseif</span> currstate == state2 <span class="hljs-keyword">then</span>
            <span class="hljs-keyword">if</span> inputc == <span class="hljs-string">'0'</span> <span class="hljs-keyword">then</span>
                n = <span class="hljs-number">2</span> * n
                <span class="hljs-keyword">return</span> state2
            <span class="hljs-keyword">elseif</span> inputc == <span class="hljs-string">'1'</span> <span class="hljs-keyword">then</span>
                n = <span class="hljs-number">2</span> * n + <span class="hljs-number">1</span>
                <span class="hljs-keyword">return</span> state2
            <span class="hljs-keyword">else</span>
                <span class="hljs-keyword">return</span> errorstate
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">error</span>()
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<span class="hljs-built_in">gmatch</span>(<span class="hljs-string">'.'</span>) <span class="hljs-keyword">do</span>
        state = delta(state, c)
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> n
<span class="hljs-keyword">end</span>
<span class="hljs-built_in">print</span>(convert(<span class="hljs-string">'1011'</span>))
</div></code></pre>
<h2 id="non-deterministic-finite-automata">non-deterministic finite automata</h2>
<ul>
<li>allow more than one transition from a state on the same symbol. the machine chooses which path to go on</li>
</ul>
<p><strong>defn.</strong> an <em>NFA</em> is a 5-tuple <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>Q</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>A</mi><mo separator="true">,</mo><mi>δ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Sigma,Q,q_0,A,\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">Σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span>:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> is a finite non-empty set (alphabet)</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> is a finite non-empty set of states</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_0\in Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> is a start state</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">A\subseteq Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> is a set of accepting states</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mo stretchy="false">(</mo><mi>Q</mi><mo>×</mo><mi mathvariant="normal">Σ</mi><mo stretchy="false">)</mo><mo>→</mo><msup><mn>2</mn><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">\delta:(Q\times\Sigma)\rightarrow 2^Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Σ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span></span></span></span></span></span></span></span> is the [total] transition function. note <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">2^Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span></span></span></span></span></span></span></span> denotes all subsets of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>.</li>
</ul>
<p>only difference: DFA's transition function outputs a state, NFA's transition function outputs a <em>set</em> of states.</p>
<h3 id="nfa-recognition-algorithm">NFA recognition algorithm</h3>
<p>can extend the definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi>δ</mi><mo>∗</mo></msup><mo>:</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mi>Q</mi></msup><mo>×</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><msup><mn>2</mn><mi>Q</mi></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi>ϵ</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>↦</mo><mi>S</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi>a</mi><mi>w</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>↦</mo><msup><mi>δ</mi><mo>∗</mo></msup><mrow><mo fence="true">(</mo><munder><mo>⋃</mo><mrow><mi>q</mi><mo>∈</mo><mi>S</mi></mrow></munder><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>w</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    \delta^*:(2^Q\times\Sigma^*)&amp;\rightarrow 2^Q\\
    (S,\epsilon)&amp;\mapsto S\\
    (S,aw)&amp;\mapsto\delta^*\left(\bigcup_{q\in S}\delta(q,a),w\right)
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.951371em;vertical-align:-3.2256855em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.7256855em;"><span style="top:-6.8843745em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-5.3843745em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ϵ</span><span class="mclose">)</span></span></span><span style="top:-2.6743544999999997em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.2256855em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.7256855em;"><span style="top:-6.8843745em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span></span></span></span></span></span></span><span style="top:-5.3843745em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span><span style="top:-2.6743544999999997em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8100000000000005em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋃</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.430444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8100000000000005em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.2256855em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">a\in\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>.</p>
<p><strong>defn.</strong> an NFA <em>accepts a string</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> iff <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>δ</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mo stretchy="false">{</mo><msub><mi>q</mi><mn>0</mn></msub><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>A</mi><mo mathvariant="normal">≠</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\delta^*(\{q_0\},w)\cap A\neq\varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66334em;vertical-align:-0.08167em;"></span><span class="mord amsrm">∅</span></span></span></span>.</p>
<blockquote>
<p>“board game style” interpretation of NFA recognition: you start with one piece in the start state. When you read a symbol, you remove your piece from the current state, and then place new pieces in each of the states you transition to on the corresponding symbol. Drop the pieces if it  In each turn, you do this for all the states you are currently in. You accept when at least one of your pieces is in an accepting state after reading the whole word.</p>
</blockquote>
<p><strong>eg.</strong></p>
<pre><code class="language-cpp"><div>nfa_recog(w=w[<span class="hljs-number">1</span>]w[<span class="hljs-number">2</span>]...w[n], S={q[<span class="hljs-number">0</span>]}):
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n:
        S = {...delta(q, w[i]) <span class="hljs-keyword">for</span> q in S}
            <span class="hljs-keyword">or</span> reject(w) <span class="hljs-comment">/* if S = {} */</span>
    <span class="hljs-keyword">if</span> S ⋂ A is <span class="hljs-keyword">not</span> Ø:
        accept(w)
    <span class="hljs-keyword">else</span>:
        reject(w)
</div></code></pre>
<p><strong>eg.</strong> for the language L = {w: w ends with bba} over the alphabet {a,b}</p>
<p><img src="assets/w5_1.PNG" alt="img"></p>
<p>given an input word, the machine chooses to stay at q0 until it sees the ending bba. eg if the input is abbba:</p>
<table>
<thead>
<tr>
<th style="text-align:center">seen</th>
<th style="text-align:center">remain</th>
<th style="text-align:center">S</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ε</td>
<td style="text-align:center">abbba</td>
<td style="text-align:center">{q0}</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">bbba</td>
<td style="text-align:center">{q0}</td>
</tr>
<tr>
<td style="text-align:center">ab</td>
<td style="text-align:center">bba</td>
<td style="text-align:center">{q0,q1}</td>
</tr>
<tr>
<td style="text-align:center">abb</td>
<td style="text-align:center">ba</td>
<td style="text-align:center">{q0,q1,q2}</td>
</tr>
<tr>
<td style="text-align:center">abbb</td>
<td style="text-align:center">a</td>
<td style="text-align:center">{q0,q1,q2}</td>
</tr>
<tr>
<td style="text-align:center">abbba</td>
<td style="text-align:center">ε</td>
<td style="text-align:center">{q0,q3}</td>
</tr>
</tbody>
</table>
<p>{q0,q3} has accepting state q3, so abbba is accepted.</p>
<p><strong>defn.</strong> <em>the language of an NFA</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>, is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>M</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>w</mi><mo>:</mo><mi>M</mi><mtext> accepts </mtext><mi>w</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(M)=\{w: M\text{ accepts } w\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord text"><span class="mord"> accepts </span></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">}</span></span></span></span>.</p>
<h2 id="nfa-to-dfa">NFA to DFA</h2>
<ul>
<li>can write down all <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">2^Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span></span></span></span></span></span></span></span> possible sets of states (as one final state) and connect them based on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>δ</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\delta^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>.</li>
</ul>
<p>subset construction</p>
<ol>
<li>start with state <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>q</mi><mn>0</mn></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S=\{q_0\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>.</li>
<li>using the NDA, determine what happens for each <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>∈</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">q\in S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> separately for each symbol <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">a\in\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>. the set of resulting states becomes it own state in DFA and a transition is added from state S to this new state on symbol <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span>.</li>
<li>repeat previous step for each new state created until we exhausted every possibility.</li>
<li>accepting states are any states that included an accepting state of the original NFA.</li>
</ol>
<p><strong>eg.</strong><br>
<img src="assets/w5_2.PNG" alt="img"></p>
<p><strong>eg.</strong> L = {cab}∪{w: w contains even number of a's}<br>
<img src="assets/w5_3.PNG" alt="img"></p>
<p><strong>eg.</strong> L = {abc}∪{w: w ends with cc}<br>
<img src="assets/w5_4.PNG" alt="img"></p>
<p><strong>eg.</strong> from video<br>
<img src="assets/w5_5.PNG" alt="img"></p>
<h2 id="ε-non-deterministic-finite-automata">ε-non-deterministic finite automata</h2>
<ul>
<li>allows state transition without consuming a symbol</li>
<li>can glue two DFAs</li>
</ul>
<p><strong>defn.</strong> an <em>ε-NFA</em> is a 5-tuple <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Σ</mi><mo separator="true">,</mo><mi>Q</mi><mo separator="true">,</mo><msub><mi>q</mi><mn>0</mn></msub><mo separator="true">,</mo><mi>A</mi><mo separator="true">,</mo><mi>δ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\Sigma,Q,q_0,A,\delta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">Σ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">Q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mclose">)</span></span></span></span>:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span> is a finite non-empty set (alphabet) <em>that does not contain the symbol <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span></em></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> is a finite non-empty set of states</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>q</mi><mn>0</mn></msub><mo>∈</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">q_0\in Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> is a start state</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⊆</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">A\subseteq Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span> is a set of accepting states</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi><mo>:</mo><mo stretchy="false">(</mo><mi>Q</mi><mo>×</mo><mi mathvariant="normal">Σ</mi><mo>∪</mo><mo stretchy="false">{</mo><mi>ϵ</mi><mo stretchy="false">}</mo><mo stretchy="false">)</mo><mo>→</mo><msup><mn>2</mn><mi>Q</mi></msup></mrow><annotation encoding="application/x-tex">\delta:(Q\times\Sigma\cup\{\epsilon\})\rightarrow 2^Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">ϵ</span><span class="mclose">}</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span></span></span></span></span></span></span></span> is the [total] transition function.</li>
</ul>
<h3 id="ε-nfa-recognition-algorithm">ε-NFA recognition algorithm</h3>
<p><strong>defn.</strong> the <em>epsilon closure</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">E(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span> of a set of states <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> is the set of all states reachable from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> in 0 or more ε-transitions. note <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>⊆</mo><mi>E</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S\subseteq E(S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8193em;vertical-align:-0.13597em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>.</p>
<p>can extend the definition of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>δ</mi></mrow><annotation encoding="application/x-tex">\delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span></span></span></span>:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><msup><mi>δ</mi><mo>∗</mo></msup><mo>:</mo><mo stretchy="false">(</mo><msup><mn>2</mn><mi>Q</mi></msup><mo>×</mo><msup><mi mathvariant="normal">Σ</mi><mo>∗</mo></msup><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>→</mo><msup><mn>2</mn><mi>Q</mi></msup></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi>ϵ</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>↦</mo><mi>S</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>S</mi><mo separator="true">,</mo><mi>a</mi><mi>w</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>↦</mo><msup><mi>δ</mi><mo>∗</mo></msup><mrow><mo fence="true">(</mo><munder><mo>⋃</mo><mrow><mi>q</mi><mo>∈</mo><mi>S</mi></mrow></munder><mi>E</mi><mo stretchy="false">(</mo><mi>δ</mi><mo stretchy="false">(</mo><mi>q</mi><mo separator="true">,</mo><mi>a</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>w</mi><mo fence="true">)</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
    \delta^*:(2^Q\times\Sigma^*)&amp;\rightarrow 2^Q\\
    (S,\epsilon)&amp;\mapsto S\\
    (S,aw)&amp;\mapsto\delta^*\left(\bigcup_{q\in S}E(\delta(q,a)),w\right)
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6.951371em;vertical-align:-3.2256855em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.7256855em;"><span style="top:-6.8843745em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord">Σ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-5.3843745em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">ϵ</span><span class="mclose">)</span></span></span><span style="top:-2.6743544999999997em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.2256855em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.7256855em;"><span style="top:-6.8843745em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-3.1130000000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">Q</span></span></span></span></span></span></span></span></span></span><span style="top:-5.3843745em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span><span style="top:-2.6743544999999997em;"><span class="pstrut" style="height:4.05002em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">↦</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.738696em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎝</span></span></span><span style="top:-2.8100000000000005em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎜</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎛</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8556639999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">q</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">⋃</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.430444em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎠</span></span></span><span style="top:-2.8100000000000005em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎟</span></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎞</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.2256855em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">a\in\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>.</p>
<p><strong>defn.</strong> an ε-NFA <em>accepts a string</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> iff <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>δ</mi><mo>∗</mo></msup><mo stretchy="false">(</mo><mo stretchy="false">{</mo><msub><mi>q</mi><mn>0</mn></msub><mo stretchy="false">}</mo><mo separator="true">,</mo><mi>w</mi><mo stretchy="false">)</mo><mo>∩</mo><mi>A</mi><mo mathvariant="normal">≠</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\delta^*(\{q_0\},w)\cap A\neq\varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03785em;">δ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66334em;vertical-align:-0.08167em;"></span><span class="mord amsrm">∅</span></span></span></span>.</p>
<p><strong>eg.</strong> L = {abc}∪{w: w ends with cc}<br>
<img src="assets/w5_6.PNG" alt="img"><br>
in which the epsilon closure of q0 is {q0,q1,q5}</p>
<h3 id="ε-nfa-to-nfa">ε-NFA to NFA</h3>
<ol>
<li>if a transition path from <code>source</code> state to a <code>dest</code> state consists of a sequence of ε transitions followed by a single transition on symbol <code>a</code>, add a direct transition from <code>source</code> to <code>dest</code> labeled with <code>a</code>.</li>
<li>if a sequence of ε transitions leads to an accepting state, make all states in the sequence accepting</li>
<li>remove all ε states</li>
<li>remove all unreachable states</li>
</ol>
<p><strong>eg.</strong><br>
<img src="assets/w5_7.PNG" alt="img"></p>
<p>Kleene's theorem also says any regular expression can be converted to an ε-NFA.</p>
<p><img src="assets/w5_8.PNG" alt="img"></p>
<h1 id="week-6-june-15">Week 6. June 15</h1>
<h2 id="maximal-munch-scanning">maximal munch scanning</h2>
<ul>
<li>greedy, tries to find the longest match. uses backtrack if a longer match is not possible</li>
</ul>
<p><strong>eg.</strong> L={a,b,abca}</p>
<p><img src="assets/w5_9.PNG" alt="img"></p>
<blockquote>
<p>Consider the input s = ababca. The algorithm consumes a and ﬂags this state, q1, as it is accepting. Being greedy, the algorithm continues to consume more input rather than outputting this token. The algorithm consumes b and reaches state q2. At this point, the algorithm is stuck; it is not at an accepting state and there is no transition on symbol a (the next symbol in the input). The algorithm backtracks to the last seen accepting state, “un-consuming” input that it had greedily consumed. The last seen accepting state is q1, when only a had been consumed. The algorithm outputs an a token and resets the state to q0, the start state. The algorithm then resumes consuming b and ﬂags state q5 as the last seen accepting state. At this point, the algorithm is stuck again as there is no transition on a. Since the current state is an accepting state, the algorithm outputs token b and resets to q0. The algorithm then consumes the second a, the second b, the ﬁrst c, the third a and runs out of input. This last state, q4, is accepting so the last token abca is output.</p>
</blockquote>
<p>problem: above procedure is O(n^2). eg <code>L=&quot;abc|(abc)*d&quot;</code> with input <code>&quot;abcabcabcabcabcabcabcabcabc&quot;</code>.</p>
<p>problem: consider language <code>L={aa,aaa}</code>. if input is aaaaa, max munch gives <code>aaa</code>, <code>aaa</code>; if input is <code>aaaa</code>, max munch gives <code>aaa</code> even if <code>aa,aa</code> is possible.</p>
<h3 id="simplified-maximal-munch">simplified maximal munch</h3>
<ul>
<li>do not do any back track at all.</li>
<li>eg <code>L={a,b,abca}</code>, input is <code>ababca</code>. it is rejected when the state is stuck at second <code>a</code></li>
</ul>
<pre><code class="language-cpp"><div>simplified_mm(w=w[<span class="hljs-number">1</span>]w[<span class="hljs-number">2</span>]...w[n], s=q[<span class="hljs-number">0</span>]):
<span class="hljs-comment">// for DFA</span>
    <span class="hljs-keyword">for</span> i = <span class="hljs-number">1</span>, n:
        next = delta(s, w[i])
        <span class="hljs-keyword">if</span> next is error:
            <span class="hljs-keyword">if</span> s in A:
                yield token <span class="hljs-keyword">for</span> state s
                <span class="hljs-comment">// continue with remaining characters</span>
                s = q[<span class="hljs-number">0</span>]
            <span class="hljs-keyword">else</span>:
                reject(w)
        <span class="hljs-keyword">else</span>:
            s = next
    <span class="hljs-keyword">if</span> s in A:
        yield token <span class="hljs-keyword">for</span> state s
        accept(w)
    <span class="hljs-keyword">else</span>:
        reject(w)
</div></code></pre>
<h1 id="week-7-june-23">Week 7. June 23</h1>
<p>typical compiler components:</p>
<pre><code><code><div>                                                        parse tree
                                                        symbol
input  +---------+        +---------+parse  +----------+table  +-----------+ output
code   |         | token  |         |tree   |context   |...    | code      | code
+----&gt; | scanner +------&gt; | parser  +-----&gt; |sensitive +-----&gt; |generation +-------&gt;
       +---------+        +---------+       |analysis  |       +-----------+
                                            +----------+
                           analysis                              synthesis
        &lt;----------------------------------------------&gt;       &lt;-----------&gt;
</div></code></code></pre>
<p>scanner weeds out lexically invalid programs (wrong keyword); context sensitive analysis weed out weed out semantically invalid programs (undefined identifier...)</p>
<h2 id="balanced-parentheses-problem">balanced parentheses problem</h2>
<p>to recognize valid arithmetic expressions from <code>Σ={ID (var name) ,OP (+=*/) ,LPAREN, RPAREN}</code>, the following DFA can be used</p>
<p><img src="assets/w7_1.PNG" alt="img"></p>
<p>this allows one level paren eg <code>(a+b)*(c-d)</code>. (to allow nested parens, append after the second line with same arrows)</p>
<p>this regular language does not allow infinite nestings.</p>
<h2 id="context-free-grammars">context free grammars</h2>
<p><strong>defn.</strong> a <em>context free grammar (CFG)</em> is a 4 tuple:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> is a finite, nonempty set  of <em>non-terminal symbols</em></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> is an alphabet; a finite, nonempty set of <em>terminal symbols</em></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> is a finite set of <em>productions/rules</em>, each of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">A\rightarrow\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>∈</mo><mi>N</mi><mo separator="true">,</mo><mi>β</mi><mo>∈</mo><mo stretchy="false">(</mo><mi>N</mi><mo>∪</mo><mi>T</mi><msup><mo stretchy="false">)</mo><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">A\in N,\beta\in(N\cup T)^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∈</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">S\in N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> is a start symbol</li>
</ul>
<p>the set of all symbols <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo>=</mo><mi>N</mi><mo>∪</mo><mi>T</mi></mrow><annotation encoding="application/x-tex">V=N\cup T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> is called the <em>vocabulary</em>.</p>
<p><strong>eg.</strong> a CFG representing valid arithmetic expressions with arbitrary balanced parens:</p>
<pre><code><code><div>N = { expr }
T = { ID, OP, LPAREN, RPAREN }
productions:
expr -&gt; ID
expr -&gt; expr OP expr
expr -&gt; LPAREN expr RPAREN
S = expr
</div></code></code></pre>
<p>note each lhs must have a non-terminal, each rhs can have both terminal and non-terminal.</p>
<h3 id="conventions">conventions</h3>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo separator="true">,</mo><mi>c</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">a,b,c,...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">c</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span> are elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi></mrow><annotation encoding="application/x-tex">T</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span></span></span></span> (<em>terminals</em>)</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi><mo separator="true">,</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">w,x,y,z,...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span> are elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>T</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">T^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> (<em>words</em>)</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo separator="true">,</mo><mi>B</mi><mo separator="true">,</mo><mi>C</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">A,B,C,...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span> are elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi></mrow><annotation encoding="application/x-tex">N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span> (<em>non-terminals</em>)</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo separator="true">,</mo><mi>γ</mi><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi></mrow><annotation encoding="application/x-tex">\alpha,\beta,\gamma,...</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span></span></span></span> ar elements of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>V</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">V^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span> (<em>sequences of terminals and non-terminals</em>)</li>
<li>when not specified, the non-terminal on lhs of the first production is the start symbol</li>
</ul>
<p><strong>defn.</strong> over a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>F</mi><mi>G</mi><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>T</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">CFG(N,T,P,S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>, we say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> <em>directly derives</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>⇒</mo><mi>γ</mi></mrow><annotation encoding="application/x-tex">A\Rightarrow\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>, iff there is a rule <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>γ</mi></mrow><annotation encoding="application/x-tex">A\rightarrow\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span> in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>.</p>
<p><strong>defn.</strong> over a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>F</mi><mi>G</mi><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>T</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">CFG(N,T,P,S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>, we say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> <em>derives</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha\Rightarrow^*\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>, if either <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>=</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">\alpha=\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>, or there exists <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo>⇒</mo><mi>γ</mi></mrow><annotation encoding="application/x-tex">\alpha\Rightarrow\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>β</mi></mrow><annotation encoding="application/x-tex">\gamma\Rightarrow^*\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8831359999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span>.</p>
<p><strong>defn.</strong> over a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>F</mi><mi>G</mi><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>T</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">CFG(N,T,P,S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>, a <em>derivation of a string of terminals</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> is a sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mn>0</mn></msub><msub><mi>α</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>α</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_0\alpha_1...\alpha_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mn>0</mn></msub><mo>=</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">\alpha_0=S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>n</mi></msub><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">\alpha_n=x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>i</mi></msub><mo>⇒</mo><msub><mi>α</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">\alpha_i\Rightarrow\alpha_{i+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span> for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">0\leq i\leq n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.78041em;vertical-align:-0.13597em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span>.</p>
<p>CFG is a set of rewriting rules that expand every non-terminals on rhs by terminals</p>
<p><strong>eg.</strong> <code>expr</code> directly  derives <code>ID</code> because there is <code>expr -&gt; ID</code> in productions.</p>
<p><strong>eg.</strong> show <code>expr =&gt;* ID OP LPAREN ID OP ID RPAREN</code></p>
<pre><code><code><div>expr =&gt; expr OP expr                        (apply expr -&gt; expr OP expr)
     =&gt; ID OP expr                          (apply expr -&gt; ID)
     =&gt; ID OP LPAREN expr RPAREN            (apply expr -&gt; LPAREN expr RPAREN)
     =&gt; ID OP LPAREN expr OP expr RPAREN    (apply expr -&gt; expr OP expr)
     =&gt; ID OP LPAREN ID OP expr RPAREN      (apply expr -&gt; ID)
     =&gt; ID OP LPAREN ID OP ID RPAREN        (apply expr -&gt; ID)
</div></code></code></pre>
<p>each step of the derivation chooses a non-terminal from the current <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and rewrites it by replacing it with the rhs of some rule for that non-terminal.</p>
<h3 id="context-free-languages">context free languages</h3>
<p><strong>defn.</strong> the <em>language</em> of a <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mi>F</mi><mi>G</mi><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>T</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">CFG(N,T,P,S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span> is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>ω</mi><mo>∈</mo><msup><mi>T</mi><mo>∗</mo></msup><mo>:</mo><mi>S</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>w</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">L(G)=\{\omega\in T^*:S\Rightarrow^*w\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mclose">}</span></span></span></span>.</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>w</mi></mrow><annotation encoding="application/x-tex">w</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span></span></span></span> must be all terminals.</li>
</ul>
<p><strong>defn.</strong> a language is context-free iff there exists a CFG <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi></mrow><annotation encoding="application/x-tex">G</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span></span></span></span> such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L=L(G)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span></span></span></span>.</p>
<ul>
<li>every regular language is context-free.</li>
</ul>
<p><strong>eg.</strong> let <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo separator="true">,</mo><mi>b</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">T=\{a,b\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span><span class="mclose">}</span></span></span></span>, write a CFG for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msup><mi>a</mi><mi>n</mi></msup><msup><mi>b</mi><mi>n</mi></msup><mo>:</mo><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{a^nb^n:n\in\mathbb{N}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathbb">N</span></span><span class="mclose">}</span></span></span></span>. find a derivation for string <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>a</mi><mi>a</mi><mi>b</mi><mi>b</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">aaabbb</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">b</span><span class="mord mathdefault">b</span><span class="mord mathdefault">b</span></span></span></span>.</p>
<pre><code><code><div>N = { S }
T = { a, b }
productions:
S -&gt; ε
S -&gt; aSb

aaabbb:
S =&gt; aSb =&gt; aaSbb =&gt; aaaSbbb =&gt; aaabbb
</div></code></code></pre>
<p>the shorthand is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>ϵ</mi><mi mathvariant="normal">∣</mi><mi>a</mi><mi>S</mi><mi>b</mi></mrow><annotation encoding="application/x-tex">S\rightarrow \epsilon|aSb</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">ϵ</span><span class="mord">∣</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">b</span></span></span></span>. note the lhs, first production rule tells the start symbol; and N, T are inferred from rules.</p>
<p><strong>eg.</strong> write a CFG for palindromes over { a,b,c }.</p>
<pre><code><code><div>S -&gt; aSa | bSb | cSc | M
M -&gt; a | b | c | ε
</div></code></code></pre>
<p><strong>eg.</strong> write a CFG for regular expression <code>a(a|b)*b</code>.</p>
<pre><code><code><div>S -&gt; aMb
M -&gt; aM | bM | ε
</div></code></code></pre>
<p><strong>eg.</strong> write a CFG for regular expression <code>a|b+</code>.</p>
<pre><code><code><div>S -&gt; a | M
M -&gt; b | M b
</div></code></code></pre>
<h3 id="reduced-grammars">reduced grammars</h3>
<p>if grammar has useless production rule of infinite recursion it is not reduced.</p>
<h2 id="parse-trees">parse trees</h2>
<p><strong>eg.</strong> consider language L(G) = { abgh, abgef, cdgh, cdgef }</p>
<pre><code><code><div>S -&gt; BgC
B -&gt; ab|cd
C -&gt; h|ef
</div></code></code></pre>
<p>then for string <code>abgef</code> it has two derivations, but resulting in same parse tree</p>
<pre><code><code><div>S =&gt; BgC =&gt; Bgef =&gt; abgef  (rightmost derivation, expand right non-terminal first)
S =&gt; BgC =&gt; abgC =&gt; abgef  (leftmost derivation, expand left non-terminal first)
                   
         S         
       / | \       
      /  |  \      
     /   |   \     
    B    g    C    
   / \       / \   
  /   \     /   \  
 /     \   /     \ 
a       b e       f
</div></code></code></pre>
<p>the root is the start symbol; non-leaf node is a non-terminal and its immediate descendants are rhs of the rule; leaf nodes are terminals of ε.<br>
parse trees has two properties:</p>
<ul>
<li>a derivation uniquely defines a parse tree</li>
<li>an input string can have more than one parse tree</li>
</ul>
<h2 id="ambiguous-grammars">ambiguous grammars</h2>
<p><strong>defn.</strong> a grammar is <em>ambibuous</em> if ther eis a word in the language which has more than one distinct leftmost derivation, or more than one distinct rightmost derivation.</p>
<p><strong>eg.</strong> consider a CFG for arithmetic operations</p>
<pre><code><code><div>S -&gt; a|b|c|SRS
R -&gt; +|-|*|/
</div></code></code></pre>
<p>the string <code>a - b * c</code> has two derivations even with leftmost derivation:</p>
<p><img src="assets/w7_2.PNG" alt="img"></p>
<p>we can force a pair of brackets to specify the order, so that only <code>((a-b)*c)</code> or <code>(a-(b*c)) </code> are accepted:</p>
<pre><code><code><div>S -&gt; a|b|c|(SRS)
R -&gt; +|-|*|/
</div></code></code></pre>
<p>we can make the language right/left associative by controlling the recursion depth:</p>
<p><img src="assets/w7_3.PNG" alt="img"></p>
<p>we can make * and / appear further down the tree so they take precedence:</p>
<pre><code><code><div>S -&gt; SPT|T
T -&gt; TRF|F
F -&gt; a|b|c|(S)
P -&gt; +|-
R -&gt; *|/
</div></code></code></pre>
<p>eg the input <code>a - b * c</code> has following tree:</p>
<p><img src="assets/w7_4.PNG" alt="img"></p>
<p>expression is evaluated using post-order, depth-first traversal.</p>
<pre><code class="language-cpp"><div>eval_tree(t):
    <span class="hljs-keyword">switch</span> t:
        S -&gt; SPT: <span class="hljs-keyword">return</span> eval_expr(t.S, t.P, t.T)
        T -&gt; TRF: <span class="hljs-keyword">return</span> eval_expr(t.T, t.R, t.F)
        S -&gt; T: T -&gt; F: <span class="hljs-keyword">return</span> eval_tree(t.child)
        F -&gt; a|b|c: <span class="hljs-keyword">return</span> values
        F -&gt; (S): <span class="hljs-keyword">return</span> eval_tree(t.S)
        P -&gt; +|-: R -&gt; *|/: <span class="hljs-keyword">return</span> t.<span class="hljs-keyword">operator</span>

eval_expr(left_tree, op_tree, right_tree):
    <span class="hljs-keyword">auto</span> left = eval_tree(left_tree)
    <span class="hljs-keyword">auto</span> op = eval_tree(op_tree)
    <span class="hljs-keyword">auto</span> right = eval_tree(right_tree)
    <span class="hljs-keyword">return</span> left op right
</div></code></pre>
<h2 id="decidability-of-ambiguous-grammars">decidability of ambiguous grammars</h2>
<ul>
<li>given a context free language <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi></mrow><annotation encoding="application/x-tex">L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span>, there is no gurantee that an unambiguous grammar such that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><mi>G</mi><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi></mrow><annotation encoding="application/x-tex">L(G)=L</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault">G</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span></span></span></span> exists.</li>
<li>it is not possible to algorithmically recognize whether a grammar is ambiguous.</li>
<li>given CFGs <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>G</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>G</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">G_1,G_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> it is not algorimically determine whether <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><msub><mi>G</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi>L</mi><mo stretchy="false">(</mo><msub><mi>G</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">L(G_1)=L(G_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>, whether <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mo stretchy="false">(</mo><msub><mi>G</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>∩</mo><mi>L</mi><mo stretchy="false">(</mo><msub><mi>G</mi><mn>2</mn></msub><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">L(G_1)\cap L(G_2)=\varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66334em;vertical-align:-0.08167em;"></span><span class="mord amsrm">∅</span></span></span></span>.</li>
</ul>
<blockquote>
<p>Formally, context-free languages can be recognized by a model of computation called <em>Pushdown Automata</em>. A Pushdown Automaton (PDA) is a Finite Automaton with the addition of a stack, and stack actions on transitions: Each transition may push a symbol to the stack, pop a symbol, and/or require that a given symbol be on the top of the stack. Like Finite Automata, there are Deterministic PDA’s and Nondeterministic PDA’s. But, while the number of states is ﬁnite like Finite Automata, the stack is potentially inﬁnite, and because of this inﬁnite component, there is no conversion of NPDA’s to DPDA’s equivalent to the conversion of NFA’s to DFA’s. Without this conversion, it’s impractical to actually use PDA’s to recognize context-free languages. Instead, we use a number of parsing algorithms which are less powerful than PDA’s, parsing only a subset of CFL’s, but which are much more practical.</p>
</blockquote>
<h1 id="week-8-june-29">Week 8. June 29</h1>
<h2 id="augmented-grammars">augmented grammars</h2>
<p>it is better if the start symbol has only one production rule. if not, we can augument the grammar CFG <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>T</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G(N,T,P,S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">G</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span> to create <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>G</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">(</mo><msup><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo separator="true">,</mo><msup><mi>S</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G&#x27;(N&#x27;,T&#x27;,P&#x27;,S&#x27;)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">G</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msup><mi>N</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>N</mi><mo>∪</mo><mrow><mo fence="true">{</mo><msup><mi>S</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo fence="true">}</mo></mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>T</mi><mo>∪</mo><mo stretchy="false">{</mo><mo>⊢</mo><mo separator="true">,</mo><mo>⊣</mo><mo stretchy="false">}</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><msup><mi>P</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>=</mo><mi>P</mi><mo>∪</mo><mrow><mo fence="true">{</mo><msup><mi>S</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mtext> </mtext><mo>⊢</mo><mi>S</mi><mo>⊣</mo><mo fence="true">}</mo></mrow></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
N^{\prime}&amp;=N \cup\left\{S^{\prime}\right\}\\
T^{\prime}&amp;=T \cup\{\vdash, \dashv\}\\
P^{\prime}&amp;=P \cup\left\{S^{\prime} \rightarrow\, \vdash S \dashv\right\}\\
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span><span style="top:-3.16em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">{</span><span class="mrel">⊢</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊣</span><span class="mclose">}</span></span></span><span style="top:-1.6599999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.801892em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊣</span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>S</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">S&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> is new start state with only one rule, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⊢</mo><mo separator="true">,</mo><mo>⊣</mo></mrow><annotation encoding="application/x-tex">\vdash,\dashv</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mrel">⊢</span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊣</span></span></span></span> are begin of file and end of file.</p>
<h2 id="top-down-parsing">top-down parsing</h2>
<h3 id="ll1">LL(1)</h3>
<p>given a string, we want to output a (leftmost) derivation. ie a sequence <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mn>1</mn></msub><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><msub><mi>α</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_1...\alpha_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p>
<p><strong>defn.</strong> <em>LL(1)</em> means Left to right, Leftmost derivations, look ahead at 1 symbol.</p>
<p><strong>defn.</strong> a grammar is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LL(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> iff each cell of the predict table contains at most one rule.</p>
<p>following parsing is LL(1) parsing:</p>
<pre><code class="language-cpp"><div>top_down_parse(input):
    <span class="hljs-comment">// given a first matched character a, current nonterminal A,</span>
    <span class="hljs-comment">// predict[A][a] gives a possible derivation</span>
    <span class="hljs-keyword">auto</span> stk = <span class="hljs-keyword">new</span> <span class="hljs-built_in">stack</span>
    stk.push(S')
    <span class="hljs-keyword">for</span> a in <span class="hljs-string">"⊢ input ⊣"</span>:
        <span class="hljs-keyword">auto</span> A = stk.top()
        <span class="hljs-comment">// if TOS (top of stack) is a non terminal</span>
        <span class="hljs-keyword">while</span> A in N:
            stk.pop()
            <span class="hljs-keyword">if</span> predict[A][a] gives <span class="hljs-string">"A -&gt; γ"</span>:
                push to stk symbols in γ right to left
                <span class="hljs-comment">// at his point link items in stack with tree nodes</span>
                <span class="hljs-comment">// at this point yield read+stack snapshot for derivation</span>
            <span class="hljs-keyword">else</span>:
                reject(input)
        <span class="hljs-comment">// if TOS is a terminal</span>
        <span class="hljs-keyword">if</span> stk.top() != a:
            reject(input)
        <span class="hljs-keyword">else</span>: <span class="hljs-comment">// match</span>
            stk.pop()
            <span class="hljs-comment">// at this point put the actual string to token node</span>
    accept(input) <span class="hljs-comment">// stk is necessarily empty</span>
</div></code></pre>
<p>it rejects input when 1. TOS is a terminal, but does not match the next input symbol, 2. the algorithm queries <code>predict</code> but finds no rules or multiple rules</p>
<p><strong>eg.</strong></p>
<pre><code><code><div>productions:           predict
1. S' -&gt; ⊢ S ⊣            ⊢ a b c d w x y z ⊣
2. S  -&gt; AyB           S' 1
3. A  -&gt; ab            S     2 2
4. A  -&gt; cd            A     3 4
5. B  -&gt; z             B             6     5
6. B  -&gt; wx
</div></code></code></pre>
<p>input is <code>abywx</code>, procedure is</p>
<table>
<thead>
<tr>
<th style="text-align:left">read</th>
<th style="text-align:left">unread</th>
<th style="text-align:right">stack</th>
<th style="text-align:left"></th>
<th style="text-align:left">derivations (read+stack)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ε</td>
<td style="text-align:left">⊢ a b y w x ⊣</td>
<td style="text-align:right">S'</td>
<td style="text-align:left">pop S', <code>predict[S'][⊢]</code> gives 1, push ⊣ S ⊢</td>
<td style="text-align:left">S'</td>
</tr>
<tr>
<td style="text-align:left">ε</td>
<td style="text-align:left">⊢ a b y w x ⊣</td>
<td style="text-align:right">⊢ S ⊣</td>
<td style="text-align:left">match ⊢</td>
<td style="text-align:left">⊢ S ⊣</td>
</tr>
<tr>
<td style="text-align:left">⊢</td>
<td style="text-align:left">a b y w x ⊣</td>
<td style="text-align:right">S ⊣</td>
<td style="text-align:left">pop S, <code>predict[S][a]</code> gives 2, push B y A</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊢</td>
<td style="text-align:left">a b y w x ⊣</td>
<td style="text-align:right">A y B ⊣</td>
<td style="text-align:left">pop A, <code>predict[A][a]</code> gives 3, push b a</td>
<td style="text-align:left">⊢ A y B ⊣</td>
</tr>
<tr>
<td style="text-align:left">⊢</td>
<td style="text-align:left">a b y w x ⊣</td>
<td style="text-align:right">a b y B ⊣</td>
<td style="text-align:left">match a</td>
<td style="text-align:left">⊢ a b y B ⊣</td>
</tr>
<tr>
<td style="text-align:left">⊢ a</td>
<td style="text-align:left">b y w x ⊣</td>
<td style="text-align:right">b y B ⊣</td>
<td style="text-align:left">match b</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊢ a b</td>
<td style="text-align:left">y w x ⊣</td>
<td style="text-align:right">y B ⊣</td>
<td style="text-align:left">match y</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊢ a b y</td>
<td style="text-align:left">w x ⊣</td>
<td style="text-align:right">B ⊣</td>
<td style="text-align:left">pop B, <code>predict[B][w]</code> gives 6, push x w</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊢ a b y</td>
<td style="text-align:left">w x ⊣</td>
<td style="text-align:right">w x ⊣</td>
<td style="text-align:left">match w</td>
<td style="text-align:left">⊢ a b y w x ⊣</td>
</tr>
<tr>
<td style="text-align:left">⊢ a b y w</td>
<td style="text-align:left">x ⊣</td>
<td style="text-align:right">x ⊣</td>
<td style="text-align:left">match x</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊢ a b y w x</td>
<td style="text-align:left">⊣</td>
<td style="text-align:right">⊣</td>
<td style="text-align:left">match ⊣</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊢ a b y w x ⊣</td>
<td style="text-align:left">ε</td>
<td style="text-align:right"></td>
<td style="text-align:left">accept</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>the derivation is 1, 2, 3, 6: <code>S' =&gt; ⊢S⊣ =&gt; ⊢AyB⊣ =&gt; ⊢abyB⊣ =&gt; ⊢abywx⊣</code>.</p>
<p>also note the concatenation of read and stack gives the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>α</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\alpha_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>'s obtained in the derivation used in parse tree.</p>
<h3 id="computing-predict-table">computing predict table</h3>
<p><strong>defn.</strong></p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>First</mtext><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo>∈</mo><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>:</mo><mi>β</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>a</mi><mi>γ</mi><mo separator="true">,</mo><mi>γ</mi><mo>∈</mo><msup><mi>V</mi><mo>∗</mo></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\text{First}(\beta)=\{a\in T&#x27;:\beta\Rightarrow^*a\gamma,\gamma\in V^*\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">First</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.7335400000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>, set of terminals that can be first non terminal symbol of some rule</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Nullable</mtext><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>true iff </mtext><mi>β</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\text{Nullable}(\beta)=\text{true iff }\beta\Rightarrow^*\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Nullable</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">true iff </span></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>, nonterminal that derives to empty string</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Follow</mtext><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>b</mi><mo>∈</mo><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>:</mo><msup><mi>S</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><msup><mo>⇒</mo><mo lspace="0em" rspace="0em">∗</mo></msup><mi>α</mi><mi>A</mi><mi>b</mi><mi>β</mi><mtext> for some </mtext><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo>∈</mo><msup><mi>V</mi><mo lspace="0em" rspace="0em">∗</mo></msup><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\text{Follow}(A)=\{b \in T&#x27;: S&#x27; \Rightarrow^{*} \alpha A b \beta\text{ for some }\alpha, \beta \in V^{*}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Follow</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">b</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord mathdefault">A</span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mord text"><span class="mord"> for some </span></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">∗</span></span></span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span>, set of terminals that come immediately after A in a derivation starting at the start symbol S'</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>predict</mtext><mo stretchy="false">[</mo><mi>A</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo><mo>=</mo><mo stretchy="false">{</mo><mi>A</mi><mo>→</mo><mi>β</mi><mo>:</mo><mi>a</mi><mo>∈</mo><mtext>First</mtext><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo><mo>∪</mo><mo stretchy="false">{</mo><mi>A</mi><mo>→</mo><mi>β</mi><mo>:</mo><mi>β</mi><mtext> is nullable and </mtext><mi>a</mi><mo>∈</mo><mtext>Follow</mtext><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\text{predict}[A][a]=\{A\rightarrow\beta:a\in\text{First}(\beta)\}\cup\{A\rightarrow\beta:\beta\text{ is nullable and }a\in\text{Follow}(A)\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">predict</span></span><span class="mopen">[</span><span class="mord mathdefault">A</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">First</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mord text"><span class="mord"> is nullable and </span></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Follow</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mclose">}</span></span></span></span></li>
</ul>
<p><strong>eg.</strong></p>
<pre><code><code><div>1. S' -&gt; ⊢ S ⊣             predict
2. S  -&gt; E S                   ⊢ ⊣ id num : ; if then
3. S  -&gt; ε                  S' 1
4. E  -&gt; id                 S    3  2  2  2 3  2  3
5. E  -&gt; num                E       4  5  6    7
6. E  -&gt; : id S ;
7. E  -&gt; if S then
</div></code></code></pre>
<ul>
<li>iterate through non-terminals</li>
<li>if non-terminal -&gt; terminal as first symbol, take that rule containing the first symbol</li>
<li>if non-terminal -&gt; non-terminal as first symbol, expand that non-terminal</li>
<li>if non-terminal -&gt; ε, consider what might follow this non-terminal</li>
</ul>
<p><strong>computing nullable</strong><br>
observations:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Nullable</mtext><mo stretchy="false">(</mo><mi>ϵ</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>true</mtext></mrow><annotation encoding="application/x-tex">\text{Nullable}(\epsilon)=\text{true}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Nullable</span></span><span class="mopen">(</span><span class="mord mathdefault">ϵ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord text"><span class="mord">true</span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Nullable</mtext><mo stretchy="false">(</mo><mi>β</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>false whenever </mtext><mi>β</mi><mtext> has a terminal</mtext></mrow><annotation encoding="application/x-tex">\text{Nullable}(\beta)=\text{false whenever } \beta\text{ has a terminal}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Nullable</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord">false whenever </span></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mord text"><span class="mord"> has a terminal</span></span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>Nullable</mtext><mo stretchy="false">(</mo><mi>A</mi><mi>B</mi><mo stretchy="false">)</mo><mo>=</mo><mtext>Nullable(A)</mtext><mo>∧</mo><mtext>Nullable(B)</mtext></mrow><annotation encoding="application/x-tex">\text{Nullable}(AB)=\text{Nullable(A)}\land\text{Nullable(B)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Nullable</span></span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Nullable(A)</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">Nullable(B)</span></span></span></span></span></li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-comment">// compute Nullable(A) for all A in N'</span>
nullable = [<span class="hljs-literal">false</span> <span class="hljs-keyword">for</span> A in N']
<span class="hljs-keyword">do</span>:
    <span class="hljs-keyword">for</span> production in P:
        <span class="hljs-keyword">if</span> P is <span class="hljs-string">"A -&gt; ε"</span> <span class="hljs-keyword">or</span> (P is <span class="hljs-string">"A -&gt; B1...Bk"</span>
            <span class="hljs-keyword">and</span> nullable[B1] == ... == nullable[Bk] == <span class="hljs-literal">true</span>):
            nullable[A] = <span class="hljs-literal">true</span>
<span class="hljs-keyword">while</span> nullable changed
</div></code></pre>
<p>have to cycle enough times until the nullable result does not change from previous iteration.</p>
<p><strong>computing first</strong><br>
observations:</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>First</mtext><mo stretchy="false">(</mo><mtext>lhs</mtext><mo stretchy="false">)</mo><mo>⊆</mo><mtext>First</mtext><mo stretchy="false">(</mo><mtext>rhs</mtext><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{First}(\text{lhs})\subseteq\text{First}(\text{rhs})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">First</span></span><span class="mopen">(</span><span class="mord text"><span class="mord">lhs</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">First</span></span><span class="mopen">(</span><span class="mord text"><span class="mord">rhs</span></span><span class="mclose">)</span></span></span></span> if lhs -&gt; rhs</li>
<li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>First</mtext><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>a</mi><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\text{First}(a)=\{a\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">First</span></span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mclose">}</span></span></span></span> if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> is a terminal</li>
</ul>
<pre><code class="language-cpp"><div><span class="hljs-comment">// compute First(A) for all A in N'</span>
first = [{} <span class="hljs-keyword">for</span> A in N']
<span class="hljs-keyword">do</span>:
    <span class="hljs-keyword">for</span> <span class="hljs-string">"A -&gt; B1...Bk"</span> in P:
        <span class="hljs-keyword">for</span> Bi in <span class="hljs-string">"B1...Bk"</span>:
            <span class="hljs-keyword">if</span> Bi in T':
                first[A] ∪= {Bi}
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">else</span>: <span class="hljs-comment">// non terminal</span>
                first[A] ∪= first[Bi]
            <span class="hljs-comment">// only look at Bi+1 if current Bi is nullable, otherwise</span>
            <span class="hljs-comment">// next symbol does not contribute to first(A)</span>
            <span class="hljs-keyword">if</span> !nullable[Bi]:
                <span class="hljs-keyword">break</span>
<span class="hljs-keyword">while</span> first changed
</div></code></pre>
<p>we can also only compute first for one B1..., instead of lhs of a production rule</p>
<pre><code class="language-cpp"><div>first(B1...Bk):
<span class="hljs-comment">// first(β) where β = B1...Bk in V*</span>
    result = {}
    <span class="hljs-keyword">for</span> Bi in <span class="hljs-string">"B1...Bk"</span>:
        <span class="hljs-keyword">if</span> Bi in T':
            result ∪= {Bi}
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">else</span>:
            result ∪= first[Bi]
            <span class="hljs-keyword">if</span> !nullable[Bi]: <span class="hljs-keyword">break</span>
    <span class="hljs-keyword">return</span> result
</div></code></pre>
<p><strong>computing follow</strong></p>
<pre><code class="language-cpp"><div><span class="hljs-comment">// Follow(A) for all A in N (N' - {S'})</span>
follow = [{} <span class="hljs-keyword">for</span> A in N]
<span class="hljs-keyword">do</span>:
    <span class="hljs-keyword">for</span> <span class="hljs-string">"A -&gt; B1...Bk"</span> in P:
        <span class="hljs-keyword">for</span> Bi in <span class="hljs-string">"B1...Bk"</span>:
            <span class="hljs-keyword">if</span> Bi in N:
                follow[Bi] ∪= first(Bi+<span class="hljs-number">1.</span>..Bk) <span class="hljs-comment">// second ver</span>
                <span class="hljs-keyword">if</span> (nullable[Bi+<span class="hljs-number">1</span>] == ... == nullable[Bk] == <span class="hljs-literal">true</span>)
                    <span class="hljs-keyword">or</span> i == k:
                    follow[Bi] ∪= follow[A]
<span class="hljs-keyword">while</span> follow changed
</div></code></pre>
<p><strong>computing predict table</strong></p>
<pre><code class="language-cpp"><div>predict = [[{} <span class="hljs-keyword">for</span> all a in T'] <span class="hljs-keyword">for</span> all A in N']
<span class="hljs-keyword">for</span> <span class="hljs-string">"A -&gt; β"</span> in P:
    <span class="hljs-keyword">for</span> a in first(β): <span class="hljs-comment">// second ver</span>
        predict[A][a] ∪= <span class="hljs-string">"A -&gt; β"</span>
    <span class="hljs-keyword">if</span> nullable(β):
        <span class="hljs-keyword">for</span> a in follow[A]:
            predict[A][a] ∪= <span class="hljs-string">"A -&gt; β"</span>
</div></code></pre>
<p><strong>eg.</strong></p>
<pre><code><code><div>1. S' -&gt; ⊢ S ⊣         summary                             predict
2. S  -&gt; b S d             Nullable   First   Follow          ⊢ ⊣ b d p q l
3. S  -&gt; p S q          S'  false       ⊢                  S' 1
4. S  -&gt; C              S   true      b,p,l   ⊣,d,q        S    4 2 4 3 4 4
5. C  -&gt; l C            C   true        l     ⊣,d,q        C    6   6   6 5
6. C  -&gt; ε
</div></code></code></pre>
<p>note this grammar is LL(1) since each entry in predict table has at most 1 rule.</p>
<h3 id="limitations-of-ll1-parsing">limitations of LL(1) parsing</h3>
<p><strong>theorem.</strong> a grammar is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LL(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> iff:</p>
<ul>
<li>no two distinct rules with the same LHS can generate the same first terminal</li>
<li>no nullable symbol <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span> has the same terminal <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> in both its first and follow sets</li>
<li>there is only one way to derive <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span> from a nullable symbol</li>
</ul>
<p><strong>theorem.</strong> a grammar is never <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LL(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> if two or more rules for the same non-terminal with a common left prefix of length <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>.</p>
<p><strong>theorem.</strong> a grammar is never <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>L</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LL(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault">L</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span> if it is left recursive.</p>
<p><strong>eg.</strong> consider this (left recursive) grammar</p>
<pre><code><code><div>    1. S -&gt; S + T
    2. S -&gt; T
    3. T -&gt; T * F
    4. T -&gt; F
5.6.7. F -&gt; a | b | c
</div></code></code></pre>
<p>it is not LL(1) since rules 1, 2, with same lhs can generate the same terminal. can show <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>T</mi><mo>∈</mo><mtext>predict</mtext><mo stretchy="false">[</mo><mi>S</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">S\rightarrow T\in\text{predict}[S][a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">predict</span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span> since <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo stretchy="false">}</mo><mo>⊆</mo><mtext>First</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>⊆</mo><mtext>First</mtext><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\{a\} \subseteq\text{First}(F)\subseteq\text{First}(T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">First</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">First</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span>, and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>→</mo><mi>S</mi><mo>+</mo><mi>T</mi><mo>∈</mo><mtext>predict</mtext><mo stretchy="false">[</mo><mi>S</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>a</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">S\rightarrow S+T\in\text{predict}[S][a]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">predict</span></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">a</span><span class="mclose">]</span></span></span></span> since <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mi>a</mi><mo stretchy="false">}</mo><mo>⊆</mo><mtext>First</mtext><mo stretchy="false">(</mo><mi>F</mi><mo stretchy="false">)</mo><mo>⊆</mo><mtext>First</mtext><mo stretchy="false">(</mo><mi>T</mi><mo stretchy="false">)</mo><mo>⊆</mo><mtext>First</mtext><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>⊆</mo><mo stretchy="false">(</mo><mi>S</mi><mo>+</mo><mi>T</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\{a\}\subseteq\text{First}(F)\subseteq\text{First}(T)\subseteq\text{First}(S)\subseteq(S+T)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">a</span><span class="mclose">}</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">First</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">F</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">First</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">First</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊆</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mclose">)</span></span></span></span>.</p>
<p>solution 1: we can convert it to right recursive, then apply <em>left factoring</em>: suppose <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>α</mi><msub><mi>β</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">∣</mi><mi>α</mi><msub><mi>β</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">A\rightarrow\alpha\beta_1|...|\alpha\beta_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> all with common prefix <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo mathvariant="normal">≠</mo><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\alpha\neq\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>, we can change it to:<br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>α</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">A\rightarrow \alpha B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><msub><mi>β</mi><mn>1</mn></msub><mi mathvariant="normal">∣</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">∣</mi><msub><mi>β</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">B\rightarrow\beta_1|...|\beta_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord">∣</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<pre><code><code><div>left recursive            right recursive           factored
    1. S -&gt; S + T             1. S -&gt; T + S             1. S -&gt; T X
    2. S -&gt; T                 2. S -&gt; T               2.3. X -&gt; + S | ε
    3. T -&gt; T * F             3. T -&gt; F * T             4. T -&gt; F Y
    4. T -&gt; F                 4. T -&gt; F               5.6. Y -&gt; * T | ε
5.6.7. F -&gt; a|b|c         5.6.7. F -&gt; a|b|c         7.8.9. F -&gt; a|b|c
</div></code></code></pre>
<p>solution 2:
use this transformation when converting from left recursive to right:<br>
replace <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><mi>α</mi></mrow><annotation encoding="application/x-tex">A\rightarrow A\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>β</mi><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">A\rightarrow\beta A&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.946332em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span><br>
replace <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">A\rightarrow\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span> with <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mo>→</mo><mi>α</mi><msup><mi>A</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi mathvariant="normal">∣</mi><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">A&#x27;\rightarrow\alpha A&#x27;|\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord">∣</span><span class="mord mathdefault">ϵ</span></span></span></span><br>
where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span> does not begin with the non-terminal <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>.</p>
<pre><code><code><div>left recursive            right recursive
    1. S -&gt; S + T             1. S -&gt; T S'
    2. S -&gt; T               2.3. S'-&gt; + T S' | ε
    3. T -&gt; T * F             4. T -&gt; F T'
    4. T -&gt; F               5.6. T'-&gt; * F T' | ε
5.6.7. F -&gt; a|b|c         7.8.9. F -&gt; a|b|c
</div></code></code></pre>
<p>but the parse tree is also changed.</p>
<h1 id="week-9-july-6">Week 9. July 6</h1>
<h2 id="bottom-up-parsing">bottom-up parsing</h2>
<h3 id="lr0">LR(0)</h3>
<blockquote>
<p>begin reading input symbols one character at a time left to right. If we recognize the RHS of a rule, replace it with its LHS</p>
</blockquote>
<ul>
<li><em>shift</em> of stack: consumes the next input symbol and push it to the stack</li>
<li><em>reduce</em> of stack: pops the RHS of a rule off the stack and pushes its LHS. (if RHS is ε, equivalent to pushing its LHS)</li>
</ul>
<p><strong>eg.</strong></p>
<pre><code><code><div>1. S' -&gt; ⊢ S ⊣
2. S  -&gt; AyB
3. A  -&gt; ab
4. A  -&gt; cd
5. B  -&gt; z
6. B  -&gt; wx
</div></code></code></pre>
<p>input is <code>abywx</code>:</p>
<table>
<thead>
<tr>
<th style="text-align:left">read</th>
<th style="text-align:left">unread</th>
<th style="text-align:left">stack</th>
<th style="text-align:left"></th>
<th style="text-align:left">derivations (stack+unread)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ε</td>
<td style="text-align:left">⊢ a b y w x ⊣</td>
<td style="text-align:left"></td>
<td style="text-align:left">shift ⊢</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊢</td>
<td style="text-align:left">a b y w x ⊣</td>
<td style="text-align:left">⊢</td>
<td style="text-align:left">shift a</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊢ a</td>
<td style="text-align:left">b y w x ⊣</td>
<td style="text-align:left">⊢ a</td>
<td style="text-align:left">shift b</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊢ a b</td>
<td style="text-align:left">y w x ⊣</td>
<td style="text-align:left">⊢ a b</td>
<td style="text-align:left">reduce rule 3: pop b,a; push A</td>
<td style="text-align:left">⊢ a b y w x ⊣</td>
</tr>
<tr>
<td style="text-align:left">⊢ a b</td>
<td style="text-align:left">y w x ⊣</td>
<td style="text-align:left">⊢ A</td>
<td style="text-align:left">shift y</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊢ a b y</td>
<td style="text-align:left">w x ⊣</td>
<td style="text-align:left">⊢ A y</td>
<td style="text-align:left">shift w</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊢ a b y w</td>
<td style="text-align:left">x ⊣</td>
<td style="text-align:left">⊢ A y w</td>
<td style="text-align:left">shift x</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊢ a b y w x</td>
<td style="text-align:left">⊣</td>
<td style="text-align:left">⊢ A y w x</td>
<td style="text-align:left">reduce rule 6: pop x,w; push B</td>
<td style="text-align:left">⊢ A y w x ⊣</td>
</tr>
<tr>
<td style="text-align:left">⊢ a b y w x</td>
<td style="text-align:left">⊣</td>
<td style="text-align:left">⊢ A y B</td>
<td style="text-align:left">reduce rule 2: pop B,y; push S</td>
<td style="text-align:left">⊢ A y B ⊣</td>
</tr>
<tr>
<td style="text-align:left">⊢ a b y w x</td>
<td style="text-align:left">⊣</td>
<td style="text-align:left">⊢ S</td>
<td style="text-align:left">shift ⊣</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">⊢ a b y w x ⊣</td>
<td style="text-align:left">ε</td>
<td style="text-align:left">⊢ S ⊣</td>
<td style="text-align:left">reduce rule 1: pop ⊣,S,⊢; push S'</td>
<td style="text-align:left">⊢ S ⊣</td>
</tr>
<tr>
<td style="text-align:left">⊢ a b y w x ⊣</td>
<td style="text-align:left">ε</td>
<td style="text-align:left">S'</td>
<td style="text-align:left">accept</td>
<td style="text-align:left">S'</td>
</tr>
</tbody>
</table>
<p>this produces a reversed, rightmost derivation. the rules are 1, 6, 2, 3.</p>
<p><strong>defn.</strong> an <em>item</em> is a production with a bookmark <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∙</mo></mrow><annotation encoding="application/x-tex">\bullet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord">∙</span></span></span></span> somewhere on the RHS of the rule.</p>
<ul>
<li>it keep tracks of how much of the rhs of a rule is on the stack</li>
</ul>
<p><strong>eg.</strong> consider</p>
<pre><code><code><div>1. S' -&gt; ⊢ E ⊣
2. E  -&gt; E + T
3. E  -&gt; T
4. T  -&gt; ID
</div></code></code></pre>
<p>then <code>E -&gt; ●E + T</code> is <em>fresh</em> item indicating none of the rhs is on the stack. if the algorithm pushes an E on the stack, we have <code>E -&gt; E ●+ T</code>. finally <code>E -&gt; E + T ●</code> means all items on rhs are on the stack thus <em>reducible</em>.</p>
<p><img src="assets/w9_1.PNG" alt="img"></p>
<p>to track all rules at the same time, we can use ε-NFA to glue these automations for each rule together.</p>
<blockquote>
<p>The following steps can be used as a shortcut to produce the DFA directly:</p>
<ol>
<li>Create a start state with a fresh item for the single rule for the start symbol</li>
<li>Select a state qi that has at least one non-reducible item. For each non-reducible item in qi, create a transition to a new state qj on the symbol X that follows the bookmark. Take all items from qi where the bookmark is followed by an X, update the bookmark to be right after X and add them as items in qj.</li>
</ol>
<blockquote>
<p>• For each item in the newly created states, if the symbol following the updated bookmark is a non-terminal, say A, add fresh items for all rules for non-terminal A to the new state. If this creates fresh items where a bookmark is followed by a non-terminal, say B, add fresh items for all rules of B. Repeat if necessary.</p>
</blockquote>
<ol start="3">
<li>Repeat step 2 until no new states are discovered.</li>
<li>Mark states containing reducible items as accept states.</li>
</ol>
</blockquote>
<p>the LR(0) parsing DFA for this grammar is<br>
<img src="assets/w9_2.PNG" alt="img"></p>
<p><strong>defn.</strong> LR(0) means Left to right, Rightmost derivations, not looking ahead symbols.</p>
<p><strong>defn.</strong> given a grammar <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><mo stretchy="false">(</mo><mi>N</mi><mo separator="true">,</mo><mi>T</mi><mo separator="true">,</mo><mi>P</mi><mo separator="true">,</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">G=(N,T,P,S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>, <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span> is a <em>sentential form</em> if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>γ</mi></mrow><annotation encoding="application/x-tex">S\Rightarrow^*\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span>. we say <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span> is a <em>viable prefix</em> if it is the prefix of a sentential form, ie <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><msup><mo>⇒</mo><mo>∗</mo></msup><mi>α</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">S\Rightarrow^*\alpha y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel">⇒</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span> for some <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span></span></span></span>.</p>
<p><strong>defn.</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Reduce</mtext><mo stretchy="false">(</mo><mi>α</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi>A</mi><mo>→</mo><mi>γ</mi><mtext> </mtext><mtext> </mtext><mo>∙</mo><mo>:</mo><mi>α</mi><mo>=</mo><mi>β</mi><mi>γ</mi><mtext> and </mtext><mi>β</mi><mi>A</mi><mtext> is a viable prefix</mtext><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\texttt{Reduce}(\alpha)=\{A\rightarrow\gamma\,\,\bullet:\alpha=\beta\gamma\text{ and }\beta A\text{ is a viable prefix}\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord texttt">Reduce</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∙</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mord text"><span class="mord"> and </span></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mord mathdefault">A</span><span class="mord text"><span class="mord"> is a viable prefix</span></span><span class="mclose">}</span></span></span></span></p>
<p>below is LR(0) parsing algorithm</p>
<pre><code class="language-cpp"><div><span class="hljs-comment">// whenever we read a symbol, push it to symbol_stack</span>
<span class="hljs-comment">// whenever we complete a transition, push the state to state_stack</span>
<span class="hljs-comment">// when we arrive at an accepting state (reducible), we have to go back k states</span>
<span class="hljs-comment">// where k is # of symbols</span>
lr_0_parse(input, dfa{Σ,Q,q0,δ,A}):
    <span class="hljs-keyword">auto</span> state_stack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">stack</span>,
         symbol_stack = <span class="hljs-keyword">new</span> <span class="hljs-built_in">stack</span>

    state_stack.push(q0)
    <span class="hljs-keyword">for</span> a in <span class="hljs-string">"⊢ input ⊣"</span>:
        <span class="hljs-comment">// for LR(1), SLR(1), LALR(1) this line is</span>
     <span class="hljs-comment">// while reduce[state_stack.top(), a]  is "B -&gt; γ":</span>
        <span class="hljs-keyword">while</span> reduce[state_stack.top()] is <span class="hljs-string">"B -&gt; γ"</span>:
            symbol_stack.pop symbols in γ
            state_stack.pop |γ| states
            <span class="hljs-comment">// state go to B</span>
            symbol_stack.push(B)
            state_stack.push(δ(state_stack.top(), B))
        <span class="hljs-comment">// cannot reduce, try shift</span>
        symbol_stack.push(a)
        <span class="hljs-keyword">if</span> δ(state_stack.top(), a) is error: reject(input)
        state_stack.push(δ(state_stack.top(), a))

    accept(input)
</div></code></pre>
<p>where reduce[state] is a function that given a state, tells us whether this is a reduce state and gives that rule.<br>
<code>symbol_stack</code> can be a tree stack: for terminal, we push leaf nodes, for non-terminals, we pop leaf nodes, connect it to a non-terminal node, then push the non-terminal node back to stack. eventually we will have a parse tree.</p>
<p><strong>eg.</strong> input is <code>⊢ ID + ID ⊣</code></p>
<table>
<thead>
<tr>
<th style="text-align:left">read</th>
<th style="text-align:left">unread</th>
<th style="text-align:left">symbol stack</th>
<th style="text-align:left">state stack</th>
<th style="text-align:left"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ε</td>
<td style="text-align:left">⊢ ID + ID ⊣</td>
<td style="text-align:left"></td>
<td style="text-align:left">1</td>
<td style="text-align:left">state 1 is shift state. shift ⊢</td>
</tr>
<tr>
<td style="text-align:left">⊢</td>
<td style="text-align:left">ID + ID ⊣</td>
<td style="text-align:left">⊢</td>
<td style="text-align:left">1 2</td>
<td style="text-align:left">state 2 is shift state. shift ID</td>
</tr>
<tr>
<td style="text-align:left">⊢ ID</td>
<td style="text-align:left">+ ID ⊣</td>
<td style="text-align:left">⊢ ID</td>
<td style="text-align:left">1 2 6</td>
<td style="text-align:left">state 6 is reduce state. reduce rule 4</td>
</tr>
<tr>
<td style="text-align:left">⊢ ID</td>
<td style="text-align:left">+ ID ⊣</td>
<td style="text-align:left">⊢ T</td>
<td style="text-align:left">1 2 5</td>
<td style="text-align:left">state 5 is reduce state. reduce rule 3</td>
</tr>
<tr>
<td style="text-align:left">⊢ ID</td>
<td style="text-align:left">+ ID ⊣</td>
<td style="text-align:left">⊢ E</td>
<td style="text-align:left">1 2 3</td>
<td style="text-align:left">state 3 is shift state. shift +</td>
</tr>
<tr>
<td style="text-align:left">⊢ ID +</td>
<td style="text-align:left">ID ⊣</td>
<td style="text-align:left">⊢ E +</td>
<td style="text-align:left">1 2 3 7</td>
<td style="text-align:left">state 7 is shift state. shift ID</td>
</tr>
<tr>
<td style="text-align:left">⊢ ID + ID</td>
<td style="text-align:left">⊣</td>
<td style="text-align:left">⊢ E + ID</td>
<td style="text-align:left">1 2 3 7 6</td>
<td style="text-align:left">state 6 is reduce state. reduce rule 4</td>
</tr>
<tr>
<td style="text-align:left">⊢ ID + ID</td>
<td style="text-align:left">⊣</td>
<td style="text-align:left">⊢ E + T</td>
<td style="text-align:left">1 2 3 7 8</td>
<td style="text-align:left">state 8 is reduce state. reduce rule 2</td>
</tr>
<tr>
<td style="text-align:left">⊢ ID + ID</td>
<td style="text-align:left">⊣</td>
<td style="text-align:left">⊢ E</td>
<td style="text-align:left">1 2 3</td>
<td style="text-align:left">state 3 is shift state. shift ⊣</td>
</tr>
<tr>
<td style="text-align:left">⊢ ID + ID ⊣</td>
<td style="text-align:left">ε</td>
<td style="text-align:left">⊢ E ⊣</td>
<td style="text-align:left">1 2 3 4</td>
<td style="text-align:left">state 4 is reduce state. reduce rule 1</td>
</tr>
<tr>
<td style="text-align:left">⊢ ID + ID ⊣</td>
<td style="text-align:left">ε</td>
<td style="text-align:left">S'</td>
<td style="text-align:left"></td>
<td style="text-align:left">accept as soon as pushing S'</td>
</tr>
</tbody>
</table>
<p>there is error if no transition on given symbol exists.</p>
<h3 id="limitations-of-lr0-parsing">limitations of LR(0) parsing</h3>
<p><strong>defn.</strong> a <em>shift-reduce conflict</em> occurs when a state in the parsing DFA has two items if the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>α</mi><mo>∙</mo><mi>a</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">A\rightarrow\alpha\bullet a\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∙</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>γ</mi><mtext> </mtext><mo>∙</mo></mrow><annotation encoding="application/x-tex">B\rightarrow\gamma\, \bullet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.63889em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∙</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo>∈</mo><msup><mi>T</mi><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow><annotation encoding="application/x-tex">a\in T&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo separator="true">,</mo><mi>γ</mi><mo>∈</mo><msup><mi>V</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\alpha,\beta,\gamma\in V^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><strong>defn.</strong> a <em>reduce-reduce conflict</em> occurs when a state in the parsing DFA has two items of the form <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>→</mo><mi>α</mi><mtext> </mtext><mo>∙</mo></mrow><annotation encoding="application/x-tex">A\rightarrow\alpha\,\bullet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.44445em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∙</span></span></span></span> and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>→</mo><mi>β</mi><mtext> </mtext><mo>∙</mo></mrow><annotation encoding="application/x-tex">B\rightarrow\beta\,\bullet</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∙</span></span></span></span> where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi><mo separator="true">,</mo><mi>β</mi><mo>∈</mo><msup><mi>V</mi><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">\alpha,\beta\in V^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>.</p>
<p><strong>defn.</strong> a grammar is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>R</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LR(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> iff the <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mi>R</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">LR(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">L</span><span class="mord mathdefault" style="margin-right:0.00773em;">R</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span> automaton does not have any shift-reduce or reduce-reduce conflicts.</p>
<p><strong>eg.</strong><br>
<img src="assets/w9_3.PNG" alt="img"><br>
in state 5, we have two choices: accept E -&gt; T or waiting for another +. we cannot make decision since we cannot look ahead 1 symbol. this is a shift-reduce conflict. so this grammar is not LR(0).</p>
<h3 id="slr1">SLR(1)</h3>
<p>means simplied LR(1).</p>
<p>we extend the definition of <em>items</em>: for each reducible item, add the follow set for the LHS non-terminal to the item. we thus extend the definition of LR(0) DFA by using one lookahead.</p>
<p><strong>defn.</strong> for SLR(1), <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Reduce</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>α</mi><mo separator="true">,</mo><mi mathvariant="normal">a</mi><mo stretchy="false">)</mo><mo>=</mo><mo stretchy="false">{</mo><mi mathvariant="normal">A</mi><mo>→</mo><mi>γ</mi><mo>:</mo><mi>α</mi><mo>=</mo><mi>β</mi><mi>γ</mi><mtext> and </mtext><mi>β</mi><mi>A</mi><mtext> is a viable prefix and </mtext><mi mathvariant="normal">a</mi><mo>∈</mo><mtext> Follow </mtext><mo stretchy="false">(</mo><mi mathvariant="normal">A</mi><mo stretchy="false">)</mo><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\operatorname{Reduce}(\alpha, \mathrm{a})=\{\mathrm{A} \rightarrow \gamma: \alpha=\beta \gamma \text { and } \beta A \text { is a viable prefix and } \mathrm{a} \in \text { Follow }(\mathrm{A})\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop"><span class="mord mathrm">R</span><span class="mord mathrm">e</span><span class="mord mathrm">d</span><span class="mord mathrm">u</span><span class="mord mathrm">c</span><span class="mord mathrm">e</span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathrm">a</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord"><span class="mord mathrm">A</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mord text"><span class="mord"> and </span></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mord mathdefault">A</span><span class="mord text"><span class="mord"> is a viable prefix and </span></span><span class="mord"><span class="mord mathrm">a</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord"> Follow </span></span><span class="mopen">(</span><span class="mord"><span class="mord mathrm">A</span></span><span class="mclose">)</span><span class="mclose">}</span></span></span></span>, where <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi></mrow><annotation encoding="application/x-tex">a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span> is the next symbol.</p>
<ul>
<li>this is not right. a in Follow set does not mean viable prefix.</li>
</ul>
<p><strong>eg.</strong> for previous not LR(0) grammer,<br>
<img src="assets/w9_4.PNG" alt="img"></p>
<blockquote>
<p>at State 5. with SLR(1), we added the Follow set for E to the reducible item. The SLR(1) algorithm will reduce using the reducible item only if the next input symbol is in the Follow set of this reducible item. if the next input symbol is ⊣, we will reduce using the rule E -&gt; T. However, if the next input symbol is not ⊣, we will shift the next input symbol (of course if the next input symbol happens to be something other than +, this would generate a parse error).</p>
</blockquote>
<h3 id="limitation-of-slr1">limitation of SLR(1)</h3>
<p><strong>eg.</strong><br>
<img src="assets/w9_5.PNG" alt="img"></p>
<p>if input is <code>⊢ ID ⊣</code>, when in State 5, ⊣ is in both follow sets of the two rules. we do not know what to choose from. ie it is not SLR(1) because the intersection of two follow sets is not empty.</p>
<blockquote>
<p>the LR(1) DFA is created by only adding the lookahead that should be present for a particular rule to be used in the reduce step, ie only adding a subset of the Follow set to each reducible item. for this eg, we should only reduce using the rule S -&gt; ID if the next input symbol is a. similarly, we should only reduce using the rule E -&gt; ID, if the next input symbol is =.</p>
</blockquote>
<p><img src="assets/w9_6.PNG" alt="img"></p>
<h1 id="week-10-july-13">Week 10. July 13</h1>
<h2 id="context-sensitive-analysis">context sensitive analysis</h2>
<h3 id="wlp4">WLP4</h3>
<p><a href="https://www.student.cs.uwaterloo.ca/~cs241/wlp4/WLP4tutorial.html">guide</a><br>
<a href="https://www.student.cs.uwaterloo.ca/~cs241/wlp4/WLP4.html">WLP4 language specification</a></p>
<p>sample parse tree:</p>
<pre><code class="language-cpp"><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span>:</span>
    <span class="hljs-built_in">string</span> rule             <span class="hljs-comment">// eg expr expr PLUS term</span>
    <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">string</span>&gt; tokens   <span class="hljs-comment">// from scanner</span>
    <span class="hljs-built_in">vector</span>&lt;Tree&gt; children
</div></code></pre>
<blockquote>
<p>the parse tree created by a parser is often called a <em>Concrete Syntax Tree</em>. often, this parse tree is passed through a tree transformation stage before applying Context Sensitive Analyses. during this stage, the tree is pruned by removing useless nodes such as those needed to ensure that the grammar is unambiguous and to satisfy the requirements of a speciﬁc parsing algorithm. This transformed tree is often called an <em>Abstract Syntax Tree</em>.</p>
</blockquote>
<h3 id="identifiers">identifiers</h3>
<p>rules for surrounding variables</p>
<ul>
<li>cannot declare more than one variable with same name in same scope
<ul>
<li>can have same identifier name across difference scopes</li>
<li><code>symbol_table = map&lt;procedure_name, map&lt;variable_name, type&gt;&gt;</code></li>
</ul>
</li>
<li>a variable cannot be used before declared</li>
</ul>
<pre><code><code><div>procedure -&gt; INT ID LPAREN params RPAREN
             LBRACE dcls statements RETURN expr SEMI RBRACE
     wain -&gt; INT WAIN LPAREN dcl COMMA dcl RPAREN
             LBRACE dcls statements RETURN expr SEMI RBRACE
</div></code></code></pre>
<p>since declarations only appear at top of the procedure, just traverse once until <code>statements</code> is encountered to get all symbols. when using symbols, traverse through <code>statements</code> and find rules <code>factor -&gt; ID</code> and <code>lvalue -&gt; ID</code>.</p>
<p><strong>eg.</strong></p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">int</span> f = <span class="hljs-number">1</span>; <span class="hljs-keyword">return</span> f + <span class="hljs-number">1</span>; } <span class="hljs-comment">// valid, local f shadows the function name.</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>{ <span class="hljs-keyword">return</span> p(p); }        <span class="hljs-comment">// not valid, p is of type int</span>
</div></code></pre>
<h3 id="call-procedures">call procedures</h3>
<p>rules of interest are <code>factor -&gt; ID LPAREN RPAREN</code> and <code>factor -&gt; ID LPAREN arglist RPAREN</code> when calling procedures. before that have to check signatures, and finding the signature of a procedure when creating symbol tables</p>
<ul>
<li><code>signature = vector&lt;type&gt;</code></li>
<li><code>symbol_table = map&lt;procedure_name, tuple&lt;signature, map&lt;variable_name, type&gt;&gt;&gt;</code></li>
</ul>
<p><strong>eg.</strong></p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">int</span> *a = <span class="hljs-literal">NULL</span>; <span class="hljs-keyword">return</span> <span class="hljs-number">9</span>; }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{ <span class="hljs-keyword">int</span> x = <span class="hljs-number">10</span>; <span class="hljs-keyword">return</span> x+a+b; }
</div></code></pre>
<p>symbol table:</p>
<pre><code class="language-js"><div>{
    <span class="hljs-attr">f</span>: {
        <span class="hljs-attr">signature</span>: [],
        <span class="hljs-attr">variables</span>: { <span class="hljs-attr">a</span>: <span class="hljs-string">"int*"</span> }
    },
    <span class="hljs-attr">wain</span>: {
        <span class="hljs-attr">signature</span>: [ <span class="hljs-string">"int"</span>, <span class="hljs-string">"int"</span> ],
        <span class="hljs-attr">variables</span>: { <span class="hljs-attr">a</span>: <span class="hljs-string">"int"</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">"int"</span>, <span class="hljs-attr">x</span>: <span class="hljs-string">"int"</span> }
    }
}
</div></code></pre>
<h3 id="type-checking">type checking</h3>
<p>a sample statement <code>a = x + 3</code> tree looks like<br>
<img src="assets/w10_1.PNG" alt="img"></p>
<p>first get the type of ID by traversing first subtree. for rhs, traverse third subtree to get type. error if two are different.</p>
<p>for <code>expr -&gt; term</code>, we have <code>type(expr) = type(term)</code>.<br>
for <code>factor -&gt; LPAREN expr RPAREN</code>, we have <code>type(factor) = type(expr)</code>.</p>
<p><strong>eg.</strong> a program tree</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> len)</span> </span>{
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (i &lt; len) {
        ret = ret + *(arr + i);
        i = i + <span class="hljs-number">1</span>;
    }
    <span class="hljs-keyword">return</span> ret;
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *arr, <span class="hljs-keyword">int</span> len)</span> </span>{
    <span class="hljs-keyword">return</span> sum(arr, len) + len;
}
</div></code></pre>
<p><img src="assets/w10_2.PNG" alt="img"></p>
<p>type inference rules for expressions:</p>
<ul>
<li>NUMs have type <code>int</code></li>
<li>NULL has type <code>int*</code></li>
<li>adding parentheses does not change type</li>
<li>taking address of <code>int</code> produces <code>int*</code></li>
<li>dereferencing <code>int*</code> produces <code>int</code></li>
<li><code>new int[E]</code> takes an <code>int</code> value E and produces an <code>int*</code></li>
<li>multiplication, division, modulo, addition, subtraction of two <code>int</code>s produces <code>int</code></li>
<li>addition of <code>int*</code> and <code>int</code> and vice versa produces <code>int*</code></li>
<li>subtraction of <code>int*</code> and <code>int*</code> produces <code>int</code></li>
<li>subtraction of an <code>int</code> from an <code>int*</code> produces a pointer</li>
<li>a procedure call checks argument types to match and produces that type</li>
<li>absense of a rule means error</li>
</ul>
<p><strong>defn.</strong> we say a statement is <em>well-typed</em> if its components are well-typed.</p>
<p>type checking for statements:</p>
<ul>
<li>an expression is well-typed if a type can be inferred</li>
<li><code>println(E)</code> statement is well-typed iff E is of type <code>int</code></li>
<li><code>delete[] E</code> is well-typed iff E is of type <code>int*</code></li>
<li><code>E1 = E2</code> (assignment) is well-typed iff types of lhs and rhs are same
<ul>
<li>lhs must be lvalue, which is enforced by context free language</li>
</ul>
</li>
<li>an empty sequence of statements is well-typed</li>
<li>a sequence of statements is well-typed iff each statement is well-typed</li>
<li><code>E1 &lt; E2</code>, <code>E1 &lt;= E2</code>, <code>E1 &gt; E2</code>, <code>E1 &gt;= E2</code>, <code>E1 == E2</code>, <code>E1 != E2</code> is well-typed iff E1 and E2 have same type</li>
<li>an <code>if</code> statement is well-typed iff test condition, branch1, branch2 are well-typed</li>
<li>a <code>while</code> statement is well-typed iff test condition, statements are well-typed</li>
<li>an empty sequence of declarations is well-typed</li>
<li>a variable declared as an <code>int</code> is well-typed if it is initialized with an int value</li>
<li>a variable declared as an <code>int*</code> is well-typed if it is initialized with a <code>NULL</code> value</li>
<li>a procedure is well-typed if the declarations and statements are well-typed and it returns an <code>int</code></li>
<li>pricedure <code>wain</code> is well-typed if the second parameter is <code>int</code>, and satisfies above condition</li>
</ul>
<p>the program is syntactically and semantically valid if it passes all tests so far.</p>
<h2 id="code-generation">code generation</h2>
<h3 id="variables">variables</h3>
<p><strong>eg.</strong></p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{ <span class="hljs-comment">// $1, $2</span>
    <span class="hljs-keyword">int</span> c = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> c; <span class="hljs-comment">// $3</span>
}
</div></code></pre>
<p>symbol table:</p>
<pre><code><code><div>  stack                 symbol table
+--------+
|        |
|        |             sym   type   offset($29)
+--------+ &lt;-$30      +------------------+
|   c    |            | a    int      0  |
+--------+            +------------------+
|   b    |            | b    int     -4  |
+--------+ &lt;-$29      +------------------+
|   a    |            | c    int     -8  |
+--------+            +------------------+
</div></code></code></pre>
<p>generated code:</p>
<pre><code class="language-sh"><div><span class="hljs-comment"># prologue</span>
lis <span class="hljs-variable">$4</span>              <span class="hljs-comment"># convention, always store 4</span>
.word 4
sub <span class="hljs-variable">$29</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>    <span class="hljs-comment"># setup frame pointer</span>
sw <span class="hljs-variable">$1</span>, 0(<span class="hljs-variable">$29</span>)       <span class="hljs-comment"># push a</span>
sub <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>    <span class="hljs-comment"># update stack pointer</span>
sw <span class="hljs-variable">$2</span>, -4(<span class="hljs-variable">$29</span>)      <span class="hljs-comment"># push b</span>
sub <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>    <span class="hljs-comment">#</span>
sw <span class="hljs-variable">$0</span>, -8(<span class="hljs-variable">$29</span>)      <span class="hljs-comment"># push c</span>
sub <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>    <span class="hljs-comment">#</span>

lw <span class="hljs-variable">$3</span>, -8(<span class="hljs-variable">$29</span>)       <span class="hljs-comment"># load c</span>

<span class="hljs-comment"># epilogue</span>
add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>
add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>
add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>
jr <span class="hljs-variable">$31</span>
</div></code></pre>
<p><strong>convention.</strong></p>
<pre><code class="language-sh"><div>code(expr)
is the generated code that evaluates expr and stores result <span class="hljs-keyword">in</span> <span class="hljs-variable">$3</span>

code(a) generates:      <span class="hljs-keyword">if</span> a is variable
lw <span class="hljs-variable">$3</span>, 0(<span class="hljs-variable">$29</span>)           <span class="hljs-built_in">where</span> 0 is offset retrieved from table

push(<span class="hljs-variable">$X</span>) generates:
sw <span class="hljs-variable">$X</span>, -4(<span class="hljs-variable">$30</span>)
sub <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>

pop(<span class="hljs-variable">$X</span>) generates:
add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>
lw <span class="hljs-variable">$X</span>, -4(<span class="hljs-variable">$30</span>)
</div></code></pre>
<h3 id="arithmetic-expressions">arithmetic expressions</h3>
<p><strong>eg.</strong></p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{ <span class="hljs-comment">// $1, $2</span>
    <span class="hljs-keyword">int</span> c = <span class="hljs-number">3</span>;
    <span class="hljs-keyword">return</span> a + (b - c); <span class="hljs-comment">// $3</span>
}
</div></code></pre>
<p>generated code:</p>
<pre><code class="language-sh"><div><span class="hljs-comment"># prologue</span>
lis <span class="hljs-variable">$4</span>
.word 4
sub <span class="hljs-variable">$29</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>
push(<span class="hljs-variable">$1</span>)            <span class="hljs-comment"># use $30 to push, but still use $29 get get values out</span>
push(<span class="hljs-variable">$2</span>)
lis <span class="hljs-variable">$5</span>
.word 3
push(<span class="hljs-variable">$5</span>)

code(a)             <span class="hljs-comment"># load a in $3</span>
push(<span class="hljs-variable">$3</span>)            <span class="hljs-comment"># a to stack top</span>
code(b)             <span class="hljs-comment"># load b in $3</span>
push(<span class="hljs-variable">$3</span>)            <span class="hljs-comment"># b to stack top</span>
code(c)             <span class="hljs-comment"># load c in $3</span>
pop(<span class="hljs-variable">$5</span>)             <span class="hljs-comment"># b to $5</span>
sub <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>      <span class="hljs-comment">#</span>
pop(<span class="hljs-variable">$5</span>)             <span class="hljs-comment"># a to $5</span>
sub <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>      <span class="hljs-comment">#</span>

<span class="hljs-comment"># epilogue</span>
add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>
add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>
add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>
jr <span class="hljs-variable">$31</span>
</div></code></pre>
<p>for addition <code>expr1 -&gt; expr2 PLUS term</code>, we have expansion</p>
<pre><code class="language-sh"><div>when both types are int:
code(expr1) = 
    code(expr2)
    push(<span class="hljs-variable">$3</span>)
    code(term)
    pop(<span class="hljs-variable">$5</span>)             convention: <span class="hljs-variable">$5</span> holds intermediate values
    add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>
</div></code></pre>
<p>same for <code>MINUS</code>, <code>STAR</code>, <code>SLASH</code> and <code>PCT</code>.</p>
<p>for <code>S -&gt; ⊢ procedure ⊣</code>, we have <code>code(S) = code(procedure)</code>.<br>
for <code>expr -&gt; term</code>, we have <code>code(expr) = code(term)</code>.<br>
for <code>factor -&gt; LPAREN expr RPAREN</code>, we have <code>code(factor) = code(expr)</code>.</p>
<h3 id="assignment">assignment</h3>
<p>for assignment statement <code>statement -&gt; lvalue BECOMES expr SEMI</code>, we have</p>
<pre><code class="language-sh"><div>when lvalue -&gt; ID:
code(statement) =
    code(expr)
    sw <span class="hljs-variable">$3</span>, offset(<span class="hljs-variable">$29</span>)      <span class="hljs-built_in">where</span> offset is computed; <span class="hljs-keyword">if</span> it is ID
                            <span class="hljs-keyword">then</span> look up symbol table
</div></code></pre>
<h3 id="println-statement">println statement</h3>
<p>for <code>statement -&gt; PRINTLN LPAREN expr RPAREN SEMI</code>, we have</p>
<pre><code class="language-sh"><div>code(println(expr);) =
    push(<span class="hljs-variable">$1</span>)            <span class="hljs-keyword">if</span> current <span class="hljs-variable">$1</span> has to be preserved
    code(expr)
    add <span class="hljs-variable">$1</span>, <span class="hljs-variable">$3</span>, <span class="hljs-variable">$0</span>      parameter stored <span class="hljs-keyword">in</span> <span class="hljs-variable">$1</span>
    push(<span class="hljs-variable">$31</span>)
    lis <span class="hljs-variable">$5</span>
    .word <span class="hljs-built_in">print</span>         external
    jalr <span class="hljs-variable">$5</span>
    pop(<span class="hljs-variable">$31</span>)
    pop(<span class="hljs-variable">$1</span>)
</div></code></pre>
<p><strong>convention.</strong></p>
<pre><code class="language-sh"><div><span class="hljs-comment"># prologue</span>
.import <span class="hljs-built_in">print</span>       <span class="hljs-comment"># print.merl</span>
.import init        <span class="hljs-comment"># alloc.merl</span>
.import new
.import delete
lis <span class="hljs-variable">$4</span>              <span class="hljs-comment"># 4 always hold 4</span>
.word 4
lis <span class="hljs-variable">$10</span>             <span class="hljs-comment"># 10 always hold println</span>
.word <span class="hljs-built_in">print</span>
lis <span class="hljs-variable">$11</span>             <span class="hljs-comment"># $11 always hold 1</span>
.word 1
sub <span class="hljs-variable">$29</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>

<span class="hljs-comment"># reserve space for variables</span>

<span class="hljs-comment"># WLP4 code</span>

<span class="hljs-comment"># epilogue</span>
<span class="hljs-comment"># deallocate parameters and local variables of wain</span>

jr <span class="hljs-variable">$31</span>
</div></code></pre>
<blockquote>
<p>the only other convention that is not apparent from the snippet above is that while evaluating any arbitrary expression, we use register 5 temporarily hold values.</p>
</blockquote>
<h3 id="comparisons">comparisons</h3>
<p>for <code>test -&gt; expr1 &lt; expr2</code> we have</p>
<pre><code class="language-sh"><div>when both types are int:
code(<span class="hljs-built_in">test</span>) =
    code(expr1)
    push(<span class="hljs-variable">$3</span>)
    code(expr2)
    pop(<span class="hljs-variable">$5</span>)
    slt <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>
</div></code></pre>
<p>for <code>test -&gt; expr1 != expr2</code> we have</p>
<pre><code class="language-sh"><div>when both types are int:
code(<span class="hljs-built_in">test</span>) =
    code(expr1)
    push(<span class="hljs-variable">$3</span>)
    code(expr2)
    pop(<span class="hljs-variable">$5</span>)
    slt <span class="hljs-variable">$6</span>, <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>
    slt <span class="hljs-variable">$7</span>, <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>
    add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$6</span>, <span class="hljs-variable">$7</span>
</div></code></pre>
<p>for <code>test -&gt; expr1 == expr2</code>, append <code>sub $3, $11, $3</code> to above to flip result (also applicable to <code>&gt;=</code>).</p>
<h3 id="control-flow-statements">control flow statements</h3>
<p>for <code>statement -&gt; IF (test) {stmts1} ELSE {stmts2}</code>, we have</p>
<pre><code class="language-sh"><div>code(statement) =
    code(<span class="hljs-built_in">test</span>)
    beq <span class="hljs-variable">$3</span>, <span class="hljs-variable">$0</span>, _else
    code(stmts1)
    beq <span class="hljs-variable">$0</span>, <span class="hljs-variable">$0</span>, _endif
    _else:
    code(stmts2)
    _endif:
</div></code></pre>
<p>for <code>statement -&gt; WHILE (test) {statements}</code>, we have</p>
<pre><code class="language-sh"><div>code(statement) =
    _while:
    code(<span class="hljs-built_in">test</span>)
    beq <span class="hljs-variable">$3</span>, <span class="hljs-variable">$0</span>, _endwhile
    code(statements)
    beq <span class="hljs-variable">$0</span>, <span class="hljs-variable">$0</span>, _while
    _endwhile:
</div></code></pre>
<h1 id="week-11-july-21">Week 11. July 21</h1>
<h3 id="null-value">Null value</h3>
<p>for <code>factor -&gt; NULL</code>, we have</p>
<pre><code class="language-sh"><div>code(factor) = add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$0</span>, <span class="hljs-variable">$11</span>
</div></code></pre>
<p>ie we set <code>NULL</code> to 1. so dereferencing <code>NULL</code> results in unaligned access error.</p>
<h3 id="dereference-pointers">dereference pointers</h3>
<p>for <code>factor1 -&gt; STAR factor2</code>, we have</p>
<pre><code class="language-sh"><div>code(factor1) =
    code(factor2)
    lw <span class="hljs-variable">$3</span>, 0(<span class="hljs-variable">$3</span>)
</div></code></pre>
<p>since the code already passes type checks, we know <code>factor2</code> is an address.</p>
<h3 id="take-address-of">take address-of</h3>
<p>for <code>factor -&gt; AMP lvalue</code>, we have</p>
<pre><code class="language-sh"><div>when lvalue -&gt; ID:
code(factor) =
    lis <span class="hljs-variable">$3</span>
    .word offset        look up symbol table
    add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$3</span>, <span class="hljs-variable">$29</span>

when lvalue -&gt; STAR factor2:
code(factor) =
    code(factor2)
</div></code></pre>
<p>note there is also third case when <code>lvalue1 -&gt; ( lvalue2 )</code>, it degrades to <code>lvalue2</code>.</p>
<h3 id="assignment-via-pointer-dereference">assignment via pointer dereference</h3>
<p>for <code>statement -&gt; lvalue BECOMES expr SEMI</code>, we have</p>
<pre><code class="language-sh"><div>when lvalue -&gt; STAR factor:
code(statement) =
    code(expr)
    push(<span class="hljs-variable">$3</span>)
    code(factor)
    pop(<span class="hljs-variable">$5</span>)
    sw <span class="hljs-variable">$5</span>, 0(<span class="hljs-variable">$3</span>)
</div></code></pre>
<h3 id="comparisons-of-pointer-type">comparisons of pointer type</h3>
<p>same as comparisons of <code>int</code>, but both sides have to be <code>int*</code> (need to look up types). since pointers are unsigned, need to use <code>sltu</code>.</p>
<h3 id="arithmetic-involving-pointer-type">arithmetic involving pointer type</h3>
<p>for <code>expr1 -&gt; expr2 PLUS term</code> when one operant is int and the other is pointer, we have</p>
<pre><code class="language-sh"><div>when expr2 is int*, term is int:
code(expr1) =
    code(expr2)
    push(<span class="hljs-variable">$3</span>)
    code(term)
    mult <span class="hljs-variable">$3</span>, <span class="hljs-variable">$4</span>
    mflo <span class="hljs-variable">$3</span>
    pop(<span class="hljs-variable">$5</span>)
    add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>

when expr2 is int, term is int*:
same, but switch order of code(expr2) and code(term)
</div></code></pre>
<p>for <code>expr1 -&gt; expr2 MINUS term</code>, when <code>expr2</code> is <code>int*</code> and <code>term</code> is <code>int</code>, same as above, but change <code>add</code> to <code>sub</code>.</p>
<p>for <code>expr1 -&gt; expr2 MINUS term</code>, when both operands are <code>int*</code>, we have</p>
<pre><code class="language-sh"><div>when both are int*:
code(expr1) =
    code(expr2)
    push(<span class="hljs-variable">$3</span>)
    code(term)
    pop(<span class="hljs-variable">$5</span>)
    sub <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>
    div <span class="hljs-variable">$3</span>, <span class="hljs-variable">$4</span>
    mflo <span class="hljs-variable">$3</span>
</div></code></pre>
<h3 id="memory-allocation">memory allocation</h3>
<p>the presence of module <code>alloc.merl</code> is assumed; it provides procedures <code>new</code> and <code>delete</code>.</p>
<p>for <code>factor -&gt; NEW INT [expr]</code>, we have</p>
<pre><code class="language-sh"><div>code(factor) =
    code(expr)
    add <span class="hljs-variable">$1</span>, <span class="hljs-variable">$3</span>, <span class="hljs-variable">$0</span>
    push(<span class="hljs-variable">$31</span>)
    lis <span class="hljs-variable">$5</span>
    .word new
    jalr <span class="hljs-variable">$5</span>             call new
    pop(<span class="hljs-variable">$31</span>)
    bne <span class="hljs-variable">$3</span>, <span class="hljs-variable">$0</span>, 1       <span class="hljs-keyword">if</span> success, skip next instr
    add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$11</span>, <span class="hljs-variable">$0</span>     <span class="hljs-keyword">if</span> fails, <span class="hljs-built_in">set</span> <span class="hljs-variable">$3</span> to NULL
</div></code></pre>
<p>for <code>statement -&gt; DELETE [ ] expr ;</code>, we have</p>
<pre><code class="language-sh"><div>code(statement) =
    code(expr)
    beq <span class="hljs-variable">$3</span>, <span class="hljs-variable">$11</span>, _skipdelete
    add <span class="hljs-variable">$1</span>, <span class="hljs-variable">$3</span>, <span class="hljs-variable">$0</span>
    push(<span class="hljs-variable">$31</span>)
    lis <span class="hljs-variable">$5</span>
    .word delete
    jalr <span class="hljs-variable">$5</span>
    pop(<span class="hljs-variable">$31</span>)
    _skipdelete:
</div></code></pre>
<p>note: <code>init</code> must be called before any <code>new</code> is called.</p>
<h3 id="assemble-and-link-output">assemble and link output</h3>
<pre><code class="language-sh"><div>cs241.linkasm &lt; output.asm &gt; output.merl
cs241.linker output.merl print.merl alloc.merl &gt; exec.merl
cs241.merl 0 &lt; exec.merl &gt; exec.mips

mips.{twoints,array} exec.mips
</div></code></pre>
<h3 id="procedures-1">procedures</h3>
<p>the layout:</p>
<pre><code class="language-sh"><div><span class="hljs-comment"># prologue wain</span>
<span class="hljs-comment"># wain's code</span>
<span class="hljs-comment"># epilogue wain</span>
jr <span class="hljs-variable">$31</span>

<span class="hljs-comment"># prologue f</span>
<span class="hljs-comment"># f's code</span>
<span class="hljs-comment"># epilogue f</span>
jr <span class="hljs-variable">$31</span>

...
</div></code></pre>
<p>for calling procedure <code>factor -&gt; ID(expr1, ..., exprn)</code>, with caller-save semantics for the frame pointer, we have</p>
<pre><code class="language-sh"><div>code(factor) =
    push(<span class="hljs-variable">$29</span>)       <span class="hljs-built_in">caller</span> save <span class="hljs-variable">$29</span>
    push(<span class="hljs-variable">$31</span>)

    code(expr1)     push arguments
    push(<span class="hljs-variable">$3</span>)
    ...
    code(exprn)
    push(<span class="hljs-variable">$3</span>)

    lis <span class="hljs-variable">$5</span>
    .word ID        procedure name
    jalr <span class="hljs-variable">$5</span>

    pop n <span class="hljs-built_in">times</span>     pop arguments

    pop(<span class="hljs-variable">$31</span>)
    pop(<span class="hljs-variable">$29</span>)
</div></code></pre>
<p>for defining a procedure <code>procedure -&gt; int ID ( params ) { dcls stmts RETURN expr; }</code>, we have</p>
<pre><code class="language-sh"><div>code(procedure) =
    ID:
    sub <span class="hljs-variable">$29</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>        assuming <span class="hljs-built_in">caller</span>-saves old frame pointer 
    push registers to save  assuming calle-saves registers
                            5, 6, 7
    code(dcls)
    code(stmts)
    code(expr)
    pop saved registers
    add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$29</span>, <span class="hljs-variable">$4</span>
    jr <span class="hljs-variable">$31</span>
</div></code></pre>
<p>when we call procedure, suppose we preserve $5,$6,$7 in the procedure, the stack layout is</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{ <span class="hljs-keyword">int</span> c = <span class="hljs-number">3</span>; <span class="hljs-keyword">int</span> d = <span class="hljs-number">4</span>; ... }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wain</span><span class="hljs-params">(...)</span> </span>{ foo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); ... }
</div></code></pre>
<p><img src="assets/w11_1.PNG" alt="img"></p>
<blockquote>
<p>parameter i is at 4(n−i+1) where n is the number of parameters. this gives us the offsets 4(21+1)=8 for a which is parameter 1 and 4(2-2+1)=4 for b which is parameter 2.<br>
local variable i is at −4r−4(i−1) where r is the number of registers to preserve. in the example above, r was 3 so local variable 1, ie c is at offset -4(3)-4(1-1)=-12 and local variable 2, ie d, is at offset -4(3)-4(2-1)=-16.</p>
</blockquote>
<h1 id="week-12-july-27">Week 12. July 27</h1>
<h2 id="compiler-optimizations">compiler optimizations</h2>
<h3 id="constant-folding">constant folding</h3>
<p><strong>eg.</strong> fold 1+2</p>
<pre><code class="language-sh"><div>original:
lis <span class="hljs-variable">$3</span> .word 1      <span class="hljs-comment"># code(1)</span>
sw <span class="hljs-variable">$3</span>, -4(<span class="hljs-variable">$30</span>)
sub <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>    <span class="hljs-comment"># push($3)</span>
lis <span class="hljs-variable">$3</span>
.word 2             <span class="hljs-comment"># code(2)</span>
lw <span class="hljs-variable">$5</span>, 0(<span class="hljs-variable">$30</span>)
add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>    <span class="hljs-comment"># pop($5)</span>
add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>      <span class="hljs-comment"># 1+2</span>

improved:
lis <span class="hljs-variable">$3</span>
.word 1             <span class="hljs-comment"># code(1)</span>
add <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>, <span class="hljs-variable">$0</span>
lis <span class="hljs-variable">$3</span>
.word 2             <span class="hljs-comment"># code(2)</span>
add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>

improved:
lis <span class="hljs-variable">$3</span>
.word 5
</div></code></pre>
<h3 id="constant-propagation">constant propagation</h3>
<p><strong>eg.</strong> fold <code>const int x = 1; return x + x;</code></p>
<pre><code class="language-sh"><div>original:
lis <span class="hljs-variable">$3</span>
.word 1
sw <span class="hljs-variable">$3</span>, -12(<span class="hljs-variable">$29</span>)     <span class="hljs-comment"># x at offset -12</span>
lw <span class="hljs-variable">$3</span>, -12(<span class="hljs-variable">$29</span>)     <span class="hljs-comment"># load operand 1</span>
sw <span class="hljs-variable">$3</span>, -4(<span class="hljs-variable">$30</span>)
sub <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>    <span class="hljs-comment"># push operand 1</span>
lw <span class="hljs-variable">$3</span>, -12(<span class="hljs-variable">$29</span>)     <span class="hljs-comment"># load operand 2</span>
lw <span class="hljs-variable">$5</span>, 0(<span class="hljs-variable">$30</span>)
add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>    <span class="hljs-comment"># pop operand 1</span>
add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>      <span class="hljs-comment"># x+x</span>

improved:
lis <span class="hljs-variable">$3</span>
.word 1
sw <span class="hljs-variable">$3</span>, -12(<span class="hljs-variable">$29</span>)
lis <span class="hljs-variable">$3</span>
.word 2
</div></code></pre>
<h3 id="eliminate-common-sub-expression">eliminate common sub-expression</h3>
<p><strong>eg.</strong> improve <code>x+x</code></p>
<pre><code class="language-sh"><div>original:
lw <span class="hljs-variable">$3</span>, -12(<span class="hljs-variable">$29</span>)     <span class="hljs-comment"># load operand 1</span>
sw <span class="hljs-variable">$3</span>, -4(<span class="hljs-variable">$30</span>)
sub <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>    <span class="hljs-comment"># push operand 1</span>
lw <span class="hljs-variable">$3</span>, -12(<span class="hljs-variable">$29</span>)     <span class="hljs-comment"># load operand 2</span>
lw <span class="hljs-variable">$5</span>, 0(<span class="hljs-variable">$30</span>)
add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>    <span class="hljs-comment"># pop operand 1</span>
add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>      <span class="hljs-comment"># x+x</span>

improved:
lw <span class="hljs-variable">$3</span>, -12(<span class="hljs-variable">$29</span>)
add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>
</div></code></pre>
<h3 id="eliminate-dead-code">eliminate dead code</h3>
<p><strong>eg.</strong></p>
<pre><code class="language-c"><div><span class="hljs-keyword">if</span> (a &lt; b) {
    <span class="hljs-keyword">if</span> (b &lt; a) {
        <span class="hljs-comment">// dead</span>
    } <span class="hljs-keyword">else</span> {}
} <span class="hljs-keyword">else</span> {}

<span class="hljs-keyword">int</span> x = <span class="hljs-number">5</span>;
<span class="hljs-keyword">int</span> y = <span class="hljs-number">10</span>;
<span class="hljs-keyword">if</span> (y &lt; <span class="hljs-number">2</span> * x) {
    <span class="hljs-comment">// dead</span>
} <span class="hljs-keyword">else</span> {}

<span class="hljs-keyword">int</span> z = <span class="hljs-number">0</span>;
<span class="hljs-comment">// never use z</span>
</div></code></pre>
<h3 id="allocate-registers">allocate registers</h3>
<blockquote>
<p>for efficiency it would be nice if the compiler could store all, or as many as possible, variables in registers</p>
</blockquote>
<h3 id="strength-reduction">strength reduction</h3>
<blockquote>
<p>in the real world, addition is much faster than multiplication. this means that it might be a good idea to replace multiplying with addition. a classic example is that instead of generating code for n*2, it is better to generate code for n+n</p>
</blockquote>
<p><strong>eg.</strong> n*2 to n+n</p>
<pre><code class="language-sh"><div>original:
load n into <span class="hljs-variable">$3</span>
sw <span class="hljs-variable">$3</span>, -4(<span class="hljs-variable">$30</span>)
sub <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>
lis <span class="hljs-variable">$3</span>
.word 2
lw <span class="hljs-variable">$5</span>, -4(<span class="hljs-variable">$30</span>)
add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$30</span>, <span class="hljs-variable">$4</span>
mult <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>
mflo <span class="hljs-variable">$3</span>

improved:
load n into <span class="hljs-variable">$3</span>
add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$3</span>, <span class="hljs-variable">$3</span>
</div></code></pre>
<h3 id="peephole-optimizations">peephole optimizations</h3>
<p>look for patterns in the generated code and replace with more efficient ones</p>
<p><strong>eg.</strong> a+b</p>
<pre><code class="language-sh"><div>original:
lw <span class="hljs-variable">$3</span>, offset_a(<span class="hljs-variable">$29</span>)
push(<span class="hljs-variable">$3</span>)
lw <span class="hljs-variable">$3</span>, offset_b(<span class="hljs-variable">$29</span>)
pop(<span class="hljs-variable">$5</span>)
add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>

after:
lw <span class="hljs-variable">$3</span>, offset_a(<span class="hljs-variable">$29</span>)
add <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>, <span class="hljs-variable">$0</span>
lw <span class="hljs-variable">$3</span>, offset_b(<span class="hljs-variable">$29</span>)
add <span class="hljs-variable">$3</span>, <span class="hljs-variable">$5</span>, <span class="hljs-variable">$3</span>
</div></code></pre>
<p>if the code is</p>
<ul>
<li>a push of a register value</li>
<li>some code that does not update the stack</li>
<li>a pop into a register</li>
</ul>
<p>we do not need to push and pop.</p>
<h3 id="inline-procedures">inline procedures</h3>
<pre><code class="language-c"><div><span class="hljs-comment">// original:</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>{ <span class="hljs-keyword">return</span> x + x; }
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{ <span class="hljs-keyword">return</span> foo(a); }

<span class="hljs-comment">// improved:</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">wain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>{ <span class="hljs-keyword">return</span> a + a; }
</div></code></pre>
<h3 id="tail-recursion">tail recursion</h3>
<p>we do not grow stack but reuse the current one. for <code>factor -&gt; ID(expr1, ..., exprn)</code> we have</p>
<pre><code class="language-sh"><div>code(factor) =
    code(expr1)
    sw <span class="hljs-variable">$3</span>, offset_param1(<span class="hljs-variable">$29</span>)
    ...
    code(exprn)
    sw <span class="hljs-variable">$3</span>, offset_paramn(<span class="hljs-variable">$29</span>)
    add <span class="hljs-variable">$30</span>, <span class="hljs-variable">$29</span>, <span class="hljs-variable">$4</span>            reset stack pointer to bottom of stack
    lis <span class="hljs-variable">$5</span>
    .word ID
    jr <span class="hljs-variable">$5</span>
</div></code></pre>
<p>that applies if the recursion is this pattern:</p>
<pre><code class="language-c"><div><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> acc)</span> </span>{
    <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) { ret = acc; }
    <span class="hljs-keyword">else</span> { ret = fact(n<span class="hljs-number">-1</span>, acc*n); }
    <span class="hljs-keyword">return</span> ret;
}
</div></code></pre>
<h3 id="overloading">overloading</h3>
<p><strong>eg.</strong> name mangling</p>
<pre><code class="language-c"><div><span class="hljs-comment">// before:</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> *b)</span></span>;

<span class="hljs-comment">// after:</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">F_foo</span><span class="hljs-params">()</span></span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fip_foo</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> *b)</span></span>;
</div></code></pre>
<h2 id="memory-management-heap">memory management: heap</h2>
<h3 id="freelist-algorithm">freelist algorithm</h3>
<p>the allocator begins with a linked list containing one node representing the entire pool of free memory. each block has</p>
<ul>
<li><code>free</code> pointer points to the start of the free block</li>
<li>first word in the block stores the amount of memory available in this block</li>
<li>second word is a pointer to the next free block (set to null at beginning)</li>
</ul>
<p><strong>eg.</strong>
initial memory of 1024 bytes:</p>
<pre><code><code><div>free
  v
  +----+-+--------------------------------------+
  |1024|/|               free                   |
  +----+-+--------------------------------------+
  &lt;---------------------------------------------&gt;
                     1024 bytes
</div></code></code></pre>
<p>after doing <code>A = new char[16], B = new char[28]</code>. note 4 bytes more is allocated at the front of each block, containing block size, the address returned to the user is after this word:</p>
<pre><code><code><div>                    free
                      v
  +---------+---------+---+-+--------------------+
  |    A    |    B    |972|/|                    |
  +---------+---------+---+-+--------------------+
  &lt;--------&gt;&lt;--------&gt;&lt;--------------------------&gt;
      20        32              972 bytes
</div></code></code></pre>
<p>after doing <code>free(A)</code>, this free block is added to the front of the free list:</p>
<pre><code><code><div>free       next free
  |   +---------------+
  v   |               v
  +--+-+----+---------+---+-+------------------+
  |20|*|    |    B    |972|/|                  |
  +--+-+----+---------+---+-+------------------+
</div></code></code></pre>
<p>after doing <code>free(B)</code>:</p>
<pre><code><code><div>free
  |   +-----+   +-----+
  v   |     v   |     v
  +--+-+----+--+-+----+---+-+-------------------+
  |20|*|    |32|*|    |972|/|                   |
  +--+-+----+--+-+----+---+-+-------------------+

</div></code></code></pre>
<p>at this point there are contiguous blocks, which can be merged into one.</p>
<p>problem: repeated allocation and deallocation creates &quot;holes&quot; in the heap.</p>
<p><strong>eg.</strong> different heuristics-based approaches</p>
<pre><code><code><div>+----+--+--------+--+-----+-------------+
|####|20|########|15|#####|     100     |
+----+--+--------+--+-----+-------------+
</div></code></code></pre>
<p>to allocate 10 bytes, options are</p>
<ul>
<li>first fit: find the first satisfying block: 20</li>
<li>best fit: leave smallest hole behind: 15</li>
<li>worst fit: find biggest block: 100</li>
</ul>
<h3 id="binary-buddy-system">binary buddy system</h3>
<p>only allocate blocks of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>. to request block of 20 bytes, will need to allocate 32 bytes. if it is available, use it, otherwise the smallest block bigger than 32 is split into &quot;buddies&quot; of the same size repeatedly.</p>
<p><strong>eg.</strong> first request 20 bytes, then 40 bytes</p>
<pre><code><code><div> A       B
+--+--+-----+-----------+------------------------+--------------------------------------------+
|32|32| 64  |    128    |         256            |                   512                      |
+--+--+-----+-----------+------------------------+--------------------------------------------+
codes:
100000 100001 10001 1001 101 11
</div></code></code></pre>
<blockquote>
<p>each block is assigned a code. the biggest initial block (1024 in eg) gets the code 1. when we break the block into two 512 byte nodes, the left buddy gets the code 10 and the right buddy the code 11. if the 10 block is split, the left buddy that is created gets the code 100 and the right buddy 101. note first, a block can ﬁnd its buddy by simply flipping its own last bit. second, if a block's code has n digits, the size of the block is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1024</mn><mi mathvariant="normal">/</mi><msup><mn>2</mn><mrow><mi>n</mi><mtext>−</mtext><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">1024/2^{n−1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">4</span><span class="mord">/</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span>.</p>
<p>when memory is allocated, the free list can be searched for an appropriate sized block. this search can be conducted by determining the number of digits expected in the block size to be allocated (eg to allocate a 32 byte block we need to look for a block which has 6 digits in its code). if the free list has a 6 digit code, that block is chosen. If such a block is not found, a block with the most digits still less than the digits we wanted is chosen and split, eg 5.</p>
<p>when a block is deallocated, the allocator can search for its buddy in the free list. if the buddy is found in the free block, the blocks are merged.</p>
</blockquote>
<p>disadvantage: causes internal fragmentation.</p>
<h3 id="garbage-collection">garbage collection</h3>
<h4 id="reference-counting"><em>reference counting</em></h4>
<ul>
<li>keeps track of the number of pointers that point to each block; whenever a block has reference ount 0, reclaim that memory</li>
<li>costs computational resources</li>
<li>problem: circular references</li>
</ul>
<h4 id="mark-and-sweep"><em>mark and sweep</em></h4>
<ul>
<li>
<blockquote>
<p>begins with a Mark phase where it discovers parts of the heap that are reachable from the stack and global variables. the entire stack (and global variables) are scanned for pointers leading into the heap. each such heap block is marked as reachable. if the marked heap blocks contain pointers, the algorithm repeatedly follows any such pointers to discover new parts of the heap that are also reachable.</p>
</blockquote>
</li>
<li>
<blockquote>
<p>once the entire reachable part of the heap has been marked, the algorithm conducts the sweep phase; any block that was not marked is deallocated.</p>
</blockquote>
</li>
<li>when gc runs, the program has to be stopped</li>
<li>works better when most objects survive collection</li>
</ul>
<h4 id="copying-collector"><em>copying collector</em></h4>
<ul>
<li>splits heap into two halves named <code>from</code> and <code>to</code>, memory is only allocated from the <code>from</code> part. when this half fills up, the gc copies the reachable parts from <code>from</code> to <code>to</code>, then reverse these rules.</li>
<li>problem: stop the world; halves the amount of the available memory</li>
<li>works well when few objects survive collection</li>
</ul>
<h1 id="week-13-august-3">Week 13. August 3</h1>
<h2 id="loading-and-linking">loading and linking</h2>
<h3 id="loader">loader</h3>
<p>the OS chooses programs and run them sequentially. pseudo-code for OS:</p>
<pre><code><code><div>repeat:
    p &lt;- choose program to run
    $3 &lt;- loader(p)
    jalr $3
    beq, $0, $0, repeat
</div></code></code></pre>
<p>loader:</p>
<pre><code class="language-cpp"><div>a = findFreeRAM(N)
<span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>, codeLength<span class="hljs-number">-1</span>:
    mem[a+<span class="hljs-number">4</span>i] = file[i]
$<span class="hljs-number">30</span> &lt;- a + N
<span class="hljs-keyword">return</span> a to OS
</div></code></pre>
<ul>
<li>loader searches for a block of memory big enough (N contiguous bytes) for program use</li>
<li>the starting address is denoted <code>a</code></li>
<li>ith word is copied to memory with this offset</li>
<li><code>$30</code> is initialized to be top of stack</li>
</ul>
<p>the memory assigned to the program includes instructions, stack, heap. can also have read-only data memory and global variables.</p>
<p>since in assemblied mips code, the start address is always assumed to be 0:</p>
<ul>
<li>only label assembler directive is affected</li>
<li><code>beq, a, b, label</code> is not affected as offsets are computed relatively</li>
<li><code>.word label</code> is affected and address is off by <code>a</code> -&gt; relocation needed</li>
</ul>
<p>so we have to process the code (add offset <code>a</code> to each label) so it can be run at different starting addresses.</p>
<p><strong>defn.</strong> <em>object code</em> contains machine code for the assembly program and additional needed by the loader and the linker.</p>
<h3 id="merl">MERL</h3>
<p>the assembler will generate MERL format instead of regular mips program.</p>
<p><strong>eg.</strong></p>
<pre><code class="language-sh"><div> not relocatable asm             MERL relocatable

                                0x00 beq <span class="hljs-variable">$0</span>, <span class="hljs-variable">$0</span>, 2          <span class="hljs-comment"># header</span>
                                0x04 .word endModule        <span class="hljs-comment">#</span>
                                0x08 .word endCode          <span class="hljs-comment">#</span>
0x00 lis <span class="hljs-variable">$3</span>                     0x0c lis <span class="hljs-variable">$3</span>
0x04 .word 0xabc                0x10 .word 0xabc
0x08 lis <span class="hljs-variable">$1</span>                     0x14 lis <span class="hljs-variable">$3</span>
0x0c .word A                    0x18 reloc1:  .word A
0x10 jr <span class="hljs-variable">$1</span>                      0x1c jr <span class="hljs-variable">$1</span>
     B:                              B:
0x14 jr <span class="hljs-variable">$31</span>                     0x20 jr <span class="hljs-variable">$31</span>
     A:                              A:
0x18 beq <span class="hljs-variable">$0</span>, <span class="hljs-variable">$0</span>, B              0x24 beq <span class="hljs-variable">$0</span>, <span class="hljs-variable">$0</span>, B
0x1c .word B                    0x28 reloc2: .word B
                                     endCode:               <span class="hljs-comment"># footer</span>
                                0x2c .word 1                <span class="hljs-comment">#</span>
                                0x30 .word reloc1           <span class="hljs-comment">#</span>
                                0x34 .word 1                <span class="hljs-comment">#</span>
                                0x38 .word reloc2           <span class="hljs-comment">#</span>
                                0x3c endModule              <span class="hljs-comment">#</span>
</div></code></pre>
<p>before any <code>.word </code> directive, a relocation label is prepended. footer have relocation entries, each entry consists of one word of 1 (REL to indicate this is an entry), followed by an address of a word that must be relocated.</p>
<p>can use this tool to create a MERL file</p>
<pre><code class="language-sh"><div>cs241.linkasm &lt; input.asm &gt; output.merl
</div></code></pre>
<p>to relocate a MERL file:</p>
<pre><code class="language-cpp"><div>read_word() <span class="hljs-comment">// skip first word</span>
<span class="hljs-keyword">auto</span> endMod = readWord() <span class="hljs-comment">// address of end of MERL file</span>
<span class="hljs-keyword">auto</span> codeSize = readWord() - <span class="hljs-number">12</span> <span class="hljs-comment">// use third word to compute size of code</span>
<span class="hljs-keyword">auto</span> a = findFreeRAM(codeSize)

<span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>, codeSize<span class="hljs-number">-1</span>, <span class="hljs-number">4</span>: <span class="hljs-comment">// load actual program starting from a</span>
    MEM[a+i] = readWord()

<span class="hljs-keyword">auto</span> i = codeSize + <span class="hljs-number">12</span> <span class="hljs-comment">// start of reloc table</span>
<span class="hljs-keyword">while</span> i &lt; endMod:
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">auto</span> format = readWord()) != <span class="hljs-number">1</span>:
        <span class="hljs-comment">/*not a reloc entry*/</span> <span class="hljs-keyword">throw</span>
    <span class="hljs-keyword">auto</span> loc = readWord() <span class="hljs-comment">// address to be relocated (relative to MERL)</span>
    MEM[a+loc<span class="hljs-number">-12</span>] += a<span class="hljs-number">-12</span>
    i += <span class="hljs-number">8</span>
</div></code></pre>
<p>never hard code addresses in <code>.word </code>, use labels instead.</p>
<p>can use this tool to relocate a MERL file</p>
<pre><code class="language-sh"><div>cs241.merl 0x1234 &lt; output.merl &gt; output.mips
</div></code></pre>
<h3 id="linking">linking</h3>
<p>we want to split assembly code to different files, need to resolve labels that are defined and used in different locations.</p>
<p>the file that uses label <code>proc</code>, <em>external symbol reference (ESR)</em> is used in the footer:</p>
<pre><code class="language-sh"><div> assembly                MERL

                        beq <span class="hljs-variable">$0</span>, <span class="hljs-variable">$0</span>, 2       <span class="hljs-comment"># header</span>
                        .word endModule     <span class="hljs-comment">#</span>
.import proc            .word endCode       <span class="hljs-comment">#</span>
lis <span class="hljs-variable">$1</span>                  lis <span class="hljs-variable">$1</span>
.word proc              use1: .word 0      <span class="hljs-comment"># placeholder for proc</span>
jalr <span class="hljs-variable">$1</span>                 jalr <span class="hljs-variable">$1</span>
                        endCode:            <span class="hljs-comment"># footer</span>
                        .word 0x11          <span class="hljs-comment"># format code for ESR</span>
                        .word use1          <span class="hljs-comment"># addr where proc is used</span>
                        .word 4             <span class="hljs-comment"># length of label</span>
                        .word 112           <span class="hljs-comment"># p</span>
                        .word 114           <span class="hljs-comment"># r</span>
                        .word 111           <span class="hljs-comment"># o</span>
                        .word 99            <span class="hljs-comment"># c</span>
                        endModule:
</div></code></pre>
<p>if <code>proc</code> is <code>import</code>-ed, it will be resolved at linking instead of being determined offset right away when assembling.</p>
<p>the filr that defines label <code>proc</code>, <em>external symbol definitions (ESD)</em> are used:</p>
<pre><code class="language-sh"><div> assembly                MERL

                        beq <span class="hljs-variable">$0</span>, <span class="hljs-variable">$0</span>, 2       <span class="hljs-comment"># header</span>
                        .word endModule     <span class="hljs-comment">#</span>
.<span class="hljs-built_in">export</span> proc            .word endCode       <span class="hljs-comment">#</span>
proc:                   proc:
jr <span class="hljs-variable">$31</span>                  jr <span class="hljs-variable">$31</span>
                        endCode:            <span class="hljs-comment"># footer</span>
                        .word 0x05          <span class="hljs-comment"># format code for ESD</span>
                        .word proc          <span class="hljs-comment"># addr where proc is defined</span>
                        .word 4             <span class="hljs-comment"># length of label</span>
                        .word 112           <span class="hljs-comment"># p</span>
                        .word 114           <span class="hljs-comment"># r</span>
                        .word 111           <span class="hljs-comment"># o</span>
                        .word 99            <span class="hljs-comment"># c</span>
                        endModule:
</div></code></pre>
<p>to link m1 and m2 in order and produce MERL, use algorithm:</p>
<pre><code class="language-cpp"><div><span class="hljs-keyword">auto</span> a = m1.endCode - <span class="hljs-number">12</span>
relocate m2.code by a
add a to each address in REL, ESR, ESD entries of m2
<span class="hljs-keyword">if</span> m1.exports ∩ m2.exports is <span class="hljs-keyword">not</span> Ø:
    <span class="hljs-keyword">throw</span>
<span class="hljs-comment">// dump labels defined in m2 to m1</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">auto</span> (addr1, label) in m1.imports:
    <span class="hljs-keyword">if</span> exists (<span class="hljs-keyword">auto</span> addr2, label) in m2.exports:
        m1.code[addr1] = addr2
        remove (addr1, label) from m1.imports
        add addr1 to m1.relocates
<span class="hljs-comment">// dump labels defined in m1 to m2</span>
<span class="hljs-keyword">for</span> <span class="hljs-keyword">auto</span> (addr2, label) in m2.imports:
    <span class="hljs-keyword">if</span> exists (<span class="hljs-keyword">auto</span> addr1, label) in m1.exports:
        m2.code[addr2] = addr1
        remove (addr2, label) from m2.imports
        add addr2 to m2.relocates
<span class="hljs-comment">// output MERL</span>
<span class="hljs-keyword">auto</span> imports = m1.imports ∪ m2.imports
<span class="hljs-keyword">auto</span> exports = m1.exports ∪ m2.exports
<span class="hljs-keyword">auto</span> relocates = m1.relocates ∪ m2.relocates
yield <span class="hljs-number">0x10000002</span>
yield <span class="hljs-number">12</span> + m1.codeSize + m2.codeSize + totalSize(imports, exports, relocates)
yield <span class="hljs-number">12</span> + m1.codeSize + m2.codeSize
yield m1 code
yield m2 code
yield imports, exports, relocates
</div></code></pre>
<p>the linked MERL file is:</p>
<pre><code class="language-sh"><div>beq <span class="hljs-variable">$0</span>, <span class="hljs-variable">$0</span>, 2       <span class="hljs-comment"># header</span>
.word endModule     <span class="hljs-comment">#</span>
.word endCode       <span class="hljs-comment">#</span>
lis <span class="hljs-variable">$1</span>
use1: .word 0x18
jalr <span class="hljs-variable">$1</span>
proc:
jr <span class="hljs-variable">$31</span>
endCode:            <span class="hljs-comment"># footer</span>
.word 0x05          <span class="hljs-comment"># ESD</span>
.word proc          <span class="hljs-comment">#</span>
.word 4             <span class="hljs-comment">#</span>
.word 112           <span class="hljs-comment">#</span>
.word 114           <span class="hljs-comment">#</span>
.word 111           <span class="hljs-comment">#</span>
.word 99            <span class="hljs-comment">#</span>
.word 0x01          <span class="hljs-comment"># REL</span>
.word use1          <span class="hljs-comment"># location to relocate</span>
endModule:          <span class="hljs-comment">#</span>
</div></code></pre>

    </body>
    </html>